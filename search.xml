<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Javascript执行上下文与闭包</title>
      <link href="/2023/06/22/Javascript%E9%97%AD%E5%8C%85%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
      <url>/2023/06/22/Javascript%E9%97%AD%E5%8C%85%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h2 id="Javascript执行上下文与闭包"><a href="#Javascript执行上下文与闭包" class="headerlink" title="Javascript执行上下文与闭包"></a>Javascript执行上下文与闭包</h2><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>说闭包之前先解释一下JavaScript的执行上下文，即作用域。</p><ol><li>全局作用域:默认环境，当我们第一次启动程序时，默认创建的全局作用域。</li><li>函数作用域:当执行流进入函数体时就会创建一个本地函数执行上下文，并压入栈中。</li><li>块级作用域:这是es6中新出的作用域，比如for循环、while循环、{}等都属于是块级作用域。<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3>知道了作用域之后，我们来看一下闭包的定义、作用以及使用场景：</li></ol><blockquote><p><strong>闭包定义</strong>：指的是那些引用了另一个函数作用域中变量的<strong>函数</strong>，通常是在嵌套函数中实现的。———-JS红宝书上面的解释</p></blockquote><blockquote><p><strong>个人理解</strong>：该作用域存在对上级作用域当中变量的引用即形成闭包。上级作用域内的变量，因为被下级作用域内引用，而没有被释放。就导致上级作用域内的变量，等到下级作用域执行完以后才正常得到释放（也就是说当解除了对该闭包的所有引用的时候，这个闭包才会被JS的垃圾回收机制回收）。</p></blockquote><p>下面我先给出一个看似闭包但不是闭包的例子，以助后面更好的认识以及理解闭包：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span><span class="token keyword">void</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> outerVariable<span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">innerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>      <span class="token keyword">let</span> innerVariable<span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>outerVariable <span class="token operator">+</span> innerVariable<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">innerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p> 在这个例子中，我们定义了一个外部函数 outerFunction，其中包含一个内部函数 innerFunction。在 outerFunction 中，我们直接调用了 innerFunction，而不是将其作为返回值或赋值给变量。<br>尽管 innerFunction 访问了 outerFunction 中的变量 outerVariable，但由于 innerFunction 在 outerFunction 内部被直接调用，而不是在外部作用域外被调用，它不满足闭包的条件。<br>在这个例子中，innerFunction 没有形成闭包，因为它没有在外部函数作用域外被调用，也没有捕获外部函数作用域的引用。<br>看一下运行效果：<br><img src="/img/context1.png" class="lazyload placeholder" data-srcset="/img/context1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果(伪闭包)"></p><p>可以看到，并没有实现闭包的效果，原因就是三次调用outerFunction函数，之间没有任何关系，每次执行完之后都会将该函数内部的变量回收。<br>下面我们改造一下这个函数，让其变成闭包：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token number">1</span> <span class="token keyword">function</span> <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span><span class="token keyword">Function</span> <span class="token punctuation">{</span><span class="token number">2</span>    <span class="token keyword">let</span> outerVariable <span class="token punctuation">:</span><span class="token keyword">number</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token number">3</span>    <span class="token keyword">function</span> <span class="token function">innerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span><span class="token keyword">number</span><span class="token punctuation">{</span><span class="token number">4</span>      <span class="token keyword">let</span> innerVariable <span class="token punctuation">:</span><span class="token keyword">number</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token number">5</span>       outerVariable <span class="token operator">++</span><span class="token number">6</span>      <span class="token keyword">return</span> <span class="token punctuation">(</span>outerVariable <span class="token operator">+</span> innerVariable<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">7</span>    <span class="token punctuation">}</span><span class="token number">8</span>    <span class="token keyword">return</span> innerFunction<span class="token punctuation">;</span><span class="token number">9</span> <span class="token punctuation">}</span><span class="token number">10</span> <span class="token keyword">const</span> closure <span class="token punctuation">:</span><span class="token keyword">Function</span> <span class="token operator">=</span> <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">11</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">closure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">12</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">closure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">13</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">closure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>先看一下执行的结果：<br><img src="/img/context2.png" class="lazyload placeholder" data-srcset="/img/context2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="修改为闭包之后的执行结果"></p><p>修改之处在于，我们将 innerFunction 返回并赋值给 closure 变量，并在外部调用 closure()。<br>现在，closure 变量中保存的是 innerFunction，它实际上是一个闭包。在调用 closure() 时，innerFunction 可以访问其定义时所在的外部函数 outerFunction 的作用域，即可以访问 outerVariable。这样，我们就创建了一个闭包，使得 innerFunction 在外部函数作用域外仍然能够访问和操作其引用的变量。<br>通过这种方式，我们确保了 innerFunction 在外部函数作用域外被调用时仍然可以访问外部变量，满足了闭包的条件。</p><h3 id="剖析执行过程"><a href="#剖析执行过程" class="headerlink" title="剖析执行过程"></a>剖析执行过程</h3><ul><li>第 1-9行。我们在全局执行上下文中创建了一个新的变量outerFunction，并赋值了一个的函数定义。</li><li>第10行。我们在全局执行上下文中声明了一个名为closure的新变量。</li><li>第11行。我们需要调用outerVariable 函数并将其返回值赋给closure变量。</li><li>第 1-9行。调用函数，创建新的本地执行上下文。</li><li>第2行。在本地执行上下文中，声明一个名为outerVariable 的新变量并赋值为 1;</li><li>第 3-7行。声明一个名为myFunction的新变量，变量在本地执行上下文中声明,变量的内容是为第4-6行所定义。</li><li>第8行。返回innerFunction变量的内容，删除本地执行上下文。变量innerFunction和outerVariable 不再存在。</li><li>第10行。在调用上下文(全局执行上下文)中，outerFunction返回的值赋给了closure，变量closure现在包含一个函数定义内容为outerFunction返回的函数。它不再标记为innerFunction，但它的定义是相同的。这个closure就相当于是闭包的引用，如果该变量一直引用着，则这个闭包会一直存在于内存当中，不会被垃圾回收机制标记为垃圾。</li><li>第11行。查找closure变量，它是一个函数并调用它。它包含前面返回的函数定义，除此之外它还有一个带有变量的闭包</li><li>创建一个新的执行上下文。没有参数，开始执行函数。</li><li>第四行，声明了一个innerVariable变量并赋值20</li><li>第五行，寻找变量outerVariable，在查找当前作用域和上级作用域之前，会先检查一下闭包当中有没有，找到了，然后执行+1操作，然后将其再次存储到闭包当中，待下次使用。</li><li>第六行，返回outerVariable + innerVariable的值，然后销毁当前上下文。</li><li>回到第11行，打印出22.</li><li>接下来就是第12行和第13行就是重复步骤执行第11行代码的执行步骤，实现递增的效果。分别打印出23，24.</li></ul><blockquote><p><strong>闭包的作用</strong>：保护函数的私有变量不受外界干扰；将上级作用域的引用保存下来，实现方法或者属性的私有化；实现模块化</p></blockquote><blockquote><p><strong>闭包的缺点</strong>：使用不当，会造成内存泄漏。</p></blockquote><p>下面是一个使用闭包不当造成内存泄漏的例子：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> outerVariable <span class="token operator">=</span> <span class="token string">'1'</span><span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">innerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> innerVariable <span class="token operator">=</span> <span class="token string">'1'</span><span class="token punctuation">;</span>    <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    outerVariable<span class="token operator">++</span>    innerVariable<span class="token operator">++</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>outerVariable <span class="token operator">+</span> innerVariable<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">innerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在这个例子中，我们定义了一个外部函数 outerFunction，其中包含一个内部函数 innerFunction。在 innerFunction 中，我们使用 setInterval 创建了一个定时器，每秒钟输出 outerVariable 和 innerVariable 的值。<br>由于定时器的回调函数形成了闭包，它可以访问 outerVariable 和 innerVariable，即使 innerFunction 已经执行完毕。这导致闭包中引用的变量无法被垃圾回收，因为定时器仍然持有对闭包的引用。<br>如果我们多次调用 outerFunction，每次调用都会创建一个新的定时器，并且每个定时器都会保留对其自己的闭包的引用。这会导致内存泄漏，因为闭包中引用的变量无法被释放。<br>为了避免内存泄漏，要记得清除定时器。<br><img src="/img/context3.png" class="lazyload placeholder" data-srcset="/img/context3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="执行结果"></p><blockquote><p><strong>闭包的使用场景</strong>：节抖或防流；自执行函数以及回调函数等</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typescript </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构八大排序之快速排序算法</title>
      <link href="/2023/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2023/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构八大排序之快速排序算法"><a href="#数据结构八大排序之快速排序算法" class="headerlink" title="数据结构八大排序之快速排序算法"></a>数据结构八大排序之快速排序算法</h2><blockquote><p>算法思想如下:<br>1、选择基准元素：从待排序的数组中选择一个元素作为基准（pivot）。可以选择数组的第一个元素、最后一个元素或者随机位置的元素作为基准。<br>2、划分操作：将数组中的其他元素按照与基准的大小关系进行划分，将比基准小的元素放在基准的左侧，比基准大的元素放在基准的右侧。同时，基准元素所在的位置也确定了。<br>3、递归排序：对基准元素左侧和右侧的子数组分别进行递归调用快速排序算法，重复上述步骤，直到子数组的长度为1或0（即已经有序）。<br>4、合并结果：递归调用的过程中，子数组的排序会不断地将基准元素放置在正确的位置上，最终整个数组就变为有序。</p></blockquote><h3 id="该算法在前端中的应用"><a href="#该算法在前端中的应用" class="headerlink" title="该算法在前端中的应用"></a>该算法在前端中的应用</h3><p>目前我知道的：js的数组操作方法sort这个api的实现原理就是快速排序算法。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 快速排序算法 </span><span class="token keyword">function</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span><span class="token keyword">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>type<span class="token punctuation">:</span>SortType<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 当数组中只有一项则直接返回 且也是结束递归的出口</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> arr    <span class="token comment" spellcheck="true">// 基准元素的索引</span>    <span class="token keyword">const</span> pivotIndex <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 基准元素的值</span>    <span class="token keyword">const</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>pivotIndex<span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// 将小于基准元素的值放入该数组中</span>    <span class="token keyword">const</span> less<span class="token punctuation">:</span><span class="token keyword">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// 将等于基准元素的值放入该数组中</span>    <span class="token keyword">const</span> equal<span class="token punctuation">:</span><span class="token keyword">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// 将大于基准元素的值放入该数组中</span>    <span class="token keyword">const</span> greater<span class="token punctuation">:</span><span class="token keyword">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// 遍历数组进行切分 </span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> element of arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span>element <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span><span class="token operator">?</span> less<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">:</span>undefined<span class="token punctuation">;</span>        <span class="token punctuation">(</span>element <span class="token operator">></span> pivot<span class="token punctuation">)</span><span class="token operator">?</span> greater<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">:</span>undefined<span class="token punctuation">;</span>        <span class="token punctuation">(</span>element <span class="token operator">==</span> pivot<span class="token punctuation">)</span><span class="token operator">?</span> equal<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">:</span>undefined    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 升序排列 递归</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>type<span class="token operator">==</span>SortType<span class="token punctuation">.</span>Asc<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token function">quickSort</span><span class="token punctuation">(</span>less<span class="token punctuation">,</span>SortType<span class="token punctuation">.</span>Asc<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">...</span>equal<span class="token punctuation">,</span><span class="token operator">...</span><span class="token function">quickSort</span><span class="token punctuation">(</span>greater<span class="token punctuation">,</span>SortType<span class="token punctuation">.</span>Asc<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// 降序排列</span>    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token function">quickSort</span><span class="token punctuation">(</span>greater<span class="token punctuation">,</span>SortType<span class="token punctuation">.</span>Desc<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">...</span>equal<span class="token punctuation">,</span><span class="token operator">...</span><span class="token function">quickSort</span><span class="token punctuation">(</span>less<span class="token punctuation">,</span>SortType<span class="token punctuation">.</span>Desc<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h3 id="算法的使用"><a href="#算法的使用" class="headerlink" title="算法的使用"></a>算法的使用</h3><p>以下面这个数组为例子，算法接收两个参数，第一个参数是待排序的数组，第二个参数指定待排序的规则（升序还是降序).</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> sortArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span></code></pre><p>实现数组升序排列：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> newArr <span class="token operator">=</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>sortArr<span class="token punctuation">,</span>SortType<span class="token punctuation">.</span>Asc<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'使用快速排序实现数组的升序排列'</span><span class="token punctuation">,</span>newArr<span class="token punctuation">)</span></code></pre><p><img src="/img/quick1.png" class="lazyload placeholder" data-srcset="/img/quick1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"></p><p>实现数组降序排列：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> newArr <span class="token operator">=</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>sortArr<span class="token punctuation">,</span>SortType<span class="token punctuation">.</span>Desc<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'使用快速排序实现数组的降序排列'</span><span class="token punctuation">,</span>newArr<span class="token punctuation">)</span></code></pre><p><img src="/img/quick2.png" class="lazyload placeholder" data-srcset="/img/quick2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"></p><h3 id="执行过程详解"><a href="#执行过程详解" class="headerlink" title="执行过程详解"></a>执行过程详解</h3><p>1、选择基准元素：在这个例子中，我们选择数组的第一个元素作为基准，即 5。</p><p>2、划分操作：将数组中的其他元素按照与基准的大小关系进行划分。比基准小的元素放在基准的左侧，比基准大的元素放在基准的右侧。</p><ul><li>第一次划分：将数组划分为 [3, 2, 1]、[5]、[6, 9] 三部分。</li><li>第二次划分：对左侧的子数组 [3, 2, 1] 进行划分，得到 [2, 1]、[3]。</li><li>第三次划分：对右侧的子数组 [6, 9] 进行划分，得到 [6]、[9]。<br>最终的划分结果为 [2, 1, 3, 5, 6, 9]。</li></ul><p>3、递归排序：对基准元素左侧和右侧的子数组分别进行递归调用快速排序算法。<br>对左侧子数组 [2, 1, 3] 进行快速排序。</p><ul><li>选择基准元素 2。<br>划分结果为 [1]、[2]、[3]。<br>对右侧子数组 [6, 9] 进行快速排序。</li><li>选择基准元素 6。<br>划分结果为 [6]、[9]。<br>4、合并结果：递归调用的过程中，子数组的排序会不断地将基准元素放置在正确的位置上，最终整个数组就变为有序。</li></ul><p>最终排序结果为 [1, 2, 3, 5, 6, 9]。<br>选择基准元素，这个元素尽量能将数组划分成两个相同长度的表，长度越接近越好，因为这样可以减少递归的深度，节省性能，</p><p>假如你选择的基准元素不好，我们来调试一下，看一下效果：<br><img src="/img/quick3.png" class="lazyload placeholder" data-srcset="/img/quick3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="调试基准元素"><br>上面的情况是对于数组几乎有序或者已经有序，并且每次基准元素选择数组的第一项的时候，这时候性能开销最大，==其时间复杂度为O(n²)==，当然如果数据量小，那确实无所谓，几乎看不出什么。<br>下面是选择基准元素适中的情况，我们再来看一下运行过程中的状态:<br><img src="/img/quick4.png" class="lazyload placeholder" data-srcset="/img/quick4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="调试基准元素"><br>两图对比一下，第二张图，基准元素选择适中，递归深度减少一半，性能开销小，两个子表几乎相同，==其时间复杂度为O(nlogn)==，这就等同于一颗二叉树，左孩子与右孩子高度相同，它相比于第一张图的单只树(只有右孩子没有左孩子)，那肯定是单只树的性能开销比较大。当数据量过大的时候，受基准元素选择不好以及待排序数组的影响，爆栈都有可能。</p><h3 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h3><p>快速排序算法的性能在八大排序中算得上是优秀的。<br>其平均时间复杂度是O(nlogn) 。其中划分子表的时间复杂度是logn级别，对子表排序的时间复杂度是n级别。<br>空间复杂度是O(n),开辟了三个长度为n的数组，总体为O(n)级别.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Typescript </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构八大排序之冒泡排序算法</title>
      <link href="/2023/06/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2023/06/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构八大排序之冒泡排序算法"><a href="#数据结构八大排序之冒泡排序算法" class="headerlink" title="数据结构八大排序之冒泡排序算法"></a>数据结构八大排序之冒泡排序算法</h2><blockquote><p>需求：用户传入数字类型的数组，并传入排序规则（升序还是降序），实现数组排列，要求使用typescript实现</p></blockquote><p>首先对传入的排序规则参数做一下约束，提高程序健壮性。rt</p><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 定义枚举类型，规定接收的排序规则参数只能是特定的值</span><span class="token keyword">enum</span> SortType <span class="token punctuation">{</span>    Asc <span class="token operator">=</span> <span class="token string">'asc'</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//升序</span>    Desc <span class="token operator">=</span> <span class="token string">'desc'</span> <span class="token comment" spellcheck="true">//降序</span><span class="token punctuation">}</span></code></pre><p>下面是算法的实现过程，它接收两个参数，数组和排序规则</p><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 传入的arr必须为数组类型，type参数表示要升序还是降序，且成员是数字，函数返回值为数字数组</span><span class="token keyword">function</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span><span class="token keyword">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>type<span class="token punctuation">:</span>SortType<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> length <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 用来判断某轮对比是否发生了交换</span>        <span class="token keyword">let</span> isExchange <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 外层循环每执行完一轮都能确定一个元素的最终位置，所以要减去i轮，这里再减1是因为每次都是用下标j和j+1进行比较的</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>length<span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>type<span class="token operator">===</span>SortType<span class="token punctuation">.</span>Asc<span class="token punctuation">)</span><span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">// 使用解构赋值来进行交换，使得代码更加简洁</span>                <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">(</span><span class="token punctuation">[</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>isExchange <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">:</span>undefined            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>type<span class="token operator">===</span>SortType<span class="token punctuation">.</span>Desc<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">(</span><span class="token punctuation">[</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>isExchange <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">:</span>undefined               <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 发生了交换，此时还不能确定排序是否完成,还需要进行下一轮循环</span>            isExchange <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果某轮循环没有发生元素的交换，则表示排序已经完成，直接结束算法执行返回数组</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>isExchange<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">}</span></code></pre><p>当中使用了一个变量isExchange 来判断此轮循环是否发生了元素交换，如果没有，则可以立马结束算法，节省了一定的性能。<br>下面是算法的执行过程，拿【5，3，6，2，9，1】来做演示实现升序排列：<br>第一轮冒泡：<br>比较 5 和 3，交换位置：[3, 5, 6, 2, 9, 1]<br>比较 5 和 6，不交换位置：[3, 5, 6, 2, 9, 1]<br>比较 6 和 2，交换位置：[3, 5, 2, 6, 9, 1]<br>比较 6 和 9，不交换位置：[3, 5, 2, 6, 9, 1]<br>比较 9 和 1，交换位置：[3, 5, 2, 6, 1, 9]<br>第二轮冒泡：<br>比较 3 和 5，不交换位置：[3, 5, 2, 6, 1, 9]<br>比较 5 和 2，交换位置：[3, 2, 5, 6, 1, 9]<br>比较 5 和 6，不交换位置：[3, 2, 5, 6, 1, 9]<br>比较 6 和 1，交换位置：[3, 2, 5, 1, 6, 9]<br>第三轮冒泡：<br>比较 3 和 2，交换位置：[2, 3, 5, 1, 6, 9]<br>比较 3 和 5，不交换位置：[2, 3, 5, 1, 6, 9]<br>比较 5 和 1，交换位置：[2, 3, 1, 5, 6, 9]<br>第四轮冒泡：<br>比较 2 和 3，不交换位置：[2, 3, 1, 5, 6, 9]<br>比较 3 和 1，交换位置：[2, 1, 3, 5, 6, 9]<br>第五轮冒泡：<br>比较 2 和 1，交换位置：[1, 2, 3, 5, 6, 9]<br>最终排序结果应该是：[1, 2, 3, 5, 6, 9]</p><p>下面是该算法的使用以及真机的运行结果：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> sortArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">const</span> newArr <span class="token operator">=</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>sortArr<span class="token punctuation">,</span>SortType<span class="token punctuation">.</span>Asc<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newArr<span class="token punctuation">)</span></code></pre><p><img src="/img/sort1.png" class="lazyload placeholder" data-srcset="/img/sort1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"><br>升序排列</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> newArr <span class="token operator">=</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>sortArr<span class="token punctuation">,</span>SortType<span class="token punctuation">.</span>Desc<span class="token punctuation">)</span></code></pre><p><img src="/img/sort2.png" class="lazyload placeholder" data-srcset="/img/sort2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"><br>降序排列</p><p><strong>总结一下：</strong></p><p>时间复杂度：该算法的最好时间复杂度是O(n),也就是当待排序数组基本按序排列时；最坏时间复杂度为O(n²) ，也就是当数组完全逆序时。平均复杂度为O(n²)。<br>空间复杂度:该算法只创建了常量级别的变量，因此空间复杂度为O(1)。<br>稳定性:当遇到数组当中又两个相同的值的时候，默认不交换位置，因此该算法是稳定的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Typescript </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组件化，模块化，高内聚和低耦合</title>
      <link href="/2023/06/19/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E9%AB%98%E5%86%85%E8%81%9A%E5%92%8C%E4%BD%8E%E8%80%A6%E5%90%88%E7%9B%B8%E5%85%B3/"/>
      <url>/2023/06/19/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E9%AB%98%E5%86%85%E8%81%9A%E5%92%8C%E4%BD%8E%E8%80%A6%E5%90%88%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><blockquote><p>下面是我看了相关的文章与解答总结出来的自己的看法：<br>组件化：对于Vue中中的组件化来说就是整合HTML css js在一个文件中，拥有特定的基础功能<br>我认为组件化开发的好处主要是：<br>1、增加程序的可维护性；<br>2、代码的复用性；<br>3、拆分成单个组件使得每个组件拥有独立的状态和数据，避免了全局变量污染。<br>4、有利于提升渲染性能，实现局部刷新</p></blockquote><p>  对于第一点增加程序的可维护性，尤其当开发大型应用的时候，程序中有大量的变量以及函数，如果不采用组件化的开发，当某个数据发生改变时，就要更新整个页面的内容，浪费的不必要的性能，而且在变量命名的时候也会令人有些恼头，容易造成命名冲突等问题，当项目越来越大的时候，容易出现bug，维护性相对较差。<br>对于第二点来说，当这个项目中很多页面都需要用到相同的组件的时候，如果不采用组件化，那只能重写，造成代码冗余，降低开发效率。<br>对于第三点和第四点来说，Vue的每个组件都拥有独立的数据和状态，是互不干扰的，每个组件是一个watcher，当这个组件中的数据更新的时候，只需重新渲染这一个组件的区域，提升了渲染性能，做到了局部刷新。</p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><blockquote><p>模块化，在前端这边可以单独对css，js等进行单独封装成单个文件，具有某个特定的功能。比如我们项目中的utils工具文件等等<br>模块化的好处：<br>1、方便代码的复用、可读性，减少代码冗余度，提高开发效率，模块化使得代码结构更清晰和模块间的关系更明确，代码更易读、易理解。方便代码的维护和交接。<br>2、可维护性：将大文件拆解成小文件，增加可读性，每个模块可拥有独特的功能，当某个功能出现了问题，可以统一得到解决，也方便找到问题所在位置。</p></blockquote><h2 id="高内聚与低耦合"><a href="#高内聚与低耦合" class="headerlink" title="高内聚与低耦合"></a>高内聚与低耦合</h2><blockquote><p>我理解的高内聚的定义是：组件或模块内部的元素（例如函数、类、方法）彼此关联紧密，<strong>共同完成一个明确的最终目标（功能）</strong>。高内聚意味着组件内的元素具有相似的功能、目的或责任，相关的代码被组织在一起，更容易定位和修改。<br>低耦合：彼此之间相对独立，相互之间的影响较小，<strong>每个组件或者模块单独完成最终目标中的一个小目标（功能）</strong>，且修改一个组件不会对其他组件造成太大的影响，可扩展性与灵活性好。</p></blockquote><p>为了更好的理解，我拿笔记本电脑来举个简单的例子，一个笔记本电脑的实现就等同于一个最终功能–供人使用，它需要硬件和软件来支撑这个最终功能，在这高内聚就体现为电脑的一个个零件，网卡、声卡、显卡、CPU等，它们分别实现某个特定的小功能（专精），当你的网卡坏了，你上不了网了，你第一时间会想到的就是网卡相关的部件以及关联的软件配置是否出现故障，这就体现了上面提到的高内聚更容易定位故障产生的位置，这就是高内聚。<br>但是呢单独一个零件又不能发挥什么作用，这些零件只是具有某个单独的功能，需要各个零件之间的合作与配合，才能组成一个完整的笔记本，才能拥有完整的功能，假如某一天你觉得CPU的性能不太好了，你想升级一下，那你只需要动CPU零件，其他零件受到的影响很小，这就是低耦合。<br>总之，代码的高内聚就是相关功能的代码组合在一起，实现某个特定的小功能，各个小功能需要关联起来才能实现整个大功能。<br>代码的低耦合就是某个特定的小功能的修改与变更对其他模块影响很小，方便针对某个单独的功能进行维护与更新。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端工程化 </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Grid布局</title>
      <link href="/2023/06/17/CSS%20Grid%E5%B8%83%E5%B1%80%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/06/17/CSS%20Grid%E5%B8%83%E5%B1%80%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-Grid布局的使用"><a href="#CSS-Grid布局的使用" class="headerlink" title="CSS Grid布局的使用"></a>CSS Grid布局的使用</h1><p>介绍之前，先了解一下该门技术的优缺点，看自己是否值得学习，优缺点如下：</p><blockquote><p>优点：CSS Grid布局是一种用于创建网页布局的强大工具。它引入了一个二维网格系统，可以以行和列的形式创建布局，提供了更灵活和精确的控制，并且减少了不必要的一些计算。<br>缺点：兼容性问题：CSS Grid布局是在CSS3中引入的较新的特性，因此旧版本的浏览器可能不支持它或支持有限。</p></blockquote><h2 id="具体的使用"><a href="#具体的使用" class="headerlink" title="具体的使用"></a>具体的使用</h2><p>  <strong>布局效果如下：（利用grid布局）</strong><br> <img src="/img/result.png" class="lazyload placeholder" data-srcset="/img/result.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="效果图"><br>上图利用grid栅格系统，从上到下共三个部分，nav main footer<br>1、nav部分四个button独占一行，先看下nav部分具体的代码，再做介绍：</p><pre class=" language-css"><code class="language-css"><span class="token selector">nav</span><span class="token punctuation">{</span>    <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>    <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">4</span>,<span class="token number">1</span>fr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token property">gap</span><span class="token punctuation">:</span> <span class="token number">10</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面代码的意思是生成一行四列的表格，每列平摊空间，每个格子之间的间距为10px，且nav的宽度会根据屏幕的宽度进行自适应。<br> 2、main部分代码如下：</p><pre class=" language-css"><code class="language-css"><span class="token selector">main</span><span class="token punctuation">{</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">450</span>px<span class="token punctuation">;</span>    <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>    <span class="token property">gap</span><span class="token punctuation">:</span> <span class="token number">20</span>px<span class="token punctuation">;</span>    <span class="token property">grid-template-areas</span><span class="token punctuation">:</span> <span class="token string">'banner banner banner banner banner box-r-top'</span>    <span class="token string">'banner banner banner banner banner box-r-bottom'</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面是main部分，使用grid布局，其中grid-template-areas将main元素分割为两行六列的栅格，并使用命名空间分别占据main的空间，下面是内部的三个元素使用空间的代码：</p><pre class=" language-css"><code class="language-css"><span class="token selector">main li<span class="token pseudo-class">:first-child</span></span><span class="token punctuation">{</span>     <span class="token property">grid-area</span><span class="token punctuation">:</span> banner<span class="token punctuation">;</span>     <span class="token property">background</span><span class="token punctuation">:</span> <span class="token url">url(./banner.jpg)</span><span class="token punctuation">;</span>     <span class="token property">background-size</span><span class="token punctuation">:</span> cover<span class="token punctuation">;</span>     <span class="token property">background-position</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">main button</span><span class="token punctuation">{</span>     <span class="token property">color</span><span class="token punctuation">:</span> <span class="token function">var</span><span class="token punctuation">(</span>--light<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面的grid-area是用来占用空间的，它的值填写grid-template-areas的某个值，比如写banner就会占据main的所有命名空间名称是banner的位置。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Grid </tag>
            
            <tag> 网站布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue组件通讯</title>
      <link href="/2023/06/16/Vue%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/06/16/Vue%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue组件的三种常用的传值方式在日常工作中是用的非常多的，非常重要！"><a href="#Vue组件的三种常用的传值方式在日常工作中是用的非常多的，非常重要！" class="headerlink" title="Vue组件的三种常用的传值方式在日常工作中是用的非常多的，非常重要！"></a>Vue组件的三种常用的传值方式在日常工作中是用的非常多的，非常重要！</h2><blockquote><p>在进行下面的介绍之前，首先要搞清楚什么是父组件，子组件和兄弟组件，下面是他们的介绍</p></blockquote><ol><li><strong>父组件向子组件传值</strong><br>父组件向子组件共享传递数据需要使用自定义属性，示例代码如下：</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//父组件里面的主要内容</span><span class="token comment" spellcheck="true">//使用子组件，自定义属性名称将父组件的两个数据暴露给子组件，例如//我这使用了msg和user,然后子组件中同样使用msg与user接收数据，</span><span class="token comment" spellcheck="true">//同样注意是通过数据绑定的方式传递</span><span class="token operator">&lt;</span>Child <span class="token punctuation">:</span>msg<span class="token operator">=</span><span class="token string">"message"</span> <span class="token punctuation">:</span>user<span class="token operator">=</span><span class="token string">"suerinfo"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>Child<span class="token operator">></span><span class="token comment" spellcheck="true">//下面这一行是引入子组件,子组件的定义名称为Child，之后记得注册</span><span class="token keyword">import</span> Child <span class="token keyword">from</span> <span class="token string">'./路径名/child.vue'</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">{</span>        message<span class="token punctuation">:</span><span class="token string">'hello vue.js'</span>        userinfo<span class="token punctuation">:</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span><span class="token string">'hh'</span><span class="token punctuation">,</span>age<span class="token punctuation">:</span><span class="token number">20</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//子组件里面的内容</span><span class="token operator">&lt;</span>template<span class="token operator">></span>    <span class="token operator">&lt;</span>view<span class="token operator">></span>        <span class="token operator">&lt;</span>p<span class="token operator">></span>父组件传递过来的msg值<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">{</span>msg<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>        <span class="token operator">&lt;</span>p<span class="token operator">></span>父组件传递过来的user值<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">{</span>user<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>view<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token comment" spellcheck="true">//通过自定义属性接收父组件传过来的参数,这里的属性名称一定要与父组件保持一致（msg,user）,注意不要更改props里面的属性值，因为里面的属性是只读的，同时修改之后这样也会导致父子组件的值不同。</span>props<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'msg'</span><span class="token punctuation">,</span><span class="token string">'user'</span><span class="token punctuation">]</span></code></pre><p>最后简单总结就是：父组件绑定自定义属性，传值；子组件在props里面声明。<br> 2.  <strong>子组件向父组件传值</strong><br>子组件向父组件共享传递数据使用自定义事件。示例代码如下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//子组件(child.vue)中的内容</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span> child_data_<span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>child_data<span class="token operator">+</span><span class="token operator">=</span><span class="token number">2</span>            <span class="token comment" spellcheck="true">//第一步</span>            <span class="token comment" spellcheck="true">//子组件修改数据时，通过$emit()触发自定义事件</span>            <span class="token comment" spellcheck="true">//这里填写监听事件与想要传递给父组件的数据</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'dataChange'</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>child_data<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//父组件中的内容</span><span class="token comment" spellcheck="true">//第二步</span><span class="token comment" spellcheck="true">//其实就等于事件监听，监听子组件中的child_data的数据变化)</span><span class="token operator">&lt;</span>Child @datachange <span class="token operator">=</span> <span class="token string">"change"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>Child<span class="token operator">></span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span> fahter_data <span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//第三步</span>        <span class="token function">change</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//这里的val其实就是子组件传递过来的child_data</span>            <span class="token comment" spellcheck="true">//下面这句代码说白了就是起到一个转存的作用</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>father_data <span class="token operator">=</span> val        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p> 3.<strong>兄弟组件之间的数据传值</strong><br> 在vue2.x的版本中，兄弟组件之间的数据共享使用的是EventBus<br> 基本步骤：</p><ul><li>建立eventBus.js模块，并向外共享一个Vue的实例对象</li><li>在发送方组件中调用EventBus.$emit（‘事件名称’，要发送的数据）来触发自定义事件</li><li>在接收方组件，调用EventBus.$on(‘事件名称’，事件处理函数)<br>来注册一个自定义事件</li></ul><p>下面是示例代码：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//兄弟组件（数据发送方）</span><span class="token keyword">import</span> eventBus <span class="token keyword">from</span> <span class="token string">'./eventBus.js'</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>            data<span class="token punctuation">:</span><span class="token string">'hello'</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">snedData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            eventBus<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'share'</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//eventBus.js</span><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token comment" spellcheck="true">//向外共享Vue的实例对象</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">vue</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//兄弟组件（数据接收方）</span><span class="token keyword">import</span> eventBus <span class="token keyword">from</span> <span class="token string">'./eventBus.js'</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>            receive_data<span class="token punctuation">:</span><span class="token string">' '</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        eventBus<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'share'</span><span class="token punctuation">,</span>val <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>receive_data <span class="token operator">=</span> val        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后简单总结三种传值关系就是：<br>父向子传数据使用自定义属性<br>子向父传数据使用自定义事件<br>兄弟组件之间传送数据使用EventBus</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 组件通讯 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
