<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ES5如何实现继承</title>
      <link href="/2023/07/25/ES5%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/"/>
      <url>/2023/07/25/ES5%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="ES5如何实现继承"><a href="#ES5如何实现继承" class="headerlink" title="ES5如何实现继承"></a>ES5如何实现继承</h2><blockquote><p>共有四种方式实现原型继承–原型链继承、构造函数继承、组合式继承、寄生式继承，下面我一一介绍，分别就实现以及特性分别展开来描述</p></blockquote><h3 id="原型链继承方式"><a href="#原型链继承方式" class="headerlink" title="原型链继承方式"></a>原型链继承方式</h3><blockquote><p>原理：将子类的原型对象指向一个父类的实例。通过这样的赋值，子类继承了父类的所有属性和方法，因为它的原型对象指向了一个父类实例，所以可以通过原型链访问到父类原型上的所有属性和方法。</p></blockquote><p>看下面的示例代码：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//父类</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'kitty'</span>  <span class="token comment" spellcheck="true">//基本数据类型</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>hobby <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'eat'</span><span class="token punctuation">,</span><span class="token string">'drink'</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">//引用数据类型</span><span class="token punctuation">}</span>Animal<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">}</span>Animal<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getHobby <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>hobby<span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//子类</span>Cat<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  Cat<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token keyword">constructor</span> <span class="token operator">=</span> Cat  <span class="token keyword">const</span> m1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> m2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>m1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'m1'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m1<span class="token punctuation">.</span>hobby<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'sleep'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m1<span class="token punctuation">.</span><span class="token function">getHobby</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m2<span class="token punctuation">.</span><span class="token function">getHobby</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>下面是运行结果：<br><img src="/img/extend1.png" class="lazyload placeholder" data-srcset="/img/extend1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="原型链继承运行结果"></p><h5 id="原因探究："><a href="#原因探究：" class="headerlink" title="原因探究："></a>原因探究：</h5><p>对于上面这个例子，我们分别对父类的两个不同的类型的属性进行修改，其中，一个是基本数据类型，另一个是引用数据类型，根据就运行结果可以发现，我们创建了两个cat子类，均通过原型链的继承方式，对Animal实现了继承，然后通过m1对引用数据类型hobby做出修改，之后再分别调用m1和m2的getHobby方法获取各自的hobby属性，发现m2的hobby属性也被修改了，这就暴露了原型链继承方式的缺点之一—-共享属性和方法，因为你的将子类（cat）的原型对象指向了父类（Animal）的同一个实例对象，也就是说你创建的所有cat对象的原型都是指向的同一个父类的实例对象，这意味着如果一个实例修改了原型上的属性，其他实例也会受到影响。<br>但再瞅一眼，为什么name没有发生这种问题呢？这是因为name是基本数据类型，如果属性是基本数据类型而不是引用类型，原型链继承就不存在共享属性问题，每个实例都会拥有独立的副本，也就是说m1.name = ‘m1’这句代码，会在当前m1的对象上新增一个name属性，然后赋值为’m1’,并不会影响到它原型上面的name属性，当打印m2.name的时候，因为m2本身没有name属性，那它就会去它的原型对象上去找这个属性，在这个例子中，也就是父类的name（’kitty’）。<br><img src="/img/extend2.png" class="lazyload placeholder" data-srcset="/img/extend2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="直接赋值，只是在当前对象本身上新增一个属性，并没影响到原型链上的属性"></p><h5 id="实现核心"><a href="#实现核心" class="headerlink" title="实现核心:"></a>实现核心:</h5><pre class=" language-typescript"><code class="language-typescript">Cat<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  Cat<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token keyword">constructor</span> <span class="token operator">=</span> Cat  </code></pre><p>Cat.prototype = new Animal():<br>这一行代码意味着将 Cat 的原型对象指向一个 Animal 的实例。通过这样的赋值，Cat 继承了 Animal 的所有属性和方法。<br>Cat.prototype.constructor = Cat:<br>这一行代码是为了修正因为前一步赋值导致的 constructor 属性被重写的问题。在第一步赋值后，Cat.prototype 的 constructor 属性会指向 Animal 的构造函数，即 Animal 函数。但实际上，我们希望 Cat.prototype.constructor 指向 Cat 构造函数本身，以保持对象的正确构造。<br>因此，通过显式赋值将 Cat.prototype.constructor 重新指向 Cat 构造函数，这样就纠正了原型链中的 constructor 属性。</p><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>1、共享属性和方法：<br>使用原型链继承时，子类的实例共享父类原型上的属性和方法。这意味着如果一个实例修改了原型上的属性，其他实例也会受到影响。这可能导致意外的副作用和不稳定的行为。<br>2、无法向父类构造函数传递参数：<br>在原型链继承中，子类通过继承父类的实例来实现继承，并没有直接调用父类构造函数。因此，无法直接向父类构造函数传递参数，导致在子类构造函数中无法完成父类构造函数的初始化操作。<br>3、无法实现多继承：<br>原型链继承只能继承一个父类的属性和方法，无法同时继承多个父类，这限制了它的灵活性。<br>4、子类无法重写父类的属性和方法，没有实现super方法：<br>如果子类的原型上定义了与父类相同名称的属性或方法，那么它会覆盖父类的属性和方法。这可能导致不可预期的行为，使代码难以维护和调试。</p><h3 id="构造函数继承方式"><a href="#构造函数继承方式" class="headerlink" title="构造函数继承方式"></a>构造函数继承方式</h3><blockquote><p>原理:在子类的构造函数中执行父类的构造函数，并为其绑定子类的this，避免了不同实例之间共享同一个原型实例，并且可以向父类的构造函数中传参,但是继承不到父类原型的属性和方法。</p></blockquote><p>看下面示例代码：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token comment" spellcheck="true">//基本数据类型</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>hobby <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'eat'</span><span class="token punctuation">,</span><span class="token string">'drink'</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">//引用数据类型</span><span class="token punctuation">}</span>Animal<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">}</span>Animal<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getHobby <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>hobby<span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 继承不到父类原型的属性和方法</span>    Animal<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>arguments<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">const</span> m1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">'m1'</span><span class="token punctuation">)</span><span class="token keyword">const</span> m2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">'m2'</span><span class="token punctuation">)</span>m1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'m1'</span><span class="token comment" spellcheck="true">// console.log(m1.getName());  //报错 Uncaught TypeError: m1.getName is not a function</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m1<span class="token punctuation">.</span>name<span class="token punctuation">,</span>m2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>m1<span class="token punctuation">.</span>hobby<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'sleep'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m1<span class="token punctuation">.</span>hobby<span class="token punctuation">,</span>m2<span class="token punctuation">.</span>hobby<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="/img/extend3.png" class="lazyload placeholder" data-srcset="/img/extend3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"></p><h6 id="原因探究：-1"><a href="#原因探究：-1" class="headerlink" title="原因探究："></a>原因探究：</h6><p>为什么调用不到父类原型上的方法呢？<br>原因是在使用构造函数继承时，子类实例只能继承父类构造函数内部设置的属性，而无法继承父类原型上的属性和方法。这是因为 Animal.apply(this, arguments) 调用的是父类构造函数，而不是父类原型上的方法。<br>实际上，使用构造函数继承时，创建的子类实例和父类实例是相互独立的，它们没有共享父类原型上的方法。这导致子类实例无法继承父类原型上的属性和方法。</p><h5 id="实现核心："><a href="#实现核心：" class="headerlink" title="实现核心："></a>实现核心：</h5><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 继承不到父类原型的属性和方法</span>    Animal<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>arguments<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>避免了不同实例之间共享同一个原型实例，实例对象之间修改属性值，不会相互影响。</p><h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><p>继承不到父类原型上的属性和方法。</p><h3 id="组合式继承方式"><a href="#组合式继承方式" class="headerlink" title="组合式继承方式"></a>组合式继承方式</h3><blockquote><p>原理：原型链继承方式+构造函数继承方式结合体</p></blockquote><p>看下面示例代码：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name  <span class="token comment" spellcheck="true">//基本数据类型</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>hobby <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'eat'</span><span class="token punctuation">,</span><span class="token string">'drink'</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">//引用数据类型</span><span class="token punctuation">}</span>Animal<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">}</span>Animal<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getHobby <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>hobby<span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Animal<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>arguments<span class="token punctuation">)</span><span class="token punctuation">}</span>Cat<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span>Cat<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token keyword">constructor</span> <span class="token operator">=</span> Cat<span class="token keyword">const</span> m1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">'m1'</span><span class="token punctuation">)</span><span class="token keyword">const</span> m2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">'m2'</span><span class="token punctuation">)</span>m1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'m1'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m1<span class="token punctuation">.</span>hobby<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'sleep'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m1<span class="token punctuation">.</span><span class="token function">getHobby</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m2<span class="token punctuation">.</span><span class="token function">getHobby</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="/img/extend4.png" class="lazyload placeholder" data-srcset="/img/extend4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"><br>打印其中一个子类实例对象看一下：<br><img src="/img/extend5.png" class="lazyload placeholder" data-srcset="/img/extend5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="子类实例对象的原型"></p><h5 id="原因探究：-2"><a href="#原因探究：-2" class="headerlink" title="原因探究："></a>原因探究：</h5><p>每次创建子类实例的时候，都执行了两次父类的构造函数（new Animal()与Animal.apply(this,arguments)），但是并不影响使用。</p><h5 id="实现核心：-1"><a href="#实现核心：-1" class="headerlink" title="实现核心："></a>实现核心：</h5><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Animal<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>arguments<span class="token punctuation">)</span><span class="token punctuation">}</span>Cat<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span>Cat<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token keyword">constructor</span> <span class="token operator">=</span> Cat</code></pre><h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><p>解决了原型链继承方式+构造函数继承方式出现的缺点</p><h5 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h5><p>重复执行了父类的构造函数，导致子类实例对象原型上的方法重复，不是特别的优雅。</p><h3 id="寄生式继承方式"><a href="#寄生式继承方式" class="headerlink" title="寄生式继承方式"></a>寄生式继承方式</h3><blockquote><p>原理：在组合式继承的基础上进行修改，将子类的原型对象指向父类的原型并不是父类实例的原型，从而减少一次父类构造函数的执行，子类实例并不直接继承父类原型上的方法。它只是创建了一个新对象，该对象的原型链中仅包含父类原型上的属性和方法。因此，它并不是传统意义上的原型链继承。</p></blockquote><p>看下面示例代码：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name  <span class="token comment" spellcheck="true">//基本数据类型</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>hobby <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'eat'</span><span class="token punctuation">,</span><span class="token string">'drink'</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">//引用数据类型</span><span class="token punctuation">}</span>Animal<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">}</span>Animal<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getHobby <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>hobby<span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Animal<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>arguments<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Object.create 创建的新对象是浅拷贝,也就是说它只复制对象的属性引用，而不会复制属性的值</span>Cat<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Animal<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>Cat<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token keyword">constructor</span> <span class="token operator">=</span> Cat<span class="token keyword">const</span> m1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">'m1'</span><span class="token punctuation">)</span><span class="token keyword">const</span> m2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">'m2'</span><span class="token punctuation">)</span>m1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'修改了m1'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m1<span class="token punctuation">.</span>hobby<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'sleep'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m1<span class="token punctuation">.</span><span class="token function">getHobby</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m2<span class="token punctuation">.</span><span class="token function">getHobby</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="/img/extend6.png" class="lazyload placeholder" data-srcset="/img/extend6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"></p><h5 id="实现核心：-2"><a href="#实现核心：-2" class="headerlink" title="实现核心："></a>实现核心：</h5><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Animal<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>arguments<span class="token punctuation">)</span><span class="token punctuation">}</span>Cat<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Animal<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>Cat<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token keyword">constructor</span> <span class="token operator">=</span> Cat</code></pre><h5 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h5><p>解决了父类构造函数被执行两次的问题，且该种方法是es5中最成熟的继承方式。</p><p>over———————————————————————————————————</p>]]></content>
      
      
      <categories>
          
          <category> Typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript严格模式以及this指向</title>
      <link href="/2023/07/14/Javascript%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8Athis%E6%8C%87%E5%90%91/"/>
      <url>/2023/07/14/Javascript%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8Athis%E6%8C%87%E5%90%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>看下面代码的输出</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token string">"use strict"</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span>info<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>info<span class="token punctuation">,</span><span class="token string">'开启严格模式'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>test<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token string">'使用call解决严格模式this指向报错问题'</span><span class="token punctuation">)</span><span class="token keyword">const</span> obj  <span class="token operator">=</span> <span class="token punctuation">{</span>    fn1 <span class="token punctuation">:</span> <span class="token punctuation">(</span>info<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>info<span class="token punctuation">)</span><span class="token punctuation">,</span>    fn2 <span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>info<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span>obj<span class="token punctuation">.</span><span class="token function">fn1</span><span class="token punctuation">(</span><span class="token string">'obj直接调用fn1'</span><span class="token punctuation">)</span>obj<span class="token punctuation">.</span><span class="token function">fn2</span><span class="token punctuation">(</span><span class="token string">'obj直接调用fn2'</span><span class="token punctuation">)</span><span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">obj<span class="token punctuation">.</span>fn2</span><span class="token punctuation">(</span><span class="token string">'使用new运算符，将fn2看为类'</span><span class="token punctuation">)</span><span class="token keyword">const</span> y <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">obj<span class="token punctuation">.</span>fn1</span><span class="token punctuation">(</span><span class="token string">'使用new运算符，将fn1看为类'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span></code></pre><p>在上面的代码中，obj对象包含两个方法fn1和fn2，fn1是一个箭头函数，而fn2使用普通函数的形式定义。</p><p>对于箭头函数，它没有自己的this值，它会捕获上下文中的this，因此fn1中的this指向的是全局对象window（当开启严格模式时，指向的是undefined）。<br>对于普通函数，它的this值是在运行时动态绑定的。因此，当我们调用obj.fn2()时，输出结果是obj，因为是obj调用的这个函数。</p><p>对于const x = new obj.fn2()，因为fn2是一个普通函数，new运算符可以正确的创建实例，并且this值指向新创建的实例对象（即是一个包含fn2方法的对象）；<br>对于const y = new obj.fn1()，因为fn1是一个箭头函数，它没有自己的构造函数，也没有自己的this值，素以在使用new运算符创建实例会报错。运行结果如下图所示：<br><img src="/img/strict.png" class="lazyload placeholder" data-srcset="/img/strict.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"></p>]]></content>
      
      
      <categories>
          
          <category> Typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写Promise及其API</title>
      <link href="/2023/07/01/%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0%EF%BC%9A%E6%89%8B%E5%86%99Promise%E5%8F%8A%E5%85%B6API/"/>
      <url>/2023/07/01/%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0%EF%BC%9A%E6%89%8B%E5%86%99Promise%E5%8F%8A%E5%85%B6API/</url>
      
        <content type="html"><![CDATA[<h2 id="手写Promise及其API"><a href="#手写Promise及其API" class="headerlink" title="手写Promise及其API"></a>手写Promise及其API</h2><h3 id="Promise构造函数"><a href="#Promise构造函数" class="headerlink" title="Promise构造函数"></a>Promise构造函数</h3><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// promise的构造函数，同步执行</span><span class="token comment" spellcheck="true">// executor===(resolve,reject)=>{}</span><span class="token keyword">function</span> <span class="token function">Promise</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Promise的内置属性 PromiseState与PromiseResult的初始化</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>PromiseState <span class="token operator">=</span> <span class="token string">'pending'</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>PromiseResult <span class="token operator">=</span> <span class="token keyword">null</span>    <span class="token keyword">const</span> self <span class="token operator">=</span> <span class="token keyword">this</span>    <span class="token comment" spellcheck="true">// 缓存then的回调函数，用于异步执行</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>callback <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>PromiseState <span class="token operator">!==</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token keyword">return</span>        self<span class="token punctuation">.</span>PromiseState <span class="token operator">=</span> <span class="token string">'fulfilled'</span>        self<span class="token punctuation">.</span>PromiseResult <span class="token operator">=</span> data        <span class="token comment" spellcheck="true">// 因为then的执行是异步的</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        self<span class="token punctuation">.</span>callback<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            item<span class="token punctuation">.</span><span class="token function">resolved</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>     <span class="token punctuation">}</span>    <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>PromiseState <span class="token operator">!==</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token keyword">return</span>        self<span class="token punctuation">.</span>PromiseState <span class="token operator">=</span> <span class="token string">'rejected'</span>        self<span class="token punctuation">.</span>PromiseResult <span class="token operator">=</span> data        <span class="token comment" spellcheck="true">// 因为then的执行是异步的</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            self<span class="token punctuation">.</span>callback<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                item<span class="token punctuation">.</span><span class="token function">rejected</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 立即执行传入Promise里的执行器函数</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token function">executor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="实例方法then"><a href="#实例方法then" class="headerlink" title="实例方法then"></a>实例方法then</h3><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">//实例方法 接收两个回调函数，成功的回调和失败的回调</span>Promise<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>then <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>resolved<span class="token punctuation">,</span>rejected<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> self <span class="token operator">=</span> <span class="token keyword">this</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> resolved <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        resolved <span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span> value <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> value<span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> rejected <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        rejected <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span> reason <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">throw</span> reason<span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token keyword">function</span> <span class="token function">callbackFn</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>             <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token function">type</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>PromiseResult<span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token keyword">instanceof</span> <span class="token class-name">Promise</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>v<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                    <span class="token function">resolve</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                    <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>            <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>             <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>PromiseState<span class="token operator">==</span><span class="token string">'pending'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>callback<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>resolved<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">callbackFn</span><span class="token punctuation">(</span>resolved<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>rejected<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">callbackFn</span><span class="token punctuation">(</span>rejected<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>PromiseState<span class="token operator">==</span><span class="token string">'fulfilled'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token function">callbackFn</span><span class="token punctuation">(</span>resolved<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>PromiseState<span class="token operator">==</span><span class="token string">'rejected'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token function">callbackFn</span><span class="token punctuation">(</span>rejected<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="实例方法catch"><a href="#实例方法catch" class="headerlink" title="实例方法catch"></a>实例方法catch</h3><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">//实例方法 接受一个失败的回调函数</span>Promise<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token keyword">catch</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>rejected<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>undefined<span class="token punctuation">,</span>rejected<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="静态方法resolve"><a href="#静态方法resolve" class="headerlink" title="静态方法resolve"></a>静态方法resolve</h3><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 静态方法 返回值为一个Promise实例</span>Promise<span class="token punctuation">.</span>resolve <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token keyword">instanceof</span> <span class="token class-name">Promise</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>v<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token function">resolve</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="静态方法reject"><a href="#静态方法reject" class="headerlink" title="静态方法reject"></a>静态方法reject</h3><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 静态方法 返回值为一个Promise实例</span>Promise<span class="token punctuation">.</span>reject <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="静态方法all"><a href="#静态方法all" class="headerlink" title="静态方法all"></a>静态方法all</h3><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 静态方法 接受一个由promise组成的数组 返回值为一个Promise实例 若成功则结果值为一个Pormise,这个promise的结果值为一个数组,存放的为每个promise实例的成功的结果值,若失败则返回为最先失败的那个Promise实例</span>Promise<span class="token punctuation">.</span>all <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>PromiseArr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>PromiseArr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            PromiseArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>v<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                count<span class="token operator">++</span>                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> v                <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">===</span> PromiseArr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token function">resolve</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="静态方法race"><a href="#静态方法race" class="headerlink" title="静态方法race"></a>静态方法race</h3><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 静态方法 接受一个由promise组成的数组 返回结果为最先改变状态的promise</span>Promise<span class="token punctuation">.</span>race <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>PromiseArr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>PromiseArr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            PromiseArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>v<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token function">resolve</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="使用es6的class实现Promise"><a href="#使用es6的class实现Promise" class="headerlink" title="使用es6的class实现Promise"></a>使用es6的class实现Promise</h3><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Promise</span><span class="token punctuation">{</span>    <span class="token keyword">constructor</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>PromiseState <span class="token operator">=</span> <span class="token string">'pending'</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>PromiseResult <span class="token operator">=</span> <span class="token keyword">null</span>        <span class="token keyword">const</span> self <span class="token operator">=</span> <span class="token keyword">this</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>callback <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>PromiseState <span class="token operator">!==</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token keyword">return</span>            self<span class="token punctuation">.</span>PromiseState <span class="token operator">=</span> <span class="token string">'fulfilled'</span>            self<span class="token punctuation">.</span>PromiseResult <span class="token operator">=</span> data            <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            self<span class="token punctuation">.</span>callback<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                item<span class="token punctuation">.</span><span class="token function">resolved</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>         <span class="token punctuation">}</span>        <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>PromiseState <span class="token operator">!==</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token keyword">return</span>            self<span class="token punctuation">.</span>PromiseState <span class="token operator">=</span> <span class="token string">'rejected'</span>            self<span class="token punctuation">.</span>PromiseResult <span class="token operator">=</span> data            <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                self<span class="token punctuation">.</span>callback<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                    item<span class="token punctuation">.</span><span class="token function">rejected</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>                    <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token function">executor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">then</span><span class="token punctuation">(</span>resolved<span class="token punctuation">,</span>rejected<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">const</span> self <span class="token operator">=</span> <span class="token keyword">this</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> resolved <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            resolved <span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span> value <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> value<span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> rejected <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            rejected <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span> reason <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">throw</span> reason<span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">function</span> <span class="token function">callbackFn</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                 <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token function">type</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>PromiseResult<span class="token punctuation">)</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token keyword">instanceof</span> <span class="token class-name">Promise</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>v<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                        <span class="token function">resolve</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>                    <span class="token punctuation">}</span><span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                        <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>                    <span class="token punctuation">}</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                    <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>                <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                   <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>                 <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>PromiseState<span class="token operator">==</span><span class="token string">'pending'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>callback<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>resolved<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">callbackFn</span><span class="token punctuation">(</span>resolved<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>rejected<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">callbackFn</span><span class="token punctuation">(</span>rejected<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>PromiseState<span class="token operator">==</span><span class="token string">'fulfilled'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                    <span class="token function">callbackFn</span><span class="token punctuation">(</span>resolved<span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>PromiseState<span class="token operator">==</span><span class="token string">'rejected'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                    <span class="token function">callbackFn</span><span class="token punctuation">(</span>rejected<span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span><span class="token punctuation">(</span>rejected<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>undefined<span class="token punctuation">,</span>rejected<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token keyword">instanceof</span> <span class="token class-name">Promise</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>v<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                    <span class="token function">resolve</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                    <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token function">all</span><span class="token punctuation">(</span>PromiseArr<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>PromiseArr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                PromiseArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>v<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                    count<span class="token operator">++</span>                    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> v                    <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">===</span> PromiseArr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token function">resolve</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                    <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token function">race</span><span class="token punctuation">(</span>PromiseArr<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>PromiseArr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                PromiseArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>v<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                    <span class="token function">resolve</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                    <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端实现元素水平垂直居中的九种方式</title>
      <link href="/2023/07/01/%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E4%B9%9D%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2023/07/01/%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E4%B9%9D%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="前端实现元素水平垂直居中的九种方式"><a href="#前端实现元素水平垂直居中的九种方式" class="headerlink" title="前端实现元素水平垂直居中的九种方式"></a>前端实现元素水平垂直居中的九种方式</h2><p>这是我的HTML结构：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>parent<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>child<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p>下面是我的CSS代码，分为九种方式实现：</p><ol><li>定位+margin:auto （推荐）<pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>        <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>        <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>        <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token selector"><span class="token class">.child</span></span><span class="token punctuation">{</span>        <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>        <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token property">bottom</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token property">right</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>        <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>        <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> brown<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre></li><li>定位+transform （推荐）</li></ol><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>            <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token selector"><span class="token class">.child</span></span><span class="token punctuation">{</span>            <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>            <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>            <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>            <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-<span class="token number">50%</span>,-<span class="token number">50%</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> brown<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><ol start="3"><li>定位+margin</li></ol><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>            <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token selector"><span class="token class">.child</span></span><span class="token punctuation">{</span>            <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>            <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>            <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>            <span class="token property">margin-left</span><span class="token punctuation">:</span>-<span class="token number">50</span>px<span class="token punctuation">;</span>            <span class="token property">margin-top</span><span class="token punctuation">:</span> -<span class="token number">50</span>px<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> brown<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><ol start="4"><li>定位+calc</li></ol><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>            <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token selector"><span class="token class">.child</span></span><span class="token punctuation">{</span>            <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span> */            <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>            <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>            <span class="token property">margin-left</span><span class="token punctuation">:</span><span class="token function">calc</span><span class="token punctuation">(</span>-<span class="token number">50</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token property">margin-top</span><span class="token punctuation">:</span> <span class="token function">calc</span><span class="token punctuation">(</span>-<span class="token number">50</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/* 上面四行等同于下面两行 注意:使用calc的时候，运算符两边要留个空格，否则效果不会出现 */</span>            <span class="token property">top</span><span class="token punctuation">:</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token number">50%</span> - <span class="token number">50</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token property">left</span><span class="token punctuation">:</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token number">50%</span> - <span class="token number">50</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> brown<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><ol start="5"><li>flex （推荐）</li></ol><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>            <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>            <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token selector"><span class="token class">.child</span></span><span class="token punctuation">{</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> brown<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><ol start="6"><li>grid</li></ol><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>            <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>            <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token selector"><span class="token class">.child</span></span><span class="token punctuation">{</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> brown<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><ol start="7"><li>table-cell+vertical-align: middle</li></ol><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>            <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span>   //或者使用line-height代替            <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token selector"><span class="token class">.child</span></span><span class="token punctuation">{</span>            <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> brown<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><ol start="8"><li>table-cell+line-height</li></ol><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>            <span class="token property">line-height</span><span class="token punctuation">:</span><span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token selector"><span class="token class">.child</span></span><span class="token punctuation">{</span>            <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> brown<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><ol start="9"><li>flex+margin:auto （推荐） </li></ol><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token selector"><span class="token class">.child</span></span><span class="token punctuation">{</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> brown<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><p>好了，以上就是实现元素水平垂直居中的九种方式，亲自在浏览器中调试过了，都是没有问题的，具体代码文件已经上传。</p>]]></content>
      
      
      <categories>
          
          <category> HTML&amp;CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML&amp;CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise异步编程的应用</title>
      <link href="/2023/06/29/Promise%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2023/06/29/Promise%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Promise异步编程的应用"><a href="#Promise异步编程的应用" class="headerlink" title="Promise异步编程的应用"></a>Promise异步编程的应用</h2><h3 id="Promise出现的原因或者它的出现为了解决什么问题"><a href="#Promise出现的原因或者它的出现为了解决什么问题" class="headerlink" title="Promise出现的原因或者它的出现为了解决什么问题"></a>Promise出现的原因或者它的出现为了解决什么问题</h3><p>在Promise出现之前，解决异步问题的方式通常是用回调函数的方式来解决的，看下面几个例子：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// fs文件操作 第二个参数为指定的回调函数</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'./index.html'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// AJAX 第三个参数为指定的回调函数</span>$<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/server'</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>data<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 定时器相关 第一个参数就是指定的回调函数</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span></code></pre><p>那回调函数的方式就可以解决异步的问题，那为什么还要使用Promise呢，下面是传统的回调函数方法解决异步的缺点：</p><blockquote><p>1、可读性差（回调地狱）：回调地狱的代码嵌套深度高，导致代码难以理解和阅读。每个异步操作的回调函数需要嵌套在前一个异步操作的回调函数中，使得代码结构变得复杂。<br>2、错误处理困难：在回调地狱中，错误处理通常需要在每个回调函数中进行，容易出现遗漏或混乱。当出现错误时，追踪和调试问题变得困难，尤其是当错误处理代码也被嵌套在多个层级中时。<br>3、难以维护：由于代码结构复杂，回调地狱中的代码修改和维护都会变得困难。如果需要添加、修改或删除某个异步操作，可能需要修改多个嵌套的回调函数，增加了代码的脆弱性。<br>4、缺乏顺序控制：在回调地狱中，异步操作的执行顺序通常由回调函数的嵌套关系决定，使得代码的执行流程不易理解和控制。特别是在有多个异步操作需要按特定顺序执行的情况下，代码会变得混乱。</p></blockquote><p>使用Promise就可以解决上面的问题,下面展开Promise相关的内容.<br><img src="/img/promise1.png" class="lazyload placeholder" data-srcset="/img/promise1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Promise"><br>对于一个Promise来说，他有两个内置属性，分别为：PromiseState与PromiseResult。</p><ol><li>PromiseState：表示 Promise 的当前状态，它可以有以下三个可能的取值：<br>“pending”：Promise 正在进行中，尚未完成或被拒绝。<br>“fulfilled”：Promise 已成功完成，即已被解析。<br>“rejected”：Promise 被拒绝，即出现了错误或异常。</li><li>PromiseResult：表示 Promise 的最终结果值，它的值取决于 Promise 的状态。如果 Promise 被成功解析（fulfilled），则该属性将包含解析后的值。如果 Promise 被拒绝（rejected），则该属性将包含拒绝的原因。<br>还有一点就是一个Promise实例的状态只能改变一次，且只能从Pending到fulfilled或者从Pending到rejected。</li></ol><h3 id="Promise的工作流程"><a href="#Promise的工作流程" class="headerlink" title="Promise的工作流程"></a>Promise的工作流程<img src="/img/promise2.png" class="lazyload placeholder" data-srcset="/img/promise2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Promise的工作流程"></h3><h3 id="Promise的构造函数的组成"><a href="#Promise的构造函数的组成" class="headerlink" title="Promise的构造函数的组成"></a>Promise的构造函数的组成</h3><p>Promise(executor){}</p><ol><li>executor函数:执行器函数 (resolve,reject)=&gt;{]</li><li>resolve函数:内部定义成功时我们调用的函数</li><li>reject()函数:内部定义失败时我们调用的函数<br>注:executor执行器函数是同步调用的，如下例：<pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span></code></pre>运行结果:<br><img src="/img/promise3.png" class="lazyload placeholder" data-srcset="/img/promise3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"><h3 id="Promise-resolve（）"><a href="#Promise-resolve（）" class="headerlink" title="Promise.resolve（）"></a>Promise.resolve（）</h3>对于这个静态方法，如果传入的参数是一个非 Promise 对象（比如一个普通的值或一个 对象），那么返回的 Promise 对象将会处于已解决（fulfilled）状态，并且它的值将是传入的参数。<br>如果传入的参数是一个 Promise 对象，那么 Promise.resolve 方法将直接返回这个 Promise 对象，则返回的 Promise 对象的状态就是内部这个promise的状态，<br>看代码：</li></ol><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token function">reject</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span></code></pre><p>输出结果如下:<br><img src="/img/promise4.png" class="lazyload placeholder" data-srcset="/img/promise4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="输出结果"></p><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h3><p>对于这个方法，无论传入的参数是什么，Promise.reject 方法返回的 Promise 对象都将处于已拒绝（rejected）状态。传入的参数将成为拒绝原因，可以通过 Promise 对象的 catch 方法或 onRejected 回调函数来处理。</p><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><p>Promise.all 方法是一个静态方法，用于处理多个 Promise 对象，并返回一个新的 Promise 对象。它接受一个可迭代的对象（比如数组）作为参数，该可迭代对象包含了多个 Promise 对象。<br>如果传入的可迭代对象是空的，则 Promise.all 立即返回一个已解决（fulfilled）状态的 Promise 对象，且该 Promise 对象的值是一个空数组 []。</p><pre class=" language-typescript"><code class="language-typescript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p><img src="/img/promise5.png" class="lazyload placeholder" data-srcset="/img/promise5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Promise.all"><br>如果传入的可迭代对象中的所有 Promise 对象都处于已解决状态，则 Promise.all 返回的 Promise 对象也会处于已解决状态，并且它的值是一个与传入的 Promise 对象顺序相对应的值数组。<br>如果传入的可迭代对象中的任何一个 Promise 对象处于已拒绝状态，则 Promise.all 返回的 Promise 对象会立即处于已拒绝状态，并且它的拒绝原因是第一个被拒绝的 Promise 对象的拒绝原因。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> p1 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">const</span> p2 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">const</span> p3 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">,</span>p3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//[1,2,3]</span><span class="token punctuation">}</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">,</span>p3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>下面是运行结果:<br><img src="/img/promise6.png" class="lazyload placeholder" data-srcset="/img/promise6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"><br>当其中有reject的promise时又是怎样的呢，看下面的例子：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> p1 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">const</span> p2 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">const</span> p3 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">,</span>p3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p><img src="/img/promise7.png" class="lazyload placeholder" data-srcset="/img/promise7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"><br>可以看到它的拒绝原因是第一个被拒绝的 Promise 对象的拒绝原因。</p><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p>Promise.race 方法是一个静态方法，用于处理多个 Promise 对象，并返回一个新的 Promise 对象。它接受一个可迭代的对象（比如数组）作为参数，该可迭代对象包含了多个 Promise 对象。<br>Promise.race 方法的行为如下：<br>如果传入的可迭代对象是空的，则 Promise.race 返回的 Promise 对象将永远处于待定（pending）状态。</p><pre class=" language-typescript"><code class="language-typescript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>运行结果：<br><img src="/img/promise8.png" class="lazyload placeholder" data-srcset="/img/promise8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"></p><p>如果传入的可迭代对象中的任何一个 Promise 对象首先变为已解决（fulfilled）或已拒绝（rejected）状态，则 Promise.race 返回的 Promise 对象也会立即变为相应的状态，并且其值或拒绝原因与首先完成的 Promise 对象相对应。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> p1 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">const</span> p2 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">const</span> p3 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">,</span>p3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p><img src="/img/promise9.png" class="lazyload placeholder" data-srcset="/img/promise9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"></p><h3 id="改变Promise实例状态的方式"><a href="#改变Promise实例状态的方式" class="headerlink" title="改变Promise实例状态的方式"></a>改变Promise实例状态的方式</h3><ul><li>resolve  将状态变成fulfilled</li><li>reject     将状态变成rejected</li><li>throw     将状态变成rejected</li></ul><h3 id="Promise指定多个回调"><a href="#Promise指定多个回调" class="headerlink" title="Promise指定多个回调"></a>Promise指定多个回调</h3><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> p1 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>p1<span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>p1<span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">34</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>运行结果：<br><img src="/img/promise10.png" class="lazyload placeholder" data-srcset="/img/promise10.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"><br>指定多个then也是同理的，都会执行（前提是promise的状态发生了变化，如果一直是pending状态就都不会执行）。</p><h3 id="中断Promise链的方式"><a href="#中断Promise链的方式" class="headerlink" title="中断Promise链的方式"></a>中断Promise链的方式</h3><p><img src="/img/promise11.png" class="lazyload placeholder" data-srcset="/img/promise11.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="中断Promise链的方式"><br>运行结果只会输出1和2，不会输出3，因为我们把它中断了，并且中断promise链的方式有且只有这一种。</p>]]></content>
      
      
      <categories>
          
          <category> Typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue的初始化过程都做了什么</title>
      <link href="/2023/06/27/Vue%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E9%83%BD%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2023/06/27/Vue%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E9%83%BD%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue的初始化过程都做了什么？"><a href="#Vue的初始化过程都做了什么？" class="headerlink" title="Vue的初始化过程都做了什么？"></a>Vue的初始化过程都做了什么？</h2><p>从构造函数前面打断点，然后进行一步步的调试：<br><img src="/img/initvue1.png" class="lazyload placeholder" data-srcset="/img/initvue1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="调试方式"><br>首先会进入init.js里面执行Vue构造函数。init函数之前会进行一下判断：即init之前的代码作用为:检测在使用 Vue 构造函数时是否使用了 new 关键字进行实例化。它主要用于开发环境下的警告提示,之后开始执行init函数正式进入Vue初始化过程。这个options就是用户传入的合并选项在这里，即</p><pre class=" language-typescript"><code class="language-typescript"><span class="token punctuation">{</span>data<span class="token punctuation">:</span><span class="token punctuation">{</span>msg<span class="token punctuation">:</span><span class="token string">'123'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>methods<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'eat'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token function">drink</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'drink'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="/img/initvue2.png" class="lazyload placeholder" data-srcset="/img/initvue2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="init初始化方法"><br>下面让我们进入init方法，给出具体的源代码：rt</p><pre class=" language-typescript"><code class="language-typescript">Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>_init <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>options<span class="token operator">?</span><span class="token punctuation">:</span> Object<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> vm<span class="token punctuation">:</span> Component <span class="token operator">=</span> <span class="token keyword">this</span>    <span class="token comment" spellcheck="true">// a uid</span>    vm<span class="token punctuation">.</span>_uid <span class="token operator">=</span> uid<span class="token operator">++</span>    <span class="token keyword">let</span> startTag<span class="token punctuation">,</span> endTag    <span class="token comment" spellcheck="true">/* istanbul ignore if */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>NODE_ENV <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> config<span class="token punctuation">.</span>performance <span class="token operator">&amp;&amp;</span> mark<span class="token punctuation">)</span> <span class="token punctuation">{</span>      startTag <span class="token operator">=</span> <span class="token template-string"><span class="token string">`vue-perf-start:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>vm<span class="token punctuation">.</span>_uid<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span>      endTag <span class="token operator">=</span> <span class="token template-string"><span class="token string">`vue-perf-end:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>vm<span class="token punctuation">.</span>_uid<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span>      <span class="token function">mark</span><span class="token punctuation">(</span>startTag<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// a flag to avoid this being observed</span>    vm<span class="token punctuation">.</span>_isVue <span class="token operator">=</span> <span class="token keyword">true</span>    <span class="token comment" spellcheck="true">// merge options</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>options <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>_isComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// optimize internal component instantiation</span>      <span class="token comment" spellcheck="true">// since dynamic options merging is pretty slow, and none of the</span>      <span class="token comment" spellcheck="true">// internal component options needs special treatment.</span>      <span class="token function">initInternalComponent</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> options<span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      vm<span class="token punctuation">.</span>$options <span class="token operator">=</span> <span class="token function">mergeOptions</span><span class="token punctuation">(</span>        <span class="token function">resolveConstructorOptions</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token keyword">constructor</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        options <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        vm      <span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* istanbul ignore else */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>NODE_ENV <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">initProxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      vm<span class="token punctuation">.</span>_renderProxy <span class="token operator">=</span> vm    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// expose real self</span>    vm<span class="token punctuation">.</span>_self <span class="token operator">=</span> vm    <span class="token function">initLifecycle</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>    <span class="token function">initEvents</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>    <span class="token function">initRender</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeCreate'</span><span class="token punctuation">)</span>    <span class="token function">initInjections</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// resolve injections before data/props</span>    <span class="token function">initState</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>    <span class="token function">initProvide</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// resolve provide after data/props</span>    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'created'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">/* istanbul ignore if */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>NODE_ENV <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> config<span class="token punctuation">.</span>performance <span class="token operator">&amp;&amp;</span> mark<span class="token punctuation">)</span> <span class="token punctuation">{</span>      vm<span class="token punctuation">.</span>_name <span class="token operator">=</span> <span class="token function">formatComponentName</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token keyword">false</span><span class="token punctuation">)</span>      <span class="token function">mark</span><span class="token punctuation">(</span>endTag<span class="token punctuation">)</span>      <span class="token function">measure</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`vue </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>vm<span class="token punctuation">.</span>_name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> init`</span></span><span class="token punctuation">,</span> startTag<span class="token punctuation">,</span> endTag<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>      vm<span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这个方法是vue实例的初始化方法，它会在创建一个 Vue 实例时被调用。让我们来进一步展开这个方法具体做了什么。</p><ol><li>首先，给当前实例设置 _uid 属性，用于标识唯一的 Vue 实例。</li><li>创建变量startTag 和 endTag 是用于标记解析模板中的标签的起始和结束位置的变量。这是为了创建ast语法树用的，然后设置实例的 _isVue 属性为 true，表示该对象是一个 Vue 实例。</li><li>判断该组件是不是内部组件，如果是内部组件则调用initInternalComponent(vm, options)进行组件合并，否则调用mergeOptions进行组件合并，至于为什么这么做，就是为了提高性能，下面是详细的介绍：</li></ol><blockquote><p>当创建一个组件实例时，会调用 _init 方法进行初始化。在初始化过程中，会检查 options 对象是否存在且具有 _isComponent 属性。如果存在，并且 _isComponent 的值为 true，则表示当前组件是一个内部组件（可以想象成局部注册的组件）。<br>针对内部组件的实例化，由于内部组件的选项合并不需要特殊处理，而且动态选项合并的性能较低，因此可以进行优化。在这种情况下，会调用 initInternalComponent 方法，将内部组件实例和选项对象作为参数传递给该方法。<br>initInternalComponent 方法负责完成内部组件的初始化，包括对选项的处理、状态的初始化等。通过将内部组件的初始化逻辑单独提取为一个方法，可以提高内部组件实例化的性能，并避免对内部组件的选项进行不必要的处理。<br>总而言之，上述代码片段中的逻辑用于优化内部组件的实例化过程，通过调用 initInternalComponent 方法进行内部组件的初始化。这样可以提高内部组件实例化的性能，并简化内部组件选项的处理过程。</p></blockquote><p> 下面是处理内部组件合并的源代码:</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">function</span> initInternalComponent <span class="token punctuation">(</span>vm<span class="token punctuation">:</span> Component<span class="token punctuation">,</span> options<span class="token punctuation">:</span> InternalComponentOptions<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> opts <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token keyword">constructor</span><span class="token punctuation">.</span>options<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// doing this because it's faster than dynamic enumeration.</span>  <span class="token keyword">const</span> parentVnode <span class="token operator">=</span> options<span class="token punctuation">.</span>_parentVnode  opts<span class="token punctuation">.</span>parent <span class="token operator">=</span> options<span class="token punctuation">.</span>parent  opts<span class="token punctuation">.</span>_parentVnode <span class="token operator">=</span> parentVnode  <span class="token keyword">const</span> vnodeComponentOptions <span class="token operator">=</span> parentVnode<span class="token punctuation">.</span>componentOptions  opts<span class="token punctuation">.</span>propsData <span class="token operator">=</span> vnodeComponentOptions<span class="token punctuation">.</span>propsData  opts<span class="token punctuation">.</span>_parentListeners <span class="token operator">=</span> vnodeComponentOptions<span class="token punctuation">.</span>listeners  opts<span class="token punctuation">.</span>_renderChildren <span class="token operator">=</span> vnodeComponentOptions<span class="token punctuation">.</span>children  opts<span class="token punctuation">.</span>_componentTag <span class="token operator">=</span> vnodeComponentOptions<span class="token punctuation">.</span>tag  <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>render<span class="token punctuation">)</span> <span class="token punctuation">{</span>    opts<span class="token punctuation">.</span>render <span class="token operator">=</span> options<span class="token punctuation">.</span>render    opts<span class="token punctuation">.</span>staticRenderFns <span class="token operator">=</span> options<span class="token punctuation">.</span>staticRenderFns  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这个函数的意思：子组件的选项会通过合并方式添加到子组件实例的选项中，以便子组件能够继承和访问父组件的选项。通过这种方式，子组件可以访问父组件的属性、方法、生命周期钩子等。<br>即initInternalComponent 方法主要用于局部注册的组件实例化时的选项合并，mergeOptions 方法用于全局注册和局部注册的组件选项的合并。合并的选项主要为components，directives，methods，computed，props等等，还有子组件的钩子函数等等。合并的结果是父组件的选项优先级高，子组件的选项会被合并到父组件的选项中，形成最终的组件选项对象<br>4. 接下来执行initLifecycle方法，它的作用就是初始化组件实例的生命周期相关属性：例如：<br>初始化 $parent 属性：将父组件实例赋值给 $parent，用于在组件实例中可以访问到其父组件实例。<br>初始化 $root 属性：将根组件实例赋值给 $root，用于在组件实例中可以访问到根组件实例。<br>初始化 $children 属性，初始化 $refs 属性<br>初始化 _watcher 属性<br>初始化 _inactive 属性<br>初始化 _isMounted 属性：将 false 赋值给 _isMounted，表示组件实例当前没有挂载到 DOM 中。<br>初始化 _isDestroyed 属性<br>初始化 _isBeingDestroyed 属性<br>5. initEvents 方法初始化组件实例的事件相关属性和方法。它主要完成以下几个任务：<br>初始化 _events 属性：将空对象赋值给 _events，用于存储组件实例的事件监听器。<br>初始化 _hasHookEvent 属性：将 false 赋值给 _hasHookEvent，表示组件实例当前没有绑定任何钩子函数的事件监听器。<br>将组件构造函数选项中的事件监听器合并到组件实例的 _events 属性中。这样可以在组件实例中通过 $on、$off、$once 等方法进行事件的订阅和取消订阅。<br>将组件实例的父组件的事件监听器合并到组件实例的 _events 属性中。这样可以在组件实例中访问到其父组件的事件监听器。<br>总之，通过执行 initEvents 方法，Vue 组件实例可以进行事件的订阅和触发，从而实现组件间的通信和交互。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">function</span> initEvents <span class="token punctuation">(</span>vm<span class="token punctuation">:</span> Component<span class="token punctuation">)</span> <span class="token punctuation">{</span>  vm<span class="token punctuation">.</span>_events <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>  vm<span class="token punctuation">.</span>_hasHookEvent <span class="token operator">=</span> <span class="token keyword">false</span>  <span class="token comment" spellcheck="true">// init parent attached events</span>  <span class="token keyword">const</span> listeners <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>_parentListeners  <span class="token keyword">if</span> <span class="token punctuation">(</span>listeners<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">updateComponentListeners</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> listeners<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>6.执行initRender 方法，Vue 组件实例具备了渲染功能所需的基本属性和方法（_vnode，$slots等等）。它为组件的模板渲染提供了必要的支持，使组件能够生成对应的虚拟节点，并进行相应的渲染和更新操作。<br>7.调用beforeCreate钩子函数，注意，beforeCreate 钩子函数在组件实例创建之前执行，此时组件的数据、计算属性、方法等还未初始化，但是可以在这个阶段进行一些初始化配置或执行其他操作。还有就是，<strong>选项合并是关于组件选项对象的处理，而初始化是关于组件实例的内部状态的设置和准备。</strong><br>8.initInjections 方法的主要功能是处理组件实例的注入选项（inject）并将其添加到组件实例的 _provided 属性中。它会在组件实例化的过程中被调用，确保组件实例可以直接访问注入的数据。<br>9.执行 initState 方法，它的作用是初始化组件实例的状态，状态包括组件的数据（data）、计算属性（computed）、观察者（watchers）等，下面给出代码，按这个顺序进行的初始化：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> initState <span class="token punctuation">(</span>vm<span class="token punctuation">:</span> Component<span class="token punctuation">)</span> <span class="token punctuation">{</span>  vm<span class="token punctuation">.</span>_watchers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token keyword">const</span> opts <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>props<span class="token punctuation">)</span> <span class="token function">initProps</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>props<span class="token punctuation">)</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>methods<span class="token punctuation">)</span> <span class="token function">initMethods</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>methods<span class="token punctuation">)</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">initData</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token function">observe</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">true</span> <span class="token comment" spellcheck="true">/* asRootData */</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>computed<span class="token punctuation">)</span> <span class="token function">initComputed</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>computed<span class="token punctuation">)</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>watch <span class="token operator">&amp;&amp;</span> opts<span class="token punctuation">.</span>watch <span class="token operator">!==</span> nativeWatch<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">initWatch</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>watch<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>10.initProvide方法，用于初始化组件的Provide选项，其允许一个组件向其所有的子组件提供数据或者方法，这样子组件就可以通过inject来访问这些数据和方法。<br>11..调用created钩子函数.组件实例刚好被创建然后立即调用该方法，表明此时组件的数据观测 和事件机制都已经初始化完成。<br>12.模板渲染：在 created 钩子函数之后，Vue.js 将根据组件的虚拟 DOM 结构开始渲染组件的模板。这个过程涉及以下步骤：<br>将组件的虚拟 DOM 与实际的 DOM 进行比对，找出需要更新的部分。<br>将需要更新的部分进行 DOM 操作，实现视图的更新。<br>13.调用beforeMount钩子函数<br>14.模板挂载：在 beforeMount 钩子函数之后，Vue.js 开始将组件的虚拟 DOM 渲染到实际的 DOM 中。这个过程包括以下步骤：<br>将组件的虚拟 DOM 插入到实际 DOM 中的指定位置。<br>执行实际的 DOM 操作，如添加、修改或删除 DOM 元素。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TS判断一个值是否为数组类型</title>
      <link href="/2023/06/26/TS%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%80%BC%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/06/26/TS%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%80%BC%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="TS判断一个值是否为数组类型"><a href="#TS判断一个值是否为数组类型" class="headerlink" title="TS判断一个值是否为数组类型"></a>TS判断一个值是否为数组类型</h2><h3 id="instanceof-用于检查对象是否属于特定类或构造函数的实例，返回的是一个布尔值。"><a href="#instanceof-用于检查对象是否属于特定类或构造函数的实例，返回的是一个布尔值。" class="headerlink" title="instanceof 用于检查对象是否属于特定类或构造函数的实例，返回的是一个布尔值。"></a>instanceof 用于检查对象是否属于特定类或构造函数的实例，返回的是一个布尔值。</h3><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> arr<span class="token punctuation">:</span> <span class="token keyword">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> isArray <span class="token operator">=</span> arr <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'使用instanceof判断'</span><span class="token punctuation">,</span>isArray<span class="token punctuation">)</span></code></pre><p><img src="/img/arr_judge.png" class="lazyload placeholder" data-srcset="/img/arr_judge.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"></p><h3 id="Array-isArray-用于检查一个值是否为数组类型，返回的是一个布尔类型"><a href="#Array-isArray-用于检查一个值是否为数组类型，返回的是一个布尔类型" class="headerlink" title="Array.isArray 用于检查一个值是否为数组类型，返回的是一个布尔类型"></a>Array.isArray 用于检查一个值是否为数组类型，返回的是一个布尔类型</h3><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> isArray<span class="token punctuation">:</span> <span class="token keyword">boolean</span> <span class="token operator">=</span> <span class="token keyword">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//true</span></code></pre><h3 id="Array-prototype-isPrototypeof"><a href="#Array-prototype-isPrototypeof" class="headerlink" title="Array.prototype.isPrototypeof"></a>Array.prototype.isPrototypeof</h3><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> obj<span class="token punctuation">:</span>object <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">const</span> arr<span class="token punctuation">:</span> <span class="token keyword">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> isPrototype<span class="token punctuation">:</span> <span class="token keyword">boolean</span> <span class="token operator">=</span> <span class="token keyword">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//false</span><span class="token keyword">const</span> isPrototype<span class="token punctuation">:</span> <span class="token keyword">boolean</span> <span class="token operator">=</span> <span class="token keyword">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//true</span></code></pre><p>备注:Array.prototype.isPrototypeOf 方法主要用于检查对象是否继承了数组的原型，而不是判断对象是否为数组类型，其返回一个布尔值，如果 obj 是数组的实例或继承自数组的原型，则返回 true，否则返回 false。<br>看下面一个例子：</p><pre class=" language-typescript"><code class="language-typescript">  <span class="token keyword">interface</span> <span class="token class-name">MyObject</span> <span class="token keyword">extends</span> <span class="token class-name">Array</span><span class="token operator">&lt;</span><span class="token keyword">any</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">const</span> myObj<span class="token punctuation">:</span> MyObject <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>  myObj<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在上述示例中，我们通过定义一个 MyObject 接口来表示 myObj 对象，它扩展了 Array<any> 类型，这样我们就可以在 myObj 对象上使用数组的属性和方法。使用类型断言 const myObj: MyObject = Object.create(Array.prototype); 将 myObj 声明为 MyObject 类型，表示它是继承自数组原型的对象。<br>打印数组如下：</any></p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">Array</span> <span class="token punctuation">{</span> <span class="token string">'0'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> length<span class="token punctuation">:</span> <span class="token number">3</span> <span class="token punctuation">}</span></code></pre><pre class=" language-typescript"><code class="language-typescript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>myObj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>myObj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myObj <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span></code></pre><p>至于为什么，那就需要了解一下isArray的实现原理：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">Array</span><span class="token punctuation">.</span>isArray <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'[object Array]'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>我再解释一下：当我们使用 Object.create(Array.prototype) 创建对象 myObj 时，myObj 成为了一个继承了数组原型的新对象。它继承了数组原型上的方法和属性，包括 push、pop、length 等。<br>然而，Array.isArray 方法的实现原理是基于 JavaScript 的内部特性，它不仅仅依赖于对象是否继承了数组原型，还会检查对象是否具有内部的特殊属性 [[Class]]。只有当对象的 [[Class]] 属性为 “Array” 时，Array.isArray 才会返回 true。<br>对于真正的数组对象，它们的 [[Class]] 属性会被设置为 “Array”，这是 JavaScript 引擎的内部行为。这样，Array.isArray 就可以准确地判断一个值是否为数组。<br>然而，通过 Object.create(Array.prototype) 创建的对象 myObj 并不具有 “Array” 的 [[Class]] 属性。它的 [[Class]] 属性为 “Object”，因为它本质上仍然是一个对象。<br>因此，尽管 myObj 继承了数组原型上的方法，可以调用 push 方法并具有类似数组的行为，但它不满足 Array.isArray 对于数组类型的判断条件，因为它的 [[Class]] 属性不是 “Array”。所以 Array.isArray(myObj) 返回 false。<br>这个行为巧妙地区分了真正的数组和仅仅继承了数组原型的对象。它让我们能够更准确地判断一个值是否为数组类型,。</p><h3 id="Object-getPrototypeOf-方法用于获取指定对象的原型（即该对象继承的原型对象）"><a href="#Object-getPrototypeOf-方法用于获取指定对象的原型（即该对象继承的原型对象）" class="headerlink" title="Object.getPrototypeOf 方法用于获取指定对象的原型（即该对象继承的原型对象）"></a>Object.getPrototypeOf 方法用于获取指定对象的原型（即该对象继承的原型对象）</h3><pre class=" language-typescript"><code class="language-typescript">Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token keyword">Array</span><span class="token punctuation">.</span>prototype <span class="token comment" spellcheck="true">//true</span></code></pre><p>Object.getPrototypeOf 方法会返回指定对象的原型对象。它是通过访问对象的 [[Prototype]] 属性来获取原型。[[Prototype]] 属性存储了对象的原型引用。</p><h3 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h3><pre class=" language-typescript"><code class="language-typescript">Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//[object Array]</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//[object Object]</span></code></pre><p>综上，isArray和Object.prototype.toString判断的是最准确的。</p><hr><h3 id="番外：typeof相关内容"><a href="#番外：typeof相关内容" class="headerlink" title="番外：typeof相关内容"></a>番外：typeof相关内容</h3><p>typeof 运算符可以判断以下类型：<br>“undefined”：未定义的变量或未赋值的变量。<br>“boolean”：布尔值。<br>“number”：数值。<br>“string”：字符串。<br>“symbol”：符号类型（ES6 引入）。<br>“function”：函数。<br>“object”：对象（包括数组、对象字面量、null、以及特殊的内置对象如 Date、RegExp 等）。<br>但是，typeof 运算符存在一些限制和特殊情况。例如，对于 null 类型和数组类型，typeof 运算符会返回 “object”，无法细分具体的类型，也就是说用来判断基本数据类型还可以，判断引用类型不太好使。</p><p>Object.prototype.toString.call() 方法可以判断几乎所有的数据类型，包括基本类型和复杂类型。它会返回一个类似于 “[object Type]” 的字符串，其中 “Type” 表示具体的数据类型，例如 “[object Array]”、”[object Object]”、”[object Date]” 等，但是，使用 typeof 和 Object.prototype.toString.call() 时，对于自定义的对象类型，都会返回 “[object Object]”，无法准确判断具体的自定义类型。这时可以通过其他方式，如 instanceof 运算符或构造函数来进行更精确的判断。<br>下面是Object.prototype.toString失灵的例子：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span>  <span class="token keyword">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 创建一个person实例</span><span class="token keyword">const</span> person<span class="token punctuation">:</span> Person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"John"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用 typeof 和 Object.prototype.toString.call()</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "object"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "[object Object]"</span></code></pre><p>完结！！</p>]]></content>
      
      
      <categories>
          
          <category> Typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法:二叉树的构建(TS实现)</title>
      <link href="/2023/06/25/%E7%AE%97%E6%B3%95_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA(TS%E5%AE%9E%E7%8E%B0)/"/>
      <url>/2023/06/25/%E7%AE%97%E6%B3%95_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA(TS%E5%AE%9E%E7%8E%B0)/</url>
      
        <content type="html"><![CDATA[<h2 id="算法-二叉树的构建-TS实现"><a href="#算法-二叉树的构建-TS实现" class="headerlink" title="算法:二叉树的构建(TS实现)"></a>算法:二叉树的构建(TS实现)</h2><blockquote><p>需求:传入一个数组，将其构建成为一颗二叉树</p></blockquote><blockquote><p>算法思想:</p><ol><li>用户传入一个空数组，或者传入其他非数组值，直接返回null，代表一颗空树</li><li>用户传入一个数组（数组长度大于等于1）：将下标为0的节点作为根节点，其左孩子下标值为2n+1，右孩子下标值为2n+2，根节点下标为0，当左孩子还有孩子时，就将用户传入的数组和当前索引传入handleToNode，进行递归调用，直至递归到最后一层；如果当前孩子有右孩子也是同理；若当前节点没有左孩子或者右孩子，则直接返回null，这也是递归结束的条件。</li></ol></blockquote><p>代码结构如下：<br>首先看一下二叉树中每个节点的结构：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token operator">&lt;</span>TreeType<span class="token operator">></span><span class="token punctuation">{</span>  value<span class="token punctuation">:</span>TreeType <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//节点的值</span>  leftChild<span class="token punctuation">:</span>TreeNode<span class="token operator">&lt;</span>TreeType<span class="token operator">></span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//左孩子</span>  rightChild<span class="token punctuation">:</span>TreeNode<span class="token operator">&lt;</span>TreeType<span class="token operator">></span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//右孩子</span>  <span class="token keyword">constructor</span><span class="token punctuation">(</span>value<span class="token punctuation">:</span>TreeType <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//初始化节点值</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>leftChild <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//初始化左孩子</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>rightChild <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 初始化右孩子</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>数据结构如上图所示—–value用于存储节点的值，leftChild指向当前节点的左孩子，rightChild指向当前节点的右孩子，初始时，节点的左右孩子指针分别指为空。</p><p>节点的结构定义好了之后，开始写二叉树的构建算法：<br>这里我分成了两个方法：分别为buildBinaryTree、handleNode<br>其中buildBinaryTree做了两件事情：一是用来判断当前传入的数组是否合法，二是构建二叉树。做了一层最基本的条件判断与处理，即如果传入的参数有值就进行递归处理成二叉树，若无值则直接return null 返回空树。<br>handleNode是用来实现构建二叉树的细节，以及深层次的递归处理，需要两个参数分别为：要转化的数组和当前处理的节点索引。<br>下面是buildBinaryTree方法的具体实现：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> buildBinaryTree<span class="token operator">&lt;</span>TreeType<span class="token operator">></span><span class="token punctuation">(</span>initTree<span class="token punctuation">:</span><span class="token punctuation">(</span>TreeType<span class="token operator">|</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>TreeNode<span class="token operator">&lt;</span>TreeType<span class="token operator">></span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 当前节点的索引值为n 左孩子的索引值为2n+1 右孩子的索引值为2n+2  且索引从0开始  即根节点的索引值下标是0</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>initTree<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//说明是一颗空树</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> handleNode<span class="token operator">&lt;</span>TreeType<span class="token operator">></span><span class="token punctuation">(</span>initTree<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>下面是handleNode方法的具体实现：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> handleNode<span class="token operator">&lt;</span>TreeType<span class="token operator">></span><span class="token punctuation">(</span>initTree<span class="token punctuation">:</span> <span class="token keyword">Array</span><span class="token operator">&lt;</span>TreeType <span class="token operator">|</span> <span class="token keyword">null</span><span class="token operator">></span><span class="token punctuation">,</span>index<span class="token punctuation">:</span><span class="token keyword">number</span><span class="token punctuation">)</span><span class="token punctuation">:</span>TreeNode<span class="token operator">&lt;</span>TreeType<span class="token operator">></span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">>=</span>initTree<span class="token punctuation">.</span>length<span class="token operator">||</span>initTree<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span>  <span class="token keyword">const</span> currentNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token operator">&lt;</span>TreeType<span class="token operator">></span><span class="token punctuation">(</span>initTree<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>  currentNode<span class="token punctuation">.</span>leftChild <span class="token operator">=</span> <span class="token function">handleNode</span><span class="token punctuation">(</span>initTree<span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">*</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>  currentNode<span class="token punctuation">.</span>rightChild <span class="token operator">=</span> <span class="token function">handleNode</span><span class="token punctuation">(</span>initTree<span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">*</span>index<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> currentNode<span class="token punctuation">}</span></code></pre><p>假如我们传递的参数为：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> preBinaryTree <span class="token punctuation">:</span><span class="token keyword">Array</span><span class="token operator">&lt;</span>Number<span class="token operator">|</span><span class="token keyword">null</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token function">buildBinaryTree</span><span class="token punctuation">(</span>preBinaryTree<span class="token punctuation">)</span></code></pre><p>下面真机运行一下：<br><img src="/img/treebuild1.png" class="lazyload placeholder" data-srcset="/img/treebuild1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="二叉树构建"><br>实际生成的物理结构应该是这样的：<br><img src="/img/treebuild2.png" class="lazyload placeholder" data-srcset="/img/treebuild2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="物理结构图"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>块级格式化上下文BFC（Block Formatting Context）</title>
      <link href="/2023/06/23/%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87BFC%EF%BC%88Block%20Formatting%20Context%EF%BC%89/"/>
      <url>/2023/06/23/%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87BFC%EF%BC%88Block%20Formatting%20Context%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>在介绍BFC之前，先了解一下文档流相关的内容。<br>我们常说的文档流包括定位流、浮动流、普通流三种。</p><h4 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h4><p>如果元素的属性position为absolute或fixed，那这个元素就是一个绝对定位的元素，它会脱离普通流，它的位置由绝对定位的坐标和层级决定，对于position:absolute的元素来说，它将相对于离自己最近的上级元素且设有relative、fixed、absolute的元素进行定位，如果没有则相对于body元素进行定位。<br>对于设置fixed的元素来说，相对于浏览器的窗口进行定位，但是如果该元素的祖先有设置transfrom非none时，会相对于该祖先元素进行定位。</p><h4 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h4><p>在浮动布局中，元素按照普通流的位置出现，然后根据浮动的方向尽可能的偏移，这里有个坑🕳：请看代码</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">padding</span><span class="token punctuation">:</span><span class="token number">0</span> <span class="token number">10</span>px<span class="token punctuation">;</span><span class="token property">background-color</span><span class="token punctuation">:</span> yellowgreen<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>span1(没有设置浮动)<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">float</span><span class="token punctuation">:</span>left<span class="token punctuation">;</span><span class="token property">padding</span><span class="token punctuation">:</span><span class="token number">0</span> <span class="token number">10</span>px<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">40</span>px<span class="token punctuation">;</span><span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>span2(设置左浮动)<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span></code></pre><p>这是运行的效果，会发现第二个设置浮动的span元素跑到了第一个span前面，原因是这样的：float这一属性，float:left会使元素变成一个inline-block元素（使得第一个span元素可以设置宽高）。实际上他是和上一行内元素span显示在同一行。<br>一个浮动的盒子会向右或向左移动直至触碰到包含<strong>块</strong>的边界或另一个浮动盒子的边界。<br>span既不是其包含块也不是另一个浮动的盒子，故div会移动至包含块的边界，所以div会显示在span之前。<br><img src="/img/bfc1.png" class="lazyload placeholder" data-srcset="/img/bfc1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行效果"></p><h4 id="普通流"><a href="#普通流" class="headerlink" title="普通流"></a>普通流</h4><p>普通流其实就是BFC的FC（Formatting Context）格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局以及和其他元素之间的关系和作用。</p><p>在普通流中，元素按照在文档中的先后位置从上至下布局，即行内元素水平排列，块级元素独占一行。</p><h3 id="BFC相关内容"><a href="#BFC相关内容" class="headerlink" title="BFC相关内容"></a>BFC相关内容</h3><h4 id="关于BFC的定义："><a href="#关于BFC的定义：" class="headerlink" title="关于BFC的定义："></a>关于BFC的定义：</h4><blockquote><p>块级格式化上下文（BFC）是WEB页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p></blockquote><p>具有BFC特性的元素可以看作是隔离了的独立容器（想象成一个独立的箱子），容器内的元素不会在布局上影响到外面的元素（你里箱子里面的物品如何怎么摆放都不会影响到外面），并且BFC具有普通容器所没有的一些特性，且同一个元素不可能同时存在于两个BFC中。</p><h4 id="BFC的触发方式"><a href="#BFC的触发方式" class="headerlink" title="BFC的触发方式"></a>BFC的触发方式</h4><p>满足下方任何一个条件即可触发BFC特性</p><ol><li>根元素本身就是个BFC</li><li>浮动元素 float为left或right</li><li>overflow不为visible，即为auto、scroll、hidden</li><li>绝对定位：position:absolute、fixed</li><li>display的值为inline-block flex grid inline-flex inline-grid block等<h4 id="BFC的特性"><a href="#BFC的特性" class="headerlink" title="BFC的特性"></a>BFC的特性</h4></li><li>BFC是页面上的一个独立容器，容器里面的子元素不会影响外面的元素。</li><li>同一个BFC里面的两个相邻的块级元素可能会发生外边距折叠，创建新的BFC可以解决此种情况。</li><li>浮动盒的区域不会和BFC重叠</li><li>计算BFC的高度时，浮动元素也会参与计算</li></ol><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>1、自适应两列布局</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>left<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>right<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><pre class=" language-css"><code class="language-css"><span class="token selector">&lt;style>        <span class="token class">.left</span></span><span class="token punctuation">{</span>            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>            <span class="token property">margin-right</span><span class="token punctuation">:</span> <span class="token number">10</span>px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> blueviolet<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token selector"><span class="token class">.right</span></span><span class="token punctuation">{</span>            <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    &lt;/style></code></pre><p>看一下运行的效果：<br><img src="/img/bfc2.png" class="lazyload placeholder" data-srcset="/img/bfc2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="BFC应用-自适应"><br>这利用了BFC 的「包含浮动元素的影响」（浮动盒的区域不会和BFC重叠）这个特性，右侧的元素开启BFC，不给定宽度，左侧的元素定宽或者不定宽都可以，</p><ul><li>将左列设为左浮动，使得其他块级元素可以和它占据同一行</li><li>右侧为块级元素，利用其自身的流特性占满整行</li><li>右列设置overflow：hidden，触发BFC特性，使其自身与左侧浮动盒隔离开，不占满整行<br>2、解决margin重叠问题<br><img src="/img/bfc3.png" class="lazyload placeholder" data-srcset="/img/bfc3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="margin重叠问题"></li></ul><pre class=" language-css"><code class="language-css">    &lt;div>        &lt;div class=<span class="token string">"div1"</span>>div<span class="token number">1</span>&lt;/div>        &lt;div class=<span class="token string">"div2"</span>>div<span class="token number">2</span>&lt;/div>    &lt;/div></code></pre><p>我给div1设置下边距10px，div2设置上边距是20px,按代码里面两个div盒子应该上下相距30px才对，但是发生了重叠，会取两个margin’中最大的一个值，并不会相加，至于解决方法，如果用BFC解决的话，可以将两个盒子分别放到不同的BFC中，下面是改进的代码：<br>其中wrap设置overflow:hidden开启BFC</p><pre class=" language-html"><code class="language-html">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>div1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>div1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>div2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>div2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p>这利用到了上面BFC特性的第二条—-同一个BFC里面的两个相邻的块级元素可能会发生外边距折叠，那就再开启一个BFC就好了。</p><p>3、父子元素的外边距重叠的问题<br>这种情况存在于父元素与其第一个或最后一个子元素之间。<br><img src="/img/bfc4.png" class="lazyload placeholder" data-srcset="/img/bfc4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="父子元素的外边距重叠的问题"><br>看下代码：</p><pre class=" language-css"><code class="language-css">       <span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/* 有没有都一个样 */</span>            <span class="token property">margin-top</span><span class="token punctuation">:</span> <span class="token number">10</span>px<span class="token punctuation">;</span>             <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token selector"><span class="token class">.son</span></span><span class="token punctuation">{</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">margin-top</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><p>解决办法很多，比如给parent触发BFC；给父元素添加border或者将父元素的margin替换成padding</p><p>4、还有就是可以清楚浮动，当父元素的子元素设置浮动之后，并且父元素此时还没有设定高度，那此时父元素的高度就只有边框，padding或者margin的高度了，解决办法就是给父元素启用BFC，使得其具有BFC的特性，这利用了BFC特性的第四条—–内部的浮动元素也参与计算。</p>]]></content>
      
      
      <categories>
          
          <category> HTML&amp;CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML&amp;CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript执行上下文与闭包</title>
      <link href="/2023/06/22/Javascript%E9%97%AD%E5%8C%85%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
      <url>/2023/06/22/Javascript%E9%97%AD%E5%8C%85%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h2 id="Javascript执行上下文与闭包"><a href="#Javascript执行上下文与闭包" class="headerlink" title="Javascript执行上下文与闭包"></a>Javascript执行上下文与闭包</h2><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>说闭包之前先解释一下JavaScript的执行上下文，即作用域。</p><ol><li>全局作用域:默认环境，当我们第一次启动程序时，默认创建的全局作用域。</li><li>函数作用域:当执行流进入函数体时就会创建一个本地函数执行上下文，并压入栈中。</li><li>块级作用域:这是es6中新出的作用域，比如for循环、while循环、{}等都属于是块级作用域。</li></ol><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p> 知道了作用域之后，我们来看一下闭包的定义、作用以及使用场景：</p><blockquote><p><strong>闭包定义</strong>：指的是那些引用了另一个函数作用域中变量的<strong>函数</strong>，通常是在嵌套函数中实现的。———-JS红宝书上面的解释</p></blockquote><blockquote><p><strong>个人理解</strong>：该作用域存在对上级作用域当中变量的引用即形成闭包。上级作用域内的变量，因为被下级作用域内引用，而没有被释放。就导致上级作用域内的变量，等到下级作用域执行完以后才正常得到释放（也就是说当解除了对该闭包的所有引用的时候，这个闭包才会被JS的垃圾回收机制回收）。</p></blockquote><p>下面我先给出一个看似闭包但不是闭包的例子，以助后面更好的认识以及理解闭包：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span><span class="token keyword">void</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> outerVariable<span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">innerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>      <span class="token keyword">let</span> innerVariable<span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>outerVariable <span class="token operator">+</span> innerVariable<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">innerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p> 在这个例子中，我们定义了一个外部函数 outerFunction，其中包含一个内部函数 innerFunction。在 outerFunction 中，我们直接调用了 innerFunction，而不是将其作为返回值或赋值给变量。<br>尽管 innerFunction 访问了 outerFunction 中的变量 outerVariable，但由于 innerFunction 在 outerFunction 内部被直接调用，而不是在外部作用域外被调用，它不满足闭包的条件。<br>在这个例子中，innerFunction 没有形成闭包，因为它没有在外部函数作用域外被调用，也没有捕获外部函数作用域的引用。<br>看一下运行效果：<br><img src="/img/context1.png" class="lazyload placeholder" data-srcset="/img/context1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果(伪闭包)"></p><p>可以看到，并没有实现闭包的效果，原因就是三次调用outerFunction函数，之间没有任何关系，每次执行完之后都会将该函数内部的变量回收。<br>下面我们改造一下这个函数，让其变成闭包：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token number">1</span> <span class="token keyword">function</span> <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span><span class="token keyword">Function</span> <span class="token punctuation">{</span><span class="token number">2</span>    <span class="token keyword">let</span> outerVariable <span class="token punctuation">:</span><span class="token keyword">number</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token number">3</span>    <span class="token keyword">function</span> <span class="token function">innerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span><span class="token keyword">number</span><span class="token punctuation">{</span><span class="token number">4</span>      <span class="token keyword">let</span> innerVariable <span class="token punctuation">:</span><span class="token keyword">number</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token number">5</span>       outerVariable <span class="token operator">++</span><span class="token number">6</span>      <span class="token keyword">return</span> <span class="token punctuation">(</span>outerVariable <span class="token operator">+</span> innerVariable<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">7</span>    <span class="token punctuation">}</span><span class="token number">8</span>    <span class="token keyword">return</span> innerFunction<span class="token punctuation">;</span><span class="token number">9</span> <span class="token punctuation">}</span><span class="token number">10</span> <span class="token keyword">const</span> closure <span class="token punctuation">:</span><span class="token keyword">Function</span> <span class="token operator">=</span> <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">11</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">closure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">12</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">closure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">13</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">closure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>先看一下执行的结果：<br><img src="/img/context2.png" class="lazyload placeholder" data-srcset="/img/context2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="修改为闭包之后的执行结果"></p><p>修改之处在于，我们将 innerFunction 返回并赋值给 closure 变量，并在外部调用 closure()。<br>现在，closure 变量中保存的是 innerFunction，它实际上是一个闭包。在调用 closure() 时，innerFunction 可以访问其定义时所在的外部函数 outerFunction 的作用域，即可以访问 outerVariable。这样，我们就创建了一个闭包，使得 innerFunction 在外部函数作用域外仍然能够访问和操作其引用的变量。<br>通过这种方式，我们确保了 innerFunction 在外部函数作用域外被调用时仍然可以访问外部变量，满足了闭包的条件。</p><h3 id="剖析执行过程"><a href="#剖析执行过程" class="headerlink" title="剖析执行过程"></a>剖析执行过程</h3><ul><li>第 1-9行。我们在全局执行上下文中创建了一个新的变量outerFunction，并赋值了一个的函数定义。</li><li>第10行。我们在全局执行上下文中声明了一个名为closure的新变量。</li><li>第11行。我们需要调用outerVariable 函数并将其返回值赋给closure变量。</li><li>第 1-9行。调用函数，创建新的本地执行上下文。</li><li>第2行。在本地执行上下文中，声明一个名为outerVariable 的新变量并赋值为 1;</li><li>第 3-7行。声明一个名为myFunction的新变量，变量在本地执行上下文中声明,变量的内容是为第4-6行所定义。</li><li>第8行。返回innerFunction变量的内容，删除本地执行上下文。变量innerFunction和outerVariable 不再存在。</li><li>第10行。在调用上下文(全局执行上下文)中，outerFunction返回的值赋给了closure，变量closure现在包含一个函数定义内容为outerFunction返回的函数。它不再标记为innerFunction，但它的定义是相同的。这个closure就相当于是闭包的引用，如果该变量一直引用着，则这个闭包会一直存在于内存当中，不会被垃圾回收机制标记为垃圾。</li><li>第11行。查找closure变量，它是一个函数并调用它。它包含前面返回的函数定义，除此之外它还有一个带有变量的闭包</li><li>创建一个新的执行上下文。没有参数，开始执行函数。</li><li>第四行，声明了一个innerVariable变量并赋值20</li><li>第五行，寻找变量outerVariable，在查找当前作用域和上级作用域之前，会先检查一下闭包当中有没有，找到了，然后执行+1操作，然后将其再次存储到闭包当中，待下次使用。</li><li>第六行，返回outerVariable + innerVariable的值，然后销毁当前上下文。</li><li>回到第11行，打印出22.</li><li>接下来就是第12行和第13行就是重复步骤执行第11行代码的执行步骤，实现递增的效果。分别打印出23，24.</li></ul><blockquote><p><strong>闭包的作用</strong>：保护函数的私有变量不受外界干扰；将上级作用域的引用保存下来，实现方法或者属性的私有化；实现模块化</p></blockquote><blockquote><p><strong>闭包的缺点</strong>：使用不当，会造成内存泄漏。</p></blockquote><p>下面是一个使用闭包不当造成内存泄漏的例子：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> outerVariable <span class="token operator">=</span> <span class="token string">'1'</span><span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">innerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> innerVariable <span class="token operator">=</span> <span class="token string">'1'</span><span class="token punctuation">;</span>    <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    outerVariable<span class="token operator">++</span>    innerVariable<span class="token operator">++</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>outerVariable <span class="token operator">+</span> innerVariable<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">innerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在这个例子中，我们定义了一个外部函数 outerFunction，其中包含一个内部函数 innerFunction。在 innerFunction 中，我们使用 setInterval 创建了一个定时器，每秒钟输出 outerVariable 和 innerVariable 的值。<br>由于定时器的回调函数形成了闭包，它可以访问 outerVariable 和 innerVariable，即使 innerFunction 已经执行完毕。这导致闭包中引用的变量无法被垃圾回收，因为定时器仍然持有对闭包的引用。<br>如果我们多次调用 outerFunction，每次调用都会创建一个新的定时器，并且每个定时器都会保留对其自己的闭包的引用。这会导致内存泄漏，因为闭包中引用的变量无法被释放。<br>为了避免内存泄漏，要记得清除定时器。<br><img src="/img/context3.png" class="lazyload placeholder" data-srcset="/img/context3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="执行结果"></p><blockquote><p><strong>闭包的使用场景</strong>：节抖或防流；自执行函数以及回调函数等</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构八大排序之快速排序算法</title>
      <link href="/2023/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2023/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构八大排序之快速排序算法"><a href="#数据结构八大排序之快速排序算法" class="headerlink" title="数据结构八大排序之快速排序算法"></a>数据结构八大排序之快速排序算法</h2><blockquote><p>算法思想如下:<br>1、选择基准元素：从待排序的数组中选择一个元素作为基准（pivot）。可以选择数组的第一个元素、最后一个元素或者随机位置的元素作为基准。<br>2、划分操作：将数组中的其他元素按照与基准的大小关系进行划分，将比基准小的元素放在基准的左侧，比基准大的元素放在基准的右侧。同时，基准元素所在的位置也确定了。<br>3、递归排序：对基准元素左侧和右侧的子数组分别进行递归调用快速排序算法，重复上述步骤，直到子数组的长度为1或0（即已经有序）。<br>4、合并结果：递归调用的过程中，子数组的排序会不断地将基准元素放置在正确的位置上，最终整个数组就变为有序。</p></blockquote><h3 id="该算法在前端中的应用"><a href="#该算法在前端中的应用" class="headerlink" title="该算法在前端中的应用"></a>该算法在前端中的应用</h3><p>目前我知道的：js的数组操作方法sort这个api的实现原理就是快速排序算法。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 快速排序算法 </span><span class="token keyword">function</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span><span class="token keyword">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>type<span class="token punctuation">:</span>SortType<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 当数组中只有一项则直接返回 且也是结束递归的出口</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> arr    <span class="token comment" spellcheck="true">// 基准元素的索引</span>    <span class="token keyword">const</span> pivotIndex <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 基准元素的值</span>    <span class="token keyword">const</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>pivotIndex<span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// 将小于基准元素的值放入该数组中</span>    <span class="token keyword">const</span> less<span class="token punctuation">:</span><span class="token keyword">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// 将等于基准元素的值放入该数组中</span>    <span class="token keyword">const</span> equal<span class="token punctuation">:</span><span class="token keyword">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// 将大于基准元素的值放入该数组中</span>    <span class="token keyword">const</span> greater<span class="token punctuation">:</span><span class="token keyword">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// 遍历数组进行切分 </span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> element of arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span>element <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span><span class="token operator">?</span> less<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">:</span>undefined<span class="token punctuation">;</span>        <span class="token punctuation">(</span>element <span class="token operator">></span> pivot<span class="token punctuation">)</span><span class="token operator">?</span> greater<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">:</span>undefined<span class="token punctuation">;</span>        <span class="token punctuation">(</span>element <span class="token operator">==</span> pivot<span class="token punctuation">)</span><span class="token operator">?</span> equal<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">:</span>undefined    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 升序排列 递归</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>type<span class="token operator">==</span>SortType<span class="token punctuation">.</span>Asc<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token function">quickSort</span><span class="token punctuation">(</span>less<span class="token punctuation">,</span>SortType<span class="token punctuation">.</span>Asc<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">...</span>equal<span class="token punctuation">,</span><span class="token operator">...</span><span class="token function">quickSort</span><span class="token punctuation">(</span>greater<span class="token punctuation">,</span>SortType<span class="token punctuation">.</span>Asc<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// 降序排列</span>    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token function">quickSort</span><span class="token punctuation">(</span>greater<span class="token punctuation">,</span>SortType<span class="token punctuation">.</span>Desc<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">...</span>equal<span class="token punctuation">,</span><span class="token operator">...</span><span class="token function">quickSort</span><span class="token punctuation">(</span>less<span class="token punctuation">,</span>SortType<span class="token punctuation">.</span>Desc<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h3 id="算法的使用"><a href="#算法的使用" class="headerlink" title="算法的使用"></a>算法的使用</h3><p>以下面这个数组为例子，算法接收两个参数，第一个参数是待排序的数组，第二个参数指定待排序的规则（升序还是降序).</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> sortArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span></code></pre><p>实现数组升序排列：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> newArr <span class="token operator">=</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>sortArr<span class="token punctuation">,</span>SortType<span class="token punctuation">.</span>Asc<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'使用快速排序实现数组的升序排列'</span><span class="token punctuation">,</span>newArr<span class="token punctuation">)</span></code></pre><p><img src="/img/quick1.png" class="lazyload placeholder" data-srcset="/img/quick1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"></p><p>实现数组降序排列：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> newArr <span class="token operator">=</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>sortArr<span class="token punctuation">,</span>SortType<span class="token punctuation">.</span>Desc<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'使用快速排序实现数组的降序排列'</span><span class="token punctuation">,</span>newArr<span class="token punctuation">)</span></code></pre><p><img src="/img/quick2.png" class="lazyload placeholder" data-srcset="/img/quick2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"></p><h3 id="执行过程详解"><a href="#执行过程详解" class="headerlink" title="执行过程详解"></a>执行过程详解</h3><p>1、选择基准元素：在这个例子中，我们选择数组的第一个元素作为基准，即 5。</p><p>2、划分操作：将数组中的其他元素按照与基准的大小关系进行划分。比基准小的元素放在基准的左侧，比基准大的元素放在基准的右侧。</p><ul><li>第一次划分：将数组划分为 [3, 2, 1]、[5]、[6, 9] 三部分。</li><li>第二次划分：对左侧的子数组 [3, 2, 1] 进行划分，得到 [2, 1]、[3]。</li><li>第三次划分：对右侧的子数组 [6, 9] 进行划分，得到 [6]、[9]。<br>最终的划分结果为 [2, 1, 3, 5, 6, 9]。</li></ul><p>3、递归排序：对基准元素左侧和右侧的子数组分别进行递归调用快速排序算法。<br>对左侧子数组 [2, 1, 3] 进行快速排序。</p><ul><li>选择基准元素 2。<br>划分结果为 [1]、[2]、[3]。<br>对右侧子数组 [6, 9] 进行快速排序。</li><li>选择基准元素 6。<br>划分结果为 [6]、[9]。<br>4、合并结果：递归调用的过程中，子数组的排序会不断地将基准元素放置在正确的位置上，最终整个数组就变为有序。</li></ul><p>最终排序结果为 [1, 2, 3, 5, 6, 9]。<br>选择基准元素，这个元素尽量能将数组划分成两个相同长度的表，长度越接近越好，因为这样可以减少递归的深度，节省性能，</p><p>假如你选择的基准元素不好，我们来调试一下，看一下效果：<br><img src="/img/quick3.png" class="lazyload placeholder" data-srcset="/img/quick3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="调试基准元素"><br>上面的情况是对于数组几乎有序或者已经有序，并且每次基准元素选择数组的第一项的时候，这时候性能开销最大，==其时间复杂度为O(n²)==，当然如果数据量小，那确实无所谓，几乎看不出什么。<br>下面是选择基准元素适中的情况，我们再来看一下运行过程中的状态:<br><img src="/img/quick4.png" class="lazyload placeholder" data-srcset="/img/quick4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="调试基准元素"><br>两图对比一下，第二张图，基准元素选择适中，递归深度减少一半，性能开销小，两个子表几乎相同，==其时间复杂度为O(nlogn)==，这就等同于一颗二叉树，左孩子与右孩子高度相同，它相比于第一张图的单只树(只有右孩子没有左孩子)，那肯定是单只树的性能开销比较大。当数据量过大的时候，受基准元素选择不好以及待排序数组的影响，爆栈都有可能。</p><h3 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h3><p>快速排序算法的性能在八大排序中算得上是优秀的。<br>其平均时间复杂度是O(nlogn) 。其中划分子表的时间复杂度是logn级别，对子表排序的时间复杂度是n级别。<br>空间复杂度是O(n),开辟了三个长度为n的数组，总体为O(n)级别.</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构八大排序之冒泡排序算法</title>
      <link href="/2023/06/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2023/06/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构八大排序之冒泡排序算法"><a href="#数据结构八大排序之冒泡排序算法" class="headerlink" title="数据结构八大排序之冒泡排序算法"></a>数据结构八大排序之冒泡排序算法</h2><blockquote><p>需求：用户传入数字类型的数组，并传入排序规则（升序还是降序），实现数组排列，要求使用typescript实现</p></blockquote><p>首先对传入的排序规则参数做一下约束，提高程序健壮性。rt</p><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 定义枚举类型，规定接收的排序规则参数只能是特定的值</span><span class="token keyword">enum</span> SortType <span class="token punctuation">{</span>    Asc <span class="token operator">=</span> <span class="token string">'asc'</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//升序</span>    Desc <span class="token operator">=</span> <span class="token string">'desc'</span> <span class="token comment" spellcheck="true">//降序</span><span class="token punctuation">}</span></code></pre><p>下面是算法的实现过程，它接收两个参数，数组和排序规则</p><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 传入的arr必须为数组类型，type参数表示要升序还是降序，且成员是数字，函数返回值为数字数组</span><span class="token keyword">function</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span><span class="token keyword">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>type<span class="token punctuation">:</span>SortType<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> length <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 用来判断某轮对比是否发生了交换</span>        <span class="token keyword">let</span> isExchange <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 外层循环每执行完一轮都能确定一个元素的最终位置，所以要减去i轮，这里再减1是因为每次都是用下标j和j+1进行比较的</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>length<span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>type<span class="token operator">===</span>SortType<span class="token punctuation">.</span>Asc<span class="token punctuation">)</span><span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">// 使用解构赋值来进行交换，使得代码更加简洁</span>                <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">(</span><span class="token punctuation">[</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>isExchange <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">:</span>undefined            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>type<span class="token operator">===</span>SortType<span class="token punctuation">.</span>Desc<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">(</span><span class="token punctuation">[</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>isExchange <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">:</span>undefined               <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 发生了交换，此时还不能确定排序是否完成,还需要进行下一轮循环</span>            isExchange <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果某轮循环没有发生元素的交换，则表示排序已经完成，直接结束算法执行返回数组</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>isExchange<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">}</span></code></pre><p>当中使用了一个变量isExchange 来判断此轮循环是否发生了元素交换，如果没有，则可以立马结束算法，节省了一定的性能。<br>下面是算法的执行过程，拿【5，3，6，2，9，1】来做演示实现升序排列：<br>第一轮冒泡：<br>比较 5 和 3，交换位置：[3, 5, 6, 2, 9, 1]<br>比较 5 和 6，不交换位置：[3, 5, 6, 2, 9, 1]<br>比较 6 和 2，交换位置：[3, 5, 2, 6, 9, 1]<br>比较 6 和 9，不交换位置：[3, 5, 2, 6, 9, 1]<br>比较 9 和 1，交换位置：[3, 5, 2, 6, 1, 9]<br>第二轮冒泡：<br>比较 3 和 5，不交换位置：[3, 5, 2, 6, 1, 9]<br>比较 5 和 2，交换位置：[3, 2, 5, 6, 1, 9]<br>比较 5 和 6，不交换位置：[3, 2, 5, 6, 1, 9]<br>比较 6 和 1，交换位置：[3, 2, 5, 1, 6, 9]<br>第三轮冒泡：<br>比较 3 和 2，交换位置：[2, 3, 5, 1, 6, 9]<br>比较 3 和 5，不交换位置：[2, 3, 5, 1, 6, 9]<br>比较 5 和 1，交换位置：[2, 3, 1, 5, 6, 9]<br>第四轮冒泡：<br>比较 2 和 3，不交换位置：[2, 3, 1, 5, 6, 9]<br>比较 3 和 1，交换位置：[2, 1, 3, 5, 6, 9]<br>第五轮冒泡：<br>比较 2 和 1，交换位置：[1, 2, 3, 5, 6, 9]<br>最终排序结果应该是：[1, 2, 3, 5, 6, 9]</p><p>下面是该算法的使用以及真机的运行结果：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> sortArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">const</span> newArr <span class="token operator">=</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>sortArr<span class="token punctuation">,</span>SortType<span class="token punctuation">.</span>Asc<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newArr<span class="token punctuation">)</span></code></pre><p><img src="/img/sort1.png" class="lazyload placeholder" data-srcset="/img/sort1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"><br>升序排列</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> newArr <span class="token operator">=</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>sortArr<span class="token punctuation">,</span>SortType<span class="token punctuation">.</span>Desc<span class="token punctuation">)</span></code></pre><p><img src="/img/sort2.png" class="lazyload placeholder" data-srcset="/img/sort2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"><br>降序排列</p><p><strong>总结一下：</strong></p><p>时间复杂度：该算法的最好时间复杂度是O(n),也就是当待排序数组基本按序排列时；最坏时间复杂度为O(n²) ，也就是当数组完全逆序时。平均复杂度为O(n²)。<br>空间复杂度:该算法只创建了常量级别的变量，因此空间复杂度为O(1)。<br>稳定性:当遇到数组当中又两个相同的值的时候，默认不交换位置，因此该算法是稳定的。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组件化，模块化，高内聚和低耦合</title>
      <link href="/2023/06/19/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E9%AB%98%E5%86%85%E8%81%9A%E5%92%8C%E4%BD%8E%E8%80%A6%E5%90%88%E7%9B%B8%E5%85%B3/"/>
      <url>/2023/06/19/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E9%AB%98%E5%86%85%E8%81%9A%E5%92%8C%E4%BD%8E%E8%80%A6%E5%90%88%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><blockquote><p>下面是我看了相关的文章与解答总结出来的自己的看法：<br>组件化：对于Vue中中的组件化来说就是整合HTML css js在一个文件中，拥有特定的基础功能<br>我认为组件化开发的好处主要是：<br>1、增加程序的可维护性；<br>2、代码的复用性；<br>3、拆分成单个组件使得每个组件拥有独立的状态和数据，避免了全局变量污染。<br>4、有利于提升渲染性能，实现局部刷新</p></blockquote><p>  对于第一点增加程序的可维护性，尤其当开发大型应用的时候，程序中有大量的变量以及函数，如果不采用组件化的开发，当某个数据发生改变时，就要更新整个页面的内容，浪费的不必要的性能，而且在变量命名的时候也会令人有些恼头，容易造成命名冲突等问题，当项目越来越大的时候，容易出现bug，维护性相对较差。<br>对于第二点来说，当这个项目中很多页面都需要用到相同的组件的时候，如果不采用组件化，那只能重写，造成代码冗余，降低开发效率。<br>对于第三点和第四点来说，Vue的每个组件都拥有独立的数据和状态，是互不干扰的，每个组件是一个watcher，当这个组件中的数据更新的时候，只需重新渲染这一个组件的区域，提升了渲染性能，做到了局部刷新。</p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><blockquote><p>模块化，在前端这边可以单独对css，js等进行单独封装成单个文件，具有某个特定的功能。比如我们项目中的utils工具文件等等<br>模块化的好处：<br>1、方便代码的复用、可读性，减少代码冗余度，提高开发效率，模块化使得代码结构更清晰和模块间的关系更明确，代码更易读、易理解。方便代码的维护和交接。<br>2、可维护性：将大文件拆解成小文件，增加可读性，每个模块可拥有独特的功能，当某个功能出现了问题，可以统一得到解决，也方便找到问题所在位置。</p></blockquote><h2 id="高内聚与低耦合"><a href="#高内聚与低耦合" class="headerlink" title="高内聚与低耦合"></a>高内聚与低耦合</h2><blockquote><p>我理解的高内聚的定义是：组件或模块内部的元素（例如函数、类、方法）彼此关联紧密，<strong>共同完成一个明确的最终目标（功能）</strong>。高内聚意味着组件内的元素具有相似的功能、目的或责任，相关的代码被组织在一起，更容易定位和修改。<br>低耦合：彼此之间相对独立，相互之间的影响较小，<strong>每个组件或者模块单独完成最终目标中的一个小目标（功能）</strong>，且修改一个组件不会对其他组件造成太大的影响，可扩展性与灵活性好。</p></blockquote><p>为了更好的理解，我拿笔记本电脑来举个简单的例子，一个笔记本电脑的实现就等同于一个最终功能–供人使用，它需要硬件和软件来支撑这个最终功能，在这高内聚就体现为电脑的一个个零件，网卡、声卡、显卡、CPU等，它们分别实现某个特定的小功能（专精），当你的网卡坏了，你上不了网了，你第一时间会想到的就是网卡相关的部件以及关联的软件配置是否出现故障，这就体现了上面提到的高内聚更容易定位故障产生的位置，这就是高内聚。<br>但是呢单独一个零件又不能发挥什么作用，这些零件只是具有某个单独的功能，需要各个零件之间的合作与配合，才能组成一个完整的笔记本，才能拥有完整的功能，假如某一天你觉得CPU的性能不太好了，你想升级一下，那你只需要动CPU零件，其他零件受到的影响很小，这就是低耦合。<br>总之，代码的高内聚就是相关功能的代码组合在一起，实现某个特定的小功能，各个小功能需要关联起来才能实现整个大功能。<br>代码的低耦合就是某个特定的小功能的修改与变更对其他模块影响很小，方便针对某个单独的功能进行维护与更新。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Grid布局</title>
      <link href="/2023/06/17/CSS%20Grid%E5%B8%83%E5%B1%80%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/06/17/CSS%20Grid%E5%B8%83%E5%B1%80%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-Grid布局的使用"><a href="#CSS-Grid布局的使用" class="headerlink" title="CSS Grid布局的使用"></a>CSS Grid布局的使用</h1><p>介绍之前，先了解一下该门技术的优缺点，看自己是否值得学习，优缺点如下：</p><blockquote><p>优点：CSS Grid布局是一种用于创建网页布局的强大工具。它引入了一个二维网格系统，可以以行和列的形式创建布局，提供了更灵活和精确的控制，并且减少了不必要的一些计算。<br>缺点：兼容性问题：CSS Grid布局是在CSS3中引入的较新的特性，因此旧版本的浏览器可能不支持它或支持有限。</p></blockquote><h2 id="具体的使用"><a href="#具体的使用" class="headerlink" title="具体的使用"></a>具体的使用</h2><p>  <strong>布局效果如下：（利用grid布局）</strong><br> <img src="/img/result.png" class="lazyload placeholder" data-srcset="/img/result.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="效果图"><br>上图利用grid栅格系统，从上到下共三个部分，nav main footer<br>1、nav部分四个button独占一行，先看下nav部分具体的代码，再做介绍：</p><pre class=" language-css"><code class="language-css"><span class="token selector">nav</span><span class="token punctuation">{</span>    <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>    <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">4</span>,<span class="token number">1</span>fr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token property">gap</span><span class="token punctuation">:</span> <span class="token number">10</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面代码的意思是生成一行四列的表格，每列平摊空间，每个格子之间的间距为10px，且nav的宽度会根据屏幕的宽度进行自适应。<br> 2、main部分代码如下：</p><pre class=" language-css"><code class="language-css"><span class="token selector">main</span><span class="token punctuation">{</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">450</span>px<span class="token punctuation">;</span>    <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>    <span class="token property">gap</span><span class="token punctuation">:</span> <span class="token number">20</span>px<span class="token punctuation">;</span>    <span class="token property">grid-template-areas</span><span class="token punctuation">:</span> <span class="token string">'banner banner banner banner banner box-r-top'</span>    <span class="token string">'banner banner banner banner banner box-r-bottom'</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面是main部分，使用grid布局，其中grid-template-areas将main元素分割为两行六列的栅格，并使用命名空间分别占据main的空间，下面是内部的三个元素使用空间的代码：</p><pre class=" language-css"><code class="language-css"><span class="token selector">main li<span class="token pseudo-class">:first-child</span></span><span class="token punctuation">{</span>     <span class="token property">grid-area</span><span class="token punctuation">:</span> banner<span class="token punctuation">;</span>     <span class="token property">background</span><span class="token punctuation">:</span> <span class="token url">url(./banner.jpg)</span><span class="token punctuation">;</span>     <span class="token property">background-size</span><span class="token punctuation">:</span> cover<span class="token punctuation">;</span>     <span class="token property">background-position</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">main button</span><span class="token punctuation">{</span>     <span class="token property">color</span><span class="token punctuation">:</span> <span class="token function">var</span><span class="token punctuation">(</span>--light<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面的grid-area是用来占用空间的，它的值填写grid-template-areas的某个值，比如写banner就会占据main的所有命名空间名称是banner的位置。</p>]]></content>
      
      
      <categories>
          
          <category> HTML&amp;CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML&amp;CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue组件通讯</title>
      <link href="/2023/06/16/Vue%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/06/16/Vue%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue组件的三种常用的传值方式在日常工作中是用的非常多的，非常重要！"><a href="#Vue组件的三种常用的传值方式在日常工作中是用的非常多的，非常重要！" class="headerlink" title="Vue组件的三种常用的传值方式在日常工作中是用的非常多的，非常重要！"></a>Vue组件的三种常用的传值方式在日常工作中是用的非常多的，非常重要！</h2><blockquote><p>在进行下面的介绍之前，首先要搞清楚什么是父组件，子组件和兄弟组件，下面是他们的介绍</p></blockquote><ol><li><strong>父组件向子组件传值</strong><br>父组件向子组件共享传递数据需要使用自定义属性，示例代码如下：</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//父组件里面的主要内容</span><span class="token comment" spellcheck="true">//使用子组件，自定义属性名称将父组件的两个数据暴露给子组件，例如//我这使用了msg和user,然后子组件中同样使用msg与user接收数据，</span><span class="token comment" spellcheck="true">//同样注意是通过数据绑定的方式传递</span><span class="token operator">&lt;</span>Child <span class="token punctuation">:</span>msg<span class="token operator">=</span><span class="token string">"message"</span> <span class="token punctuation">:</span>user<span class="token operator">=</span><span class="token string">"suerinfo"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>Child<span class="token operator">></span><span class="token comment" spellcheck="true">//下面这一行是引入子组件,子组件的定义名称为Child，之后记得注册</span><span class="token keyword">import</span> Child <span class="token keyword">from</span> <span class="token string">'./路径名/child.vue'</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">{</span>        message<span class="token punctuation">:</span><span class="token string">'hello vue.js'</span>        userinfo<span class="token punctuation">:</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span><span class="token string">'hh'</span><span class="token punctuation">,</span>age<span class="token punctuation">:</span><span class="token number">20</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//子组件里面的内容</span><span class="token operator">&lt;</span>template<span class="token operator">></span>    <span class="token operator">&lt;</span>view<span class="token operator">></span>        <span class="token operator">&lt;</span>p<span class="token operator">></span>父组件传递过来的msg值<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">{</span>msg<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>        <span class="token operator">&lt;</span>p<span class="token operator">></span>父组件传递过来的user值<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">{</span>user<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>view<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token comment" spellcheck="true">//通过自定义属性接收父组件传过来的参数,这里的属性名称一定要与父组件保持一致（msg,user）,注意不要更改props里面的属性值，因为里面的属性是只读的，同时修改之后这样也会导致父子组件的值不同。</span>props<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'msg'</span><span class="token punctuation">,</span><span class="token string">'user'</span><span class="token punctuation">]</span></code></pre><p>最后简单总结就是：父组件绑定自定义属性，传值；子组件在props里面声明。<br> 2.  <strong>子组件向父组件传值</strong><br>子组件向父组件共享传递数据使用自定义事件。示例代码如下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//子组件(child.vue)中的内容</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span> child_data_<span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>child_data<span class="token operator">+</span><span class="token operator">=</span><span class="token number">2</span>            <span class="token comment" spellcheck="true">//第一步</span>            <span class="token comment" spellcheck="true">//子组件修改数据时，通过$emit()触发自定义事件</span>            <span class="token comment" spellcheck="true">//这里填写监听事件与想要传递给父组件的数据</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'dataChange'</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>child_data<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//父组件中的内容</span><span class="token comment" spellcheck="true">//第二步</span><span class="token comment" spellcheck="true">//其实就等于事件监听，监听子组件中的child_data的数据变化)</span><span class="token operator">&lt;</span>Child @datachange <span class="token operator">=</span> <span class="token string">"change"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>Child<span class="token operator">></span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span> fahter_data <span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//第三步</span>        <span class="token function">change</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//这里的val其实就是子组件传递过来的child_data</span>            <span class="token comment" spellcheck="true">//下面这句代码说白了就是起到一个转存的作用</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>father_data <span class="token operator">=</span> val        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p> 3.<strong>兄弟组件之间的数据传值</strong><br> 在vue2.x的版本中，兄弟组件之间的数据共享使用的是EventBus<br> 基本步骤：</p><ul><li>建立eventBus.js模块，并向外共享一个Vue的实例对象</li><li>在发送方组件中调用EventBus.$emit（‘事件名称’，要发送的数据）来触发自定义事件</li><li>在接收方组件，调用EventBus.$on(‘事件名称’，事件处理函数)<br>来注册一个自定义事件</li></ul><p>下面是示例代码：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//兄弟组件（数据发送方）</span><span class="token keyword">import</span> eventBus <span class="token keyword">from</span> <span class="token string">'./eventBus.js'</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>            data<span class="token punctuation">:</span><span class="token string">'hello'</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">snedData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            eventBus<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'share'</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//eventBus.js</span><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token comment" spellcheck="true">//向外共享Vue的实例对象</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">vue</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//兄弟组件（数据接收方）</span><span class="token keyword">import</span> eventBus <span class="token keyword">from</span> <span class="token string">'./eventBus.js'</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>            receive_data<span class="token punctuation">:</span><span class="token string">' '</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        eventBus<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'share'</span><span class="token punctuation">,</span>val <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>receive_data <span class="token operator">=</span> val        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后简单总结三种传值关系就是：<br>父向子传数据使用自定义属性<br>子向父传数据使用自定义事件<br>兄弟组件之间传送数据使用EventBus</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
