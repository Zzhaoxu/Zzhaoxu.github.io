<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Boke</title>
  
  
  <link href="https://github.com/atom.xml" rel="self"/>
  
  <link href="https://github.com/"/>
  <updated>2023-06-20T12:09:49.068Z</updated>
  <id>https://github.com/</id>
  
  <author>
    <name>developer.zx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://github.com/2023/06/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://github.com/2023/06/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2023-06-20T11:31:18.024Z</published>
    <updated>2023-06-20T12:09:49.068Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构八大排序之冒泡排序算法"><a href="#数据结构八大排序之冒泡排序算法" class="headerlink" title="数据结构八大排序之冒泡排序算法"></a>数据结构八大排序之冒泡排序算法</h2><blockquote><p>需求：用户传入数字类型的数组，并传入排序规则（升序还是降序），实现数组排列，要求使用typescript实现</p></blockquote><p>首先对传入的排序规则参数做一下约束，提高程序健壮性。rt</p><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 定义枚举类型，规定接收的排序规则参数只能是特定的值</span><span class="token keyword">enum</span> SortType <span class="token punctuation">{</span>    Asc <span class="token operator">=</span> <span class="token string">'asc'</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//升序</span>    Desc <span class="token operator">=</span> <span class="token string">'desc'</span> <span class="token comment" spellcheck="true">//降序</span><span class="token punctuation">}</span></code></pre><p>下面是算法的实现过程，它接收两个参数，数组和排序规则</p><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 传入的arr必须为数组类型，type参数表示要升序还是降序，且成员是数字，函数返回值为数字数组</span><span class="token keyword">function</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span><span class="token keyword">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>type<span class="token punctuation">:</span>SortType<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> length <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 用来判断某轮对比是否发生了交换</span>        <span class="token keyword">let</span> isExchange <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 外层循环每执行完一轮都能确定一个元素的最终位置，所以要减去i轮，这里再减1是因为每次都是用下标j和j+1进行比较的</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>length<span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>type<span class="token operator">===</span>SortType<span class="token punctuation">.</span>Asc<span class="token punctuation">)</span><span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">// 使用解构赋值来进行交换，使得代码更加简洁</span>                <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">(</span><span class="token punctuation">[</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>isExchange <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">:</span>undefined            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>type<span class="token operator">===</span>SortType<span class="token punctuation">.</span>Desc<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">(</span><span class="token punctuation">[</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>isExchange <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">:</span>undefined               <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 发生了交换，此时还不能确定排序是否完成,还需要进行下一轮循环</span>            isExchange <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果某轮循环没有发生元素的交换，则表示排序已经完成，直接结束算法执行返回数组</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>isExchange<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">}</span></code></pre><p>当中使用了一个变量isExchange 来判断此轮循环是否发生了元素交换，如果没有，则可以立马结束算法，节省了一定的性能。<br>下面是算法的执行过程，拿【5，3，6，2，9，1】来做演示实现升序排列：<br>第一轮冒泡：<br>比较 5 和 3，交换位置：[3, 5, 6, 2, 9, 1]<br>比较 5 和 6，不交换位置：[3, 5, 6, 2, 9, 1]<br>比较 6 和 2，交换位置：[3, 5, 2, 6, 9, 1]<br>比较 6 和 9，不交换位置：[3, 5, 2, 6, 9, 1]<br>比较 9 和 1，交换位置：[3, 5, 2, 6, 1, 9]<br>第二轮冒泡：<br>比较 3 和 5，不交换位置：[3, 5, 2, 6, 1, 9]<br>比较 5 和 2，交换位置：[3, 2, 5, 6, 1, 9]<br>比较 5 和 6，不交换位置：[3, 2, 5, 6, 1, 9]<br>比较 6 和 1，交换位置：[3, 2, 5, 1, 6, 9]<br>第三轮冒泡：<br>比较 3 和 2，交换位置：[2, 3, 5, 1, 6, 9]<br>比较 3 和 5，不交换位置：[2, 3, 5, 1, 6, 9]<br>比较 5 和 1，交换位置：[2, 3, 1, 5, 6, 9]<br>第四轮冒泡：<br>比较 2 和 3，不交换位置：[2, 3, 1, 5, 6, 9]<br>比较 3 和 1，交换位置：[2, 1, 3, 5, 6, 9]<br>第五轮冒泡：<br>比较 2 和 1，交换位置：[1, 2, 3, 5, 6, 9]<br>最终排序结果应该是：[1, 2, 3, 5, 6, 9]</p><p>下面是该算法的使用以及真机的运行结果：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> sortArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">const</span> newArr <span class="token operator">=</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>sortArr<span class="token punctuation">,</span>SortType<span class="token punctuation">.</span>Asc<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newArr<span class="token punctuation">)</span></code></pre><p><img src="/img/sort1.png" class="lazyload placeholder" data-srcset="/img/sort1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"><br>升序排列</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> newArr <span class="token operator">=</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>sortArr<span class="token punctuation">,</span>SortType<span class="token punctuation">.</span>Desc<span class="token punctuation">)</span></code></pre><p><img src="/img/sort2.png" class="lazyload placeholder" data-srcset="/img/sort2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"><br>降序排列</p><p><strong>总结一下：</strong></p><p>时间复杂度：该算法的最好时间复杂度是O(n),也就是当待排序数组基本按序排列时；最坏时间复杂度为O(n²) ，也就是当数组完全逆序时。平均复杂度为O(n²)。<br>空间复杂度:该算法只创建了常量级别的变量，因此空间复杂度为O(1)。<br>稳定性:当遇到数组当中又两个相同的值的时候，默认不交换位置，因此该算法是稳定的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据结构八大排序之冒泡排序算法&quot;&gt;&lt;a href=&quot;#数据结构八大排序之冒泡排序算法&quot; class=&quot;headerlink&quot; title=&quot;数据结构八大排序之冒泡排序算法&quot;&gt;&lt;/a&gt;数据结构八大排序之冒泡排序算法&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;需求：用户</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/2023/06/19/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E9%AB%98%E5%86%85%E8%81%9A%E5%92%8C%E4%BD%8E%E8%80%A6%E5%90%88%E7%9B%B8%E5%85%B3/"/>
    <id>https://github.com/2023/06/19/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E9%AB%98%E5%86%85%E8%81%9A%E5%92%8C%E4%BD%8E%E8%80%A6%E5%90%88%E7%9B%B8%E5%85%B3/</id>
    <published>2023-06-19T15:50:28.524Z</published>
    <updated>2023-06-19T15:50:30.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><blockquote><p>下面是我看了相关的文章与解答总结出来的自己的看法：<br>组件化：对于Vue中中的组件化来说就是整合HTML css js在一个文件中，拥有特定的基础功能<br>我认为组件化开发的好处主要是：<br>1、增加程序的可维护性；<br>2、代码的复用性；<br>3、拆分成单个组件使得每个组件拥有独立的状态和数据，避免了全局变量污染。<br>4、有利于提升渲染性能，实现局部刷新</p></blockquote><p>  对于第一点增加程序的可维护性，尤其当开发大型应用的时候，程序中有大量的变量以及函数，如果不采用组件化的开发，当某个数据发生改变时，就要更新整个页面的内容，浪费的不必要的性能，而且在变量命名的时候也会令人有些恼头，容易造成命名冲突等问题，当项目越来越大的时候，容易出现bug，维护性相对较差。<br>对于第二点来说，当这个项目中很多页面都需要用到相同的组件的时候，如果不采用组件化，那只能重写，造成代码冗余，降低开发效率。<br>对于第三点和第四点来说，Vue的每个组件都拥有独立的数据和状态，是互不干扰的，每个组件是一个watcher，当这个组件中的数据更新的时候，只需重新渲染这一个组件的区域，提升了渲染性能，做到了局部刷新。</p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><blockquote><p>模块化，在前端这边可以单独对css，js等进行单独封装成单个文件，具有某个特定的功能。比如我们项目中的utils工具文件等等<br>模块化的好处：<br>1、方便代码的复用、可读性，减少代码冗余度，提高开发效率，模块化使得代码结构更清晰和模块间的关系更明确，代码更易读、易理解。方便代码的维护和交接。<br>2、可维护性：将大文件拆解成小文件，增加可读性，每个模块可拥有独特的功能，当某个功能出现了问题，可以统一得到解决，也方便找到问题所在位置。</p></blockquote><h2 id="高内聚与低耦合"><a href="#高内聚与低耦合" class="headerlink" title="高内聚与低耦合"></a>高内聚与低耦合</h2><blockquote><p>我理解的高内聚的定义是：组件或模块内部的元素（例如函数、类、方法）彼此关联紧密，<strong>共同完成一个明确的最终目标（功能）</strong>。高内聚意味着组件内的元素具有相似的功能、目的或责任，相关的代码被组织在一起，更容易定位和修改。<br>低耦合：彼此之间相对独立，相互之间的影响较小，<strong>每个组件或者模块单独完成最终目标中的一个小目标（功能）</strong>，且修改一个组件不会对其他组件造成太大的影响，可扩展性与灵活性好。</p></blockquote><p>为了更好的理解，我拿笔记本电脑来举个简单的例子，一个笔记本电脑的实现就等同于一个最终功能–供人使用，它需要硬件和软件来支撑这个最终功能，在这高内聚就体现为电脑的一个个零件，网卡、声卡、显卡、CPU等，它们分别实现某个特定的小功能（专精），当你的网卡坏了，你上不了网了，你第一时间会想到的就是网卡相关的部件以及关联的软件配置是否出现故障，这就体现了上面提到的高内聚更容易定位故障产生的位置，这就是高内聚。<br>但是呢单独一个零件又不能发挥什么作用，这些零件只是具有某个单独的功能，需要各个零件之间的合作与配合，才能组成一个完整的笔记本，才能拥有完整的功能，假如某一天你觉得CPU的性能不太好了，你想升级一下，那你只需要动CPU零件，其他零件受到的影响很小，这就是低耦合。<br>总之，代码的高内聚就是相关功能的代码组合在一起，实现某个特定的小功能，各个小功能需要关联起来才能实现整个大功能。<br>代码的低耦合就是某个特定的小功能的修改与变更对其他模块影响很小，方便针对某个单独的功能进行维护与更新。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;组件化&quot;&gt;&lt;a href=&quot;#组件化&quot; class=&quot;headerlink&quot; title=&quot;组件化&quot;&gt;&lt;/a&gt;组件化&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;下面是我看了相关的文章与解答总结出来的自己的看法：&lt;br&gt;组件化：对于Vue中中的组件化来说就是整合HTM</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/2023/06/17/CSS%20Grid%E5%B8%83%E5%B1%80%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://github.com/2023/06/17/CSS%20Grid%E5%B8%83%E5%B1%80%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-06-17T11:21:18.237Z</published>
    <updated>2023-06-20T12:09:15.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS-Grid布局的使用"><a href="#CSS-Grid布局的使用" class="headerlink" title="CSS Grid布局的使用"></a>CSS Grid布局的使用</h1><p>介绍之前，先了解一下该门技术的优缺点，看自己是否值得学习，优缺点如下：</p><blockquote><p>优点：CSS Grid布局是一种用于创建网页布局的强大工具。它引入了一个二维网格系统，可以以行和列的形式创建布局，提供了更灵活和精确的控制，并且减少了不必要的一些计算。<br>缺点：兼容性问题：CSS Grid布局是在CSS3中引入的较新的特性，因此旧版本的浏览器可能不支持它或支持有限。</p></blockquote><h2 id="具体的使用"><a href="#具体的使用" class="headerlink" title="具体的使用"></a>具体的使用</h2><p>  <strong>布局效果如下：（利用grid布局）</strong><br> <img src="/img/result.png" class="lazyload placeholder" data-srcset="/img/result.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="效果图"><br>上图利用grid栅格系统，从上到下共三个部分，nav main footer<br>1、nav部分四个button独占一行，先看下nav部分具体的代码，再做介绍：</p><pre class=" language-css"><code class="language-css"><span class="token selector">nav</span><span class="token punctuation">{</span>    <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>    <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">4</span>,<span class="token number">1</span>fr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token property">gap</span><span class="token punctuation">:</span> <span class="token number">10</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面代码的意思是生成一行四列的表格，每列平摊空间，每个格子之间的间距为10px，且nav的宽度会根据屏幕的宽度进行自适应。<br> 2、main部分代码如下：</p><pre class=" language-css"><code class="language-css"><span class="token selector">main</span><span class="token punctuation">{</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">450</span>px<span class="token punctuation">;</span>    <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>    <span class="token property">gap</span><span class="token punctuation">:</span> <span class="token number">20</span>px<span class="token punctuation">;</span>    <span class="token property">grid-template-areas</span><span class="token punctuation">:</span> <span class="token string">'banner banner banner banner banner box-r-top'</span>    <span class="token string">'banner banner banner banner banner box-r-bottom'</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面是main部分，使用grid布局，其中grid-template-areas将main元素分割为两行六列的栅格，并使用命名空间分别占据main的空间，下面是内部的三个元素使用空间的代码：</p><pre class=" language-css"><code class="language-css"><span class="token selector">main li<span class="token pseudo-class">:first-child</span></span><span class="token punctuation">{</span>     <span class="token property">grid-area</span><span class="token punctuation">:</span> banner<span class="token punctuation">;</span>     <span class="token property">background</span><span class="token punctuation">:</span> <span class="token url">url(./banner.jpg)</span><span class="token punctuation">;</span>     <span class="token property">background-size</span><span class="token punctuation">:</span> cover<span class="token punctuation">;</span>     <span class="token property">background-position</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">main button</span><span class="token punctuation">{</span>     <span class="token property">color</span><span class="token punctuation">:</span> <span class="token function">var</span><span class="token punctuation">(</span>--light<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面的grid-area是用来占用空间的，它的值填写grid-template-areas的某个值，比如写banner就会占据main的所有命名空间名称是banner的位置。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSS-Grid布局的使用&quot;&gt;&lt;a href=&quot;#CSS-Grid布局的使用&quot; class=&quot;headerlink&quot; title=&quot;CSS Grid布局的使用&quot;&gt;&lt;/a&gt;CSS Grid布局的使用&lt;/h1&gt;&lt;p&gt;介绍之前，先了解一下该门技术的优缺点，看自己是否值得</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/2023/06/16/Vue%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E4%BB%8B%E7%BB%8D/"/>
    <id>https://github.com/2023/06/16/Vue%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E4%BB%8B%E7%BB%8D/</id>
    <published>2023-06-16T06:22:32.000Z</published>
    <updated>2023-06-16T06:22:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue组件的三种常用的传值方式在日常工作中是用的非常多的，非常重要！"><a href="#Vue组件的三种常用的传值方式在日常工作中是用的非常多的，非常重要！" class="headerlink" title="Vue组件的三种常用的传值方式在日常工作中是用的非常多的，非常重要！"></a>Vue组件的三种常用的传值方式在日常工作中是用的非常多的，非常重要！</h2><blockquote><p>在进行下面的介绍之前，首先要搞清楚什么是父组件，子组件和兄弟组件，下面是他们的介绍</p></blockquote><ol><li><strong>父组件向子组件传值</strong><br>父组件向子组件共享传递数据需要使用自定义属性，示例代码如下：</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//父组件里面的主要内容</span><span class="token comment" spellcheck="true">//使用子组件，自定义属性名称将父组件的两个数据暴露给子组件，例如//我这使用了msg和user,然后子组件中同样使用msg与user接收数据，</span><span class="token comment" spellcheck="true">//同样注意是通过数据绑定的方式传递</span><span class="token operator">&lt;</span>Child <span class="token punctuation">:</span>msg<span class="token operator">=</span><span class="token string">"message"</span> <span class="token punctuation">:</span>user<span class="token operator">=</span><span class="token string">"suerinfo"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>Child<span class="token operator">></span><span class="token comment" spellcheck="true">//下面这一行是引入子组件,子组件的定义名称为Child，之后记得注册</span><span class="token keyword">import</span> Child <span class="token keyword">from</span> <span class="token string">'./路径名/child.vue'</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">{</span>        message<span class="token punctuation">:</span><span class="token string">'hello vue.js'</span>        userinfo<span class="token punctuation">:</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span><span class="token string">'hh'</span><span class="token punctuation">,</span>age<span class="token punctuation">:</span><span class="token number">20</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//子组件里面的内容</span><span class="token operator">&lt;</span>template<span class="token operator">></span>    <span class="token operator">&lt;</span>view<span class="token operator">></span>        <span class="token operator">&lt;</span>p<span class="token operator">></span>父组件传递过来的msg值<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">{</span>msg<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>        <span class="token operator">&lt;</span>p<span class="token operator">></span>父组件传递过来的user值<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">{</span>user<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>view<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token comment" spellcheck="true">//通过自定义属性接收父组件传过来的参数,这里的属性名称一定要与父组件保持一致（msg,user）,注意不要更改props里面的属性值，因为里面的属性是只读的，同时修改之后这样也会导致父子组件的值不同。</span>props<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'msg'</span><span class="token punctuation">,</span><span class="token string">'user'</span><span class="token punctuation">]</span></code></pre><p>最后简单总结就是：父组件绑定自定义属性，传值；子组件在props里面声明。<br> 2.  <strong>子组件向父组件传值</strong><br>子组件向父组件共享传递数据使用自定义事件。示例代码如下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//子组件(child.vue)中的内容</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span> child_data_<span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>child_data<span class="token operator">+</span><span class="token operator">=</span><span class="token number">2</span>            <span class="token comment" spellcheck="true">//第一步</span>            <span class="token comment" spellcheck="true">//子组件修改数据时，通过$emit()触发自定义事件</span>            <span class="token comment" spellcheck="true">//这里填写监听事件与想要传递给父组件的数据</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'dataChange'</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>child_data<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//父组件中的内容</span><span class="token comment" spellcheck="true">//第二步</span><span class="token comment" spellcheck="true">//其实就等于事件监听，监听子组件中的child_data的数据变化)</span><span class="token operator">&lt;</span>Child @datachange <span class="token operator">=</span> <span class="token string">"change"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>Child<span class="token operator">></span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span> fahter_data <span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//第三步</span>        <span class="token function">change</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//这里的val其实就是子组件传递过来的child_data</span>            <span class="token comment" spellcheck="true">//下面这句代码说白了就是起到一个转存的作用</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>father_data <span class="token operator">=</span> val        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p> 3.<strong>兄弟组件之间的数据传值</strong><br> 在vue2.x的版本中，兄弟组件之间的数据共享使用的是EventBus<br> 基本步骤：</p><ul><li>建立eventBus.js模块，并向外共享一个Vue的实例对象</li><li>在发送方组件中调用EventBus.$emit（‘事件名称’，要发送的数据）来触发自定义事件</li><li>在接收方组件，调用EventBus.$on(‘事件名称’，事件处理函数)<br>来注册一个自定义事件</li></ul><p>下面是示例代码：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//兄弟组件（数据发送方）</span><span class="token keyword">import</span> eventBus <span class="token keyword">from</span> <span class="token string">'./eventBus.js'</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>            data<span class="token punctuation">:</span><span class="token string">'hello'</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">snedData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            eventBus<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'share'</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//eventBus.js</span><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token comment" spellcheck="true">//向外共享Vue的实例对象</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">vue</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//兄弟组件（数据接收方）</span><span class="token keyword">import</span> eventBus <span class="token keyword">from</span> <span class="token string">'./eventBus.js'</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>            receive_data<span class="token punctuation">:</span><span class="token string">' '</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        eventBus<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'share'</span><span class="token punctuation">,</span>val <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>receive_data <span class="token operator">=</span> val        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后简单总结三种传值关系就是：<br>父向子传数据使用自定义属性<br>子向父传数据使用自定义事件<br>兄弟组件之间传送数据使用EventBus</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Vue组件的三种常用的传值方式在日常工作中是用的非常多的，非常重要！&quot;&gt;&lt;a href=&quot;#Vue组件的三种常用的传值方式在日常工作中是用的非常多的，非常重要！&quot; class=&quot;headerlink&quot; title=&quot;Vue组件的三种常用的传值方式在日常工作中是用的</summary>
      
    
    
    
    
  </entry>
  
</feed>
