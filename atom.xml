<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Boke</title>
  
  
  <link href="https://github.com/atom.xml" rel="self"/>
  
  <link href="https://github.com/"/>
  <updated>2023-09-06T13:37:19.861Z</updated>
  <id>https://github.com/</id>
  
  <author>
    <name>developer.zx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode刷题-20230906</title>
    <link href="https://github.com/2023/09/06/LeetCode%E5%88%B7%E9%A2%98----2023.09.06/"/>
    <id>https://github.com/2023/09/06/LeetCode%E5%88%B7%E9%A2%98----2023.09.06/</id>
    <published>2023-09-05T16:00:00.000Z</published>
    <updated>2023-09-06T13:37:19.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode刷题"><a href="#LeetCode刷题" class="headerlink" title="LeetCode刷题"></a>LeetCode刷题</h2><h5 id="这道题考察的点是闭包的应用"><a href="#这道题考察的点是闭包的应用" class="headerlink" title="这道题考察的点是闭包的应用"></a>这道题考察的点是闭包的应用</h5><blockquote><p>个人对闭包的理解：该作用域存在对上级作用域当中变量的引用即形成闭包。上级作用域内的变量，因为被下级作用域内引用，而没有被释放。就导致上级作用域内的变量，等到下级作用域执行完以后才正常得到释放（也就是说当解除了对该闭包的所有引用的时候，这个闭包才会被JS的垃圾回收机制回收）</p></blockquote><blockquote><p>闭包的作用：能够保持变量的状态，这道题就是利用了闭包的该特性。</p></blockquote><p><img src="/img/20230906_1.png" class="lazyload placeholder" data-srcset="/img/20230906_1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="测试用例结果"></p><h4 id="这道题考察的就是数组遍历"><a href="#这道题考察的就是数组遍历" class="headerlink" title="这道题考察的就是数组遍历"></a>这道题考察的就是数组遍历</h4><p>算法思想:遍历数组，若该索引对应的值大于等于target，则直接进入下一轮循环，若小于target，则使用target-当前值得到预期的另外一个值，然后将该值与数组传入到searchHasOtherNum方法中，寻找是否含有该值，如果有，则返回值的索引，如果没有就返回-1。<br><img src="/img/20230906_2.png" class="lazyload placeholder" data-srcset="/img/20230906_2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="测试用例结果"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;LeetCode刷题&quot;&gt;&lt;a href=&quot;#LeetCode刷题&quot; class=&quot;headerlink&quot; title=&quot;LeetCode刷题&quot;&gt;&lt;/a&gt;LeetCode刷题&lt;/h2&gt;&lt;h5 id=&quot;这道题考察的点是闭包的应用&quot;&gt;&lt;a href=&quot;#这道题考察的点是</summary>
      
    
    
    
    <category term="Typescript" scheme="https://github.com/categories/Typescript/"/>
    
    
    <category term="Typescript" scheme="https://github.com/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>JS基础知识篇三</title>
    <link href="https://github.com/2023/08/14/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%863/"/>
    <id>https://github.com/2023/08/14/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%863/</id>
    <published>2023-08-13T16:00:00.000Z</published>
    <updated>2023-08-14T02:31:59.391Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS基础知识篇三"><a href="#JS基础知识篇三" class="headerlink" title="JS基础知识篇三"></a>JS基础知识篇三</h2><h5 id=""><a href="#" class="headerlink" title=""></a><details green="" open=""><summary pointer=""> 1.前端代码重构需要从哪些方面考虑？ </summary>              <div class="content">              <p>前端代码重构是对现有代码进行优化和改进的过程，以提高代码质量、可维护性和性能。在进行前端代码重构时，需要从多个方面进行考虑和规划：<br><span class="p ">代码结构优化</span>： 检查代码的组织结构，确保模块化、可扩展性和可维护性。拆分大型函数或组件，遵循设计模式和最佳实践。<br><span class="p ">命名和注释</span>： 确保代码中的变量、函数、类和组件的命名具有描述性，易于理解。添加清晰的注释，解释代码的意图和功能。<br><span class="p ">重复代码消除</span>： 寻找并消除重复的代码片段，可以将其提取为函数、组件或工具函数，以减少代码冗余。<br><span class="p ">性能优化</span>： 评估代码的性能瓶颈，优化关键路径和性能敏感区域。减少不必要的 DOM 操作、网络请求和资源加载时间。<br><span class="p ">数据流管理</span>： 使用状态管理库（如 Redux、Vuex、Mobx 等）来管理数据流，确保数据的一致性和可追踪性。<br><span class="p ">响应式设计</span>： 确保应用在不同设备和屏幕尺寸上都能正常工作，采用响应式设计和媒体查询。<br><span class="p ">测试覆盖率提升</span>： 增加代码的测试覆盖率，编写单元测试、集成测试和端到端测试，以确保代码的正确性和稳定性。<br><span class="p ">优化加载性能</span>： 优化资源加载顺序，使用合适的打包工具和代码分割策略，以减少页面加载时间。<br><span class="p ">可访问性</span>： 确保应用对于残障人士也具有良好的可访问性，遵循 Web Content Accessibility Guidelines（WCAG）。<br><span class="p ">代码规范</span>： 遵循一致的代码规范和风格，可以使用代码风格检查工具（如 ESLint）来保持代码的一致性。<br><span class="p ">技术选型</span>： 评估当前使用的技术栈是否仍然适合项目需求，是否需要更新或替换某些技术。<br>文档更新： 更新项目文档，记录代码改动、新增功能和更新的文档。<br>在进行前端代码重构时，还应该考虑项目的紧急程度、团队协作、风险管理等因素，以确保重构过程是有序、逐步的，并且不会影响现有的业务功能。</p>              </div>            </details></h5><h5 id="-1"><a href="#-1" class="headerlink" title=""></a><details green="" open=""><summary pointer=""> 2.那重构的目的是什么？ </summary>              <div class="content">              <p>前端代码重构的主要目的是改进现有代码的质量、可维护性、可读性和性能，以及减少技术债务。重构是一个有目的的过程，旨在使代码更加健壮、可扩展、易于理解和修改。以下是重构的一些主要目的：<br><span class="p ">代码质量提升</span>： 通过重构，可以改进代码的结构、命名、注释和设计，从而提高代码的整体质量，减少代码的混乱和冗余。<br><span class="p ">可维护性增强</span>： 重构可以使代码更易于维护，降低维护成本。通过拆分函数、模块化代码和应用设计模式，可以更容易地定位和修复 bug。<br><span class="p ">可读性改善</span>： 重构可以使代码更易于理解，通过改善命名、提取函数、删除无用代码等方式，使代码更具可读性，新成员可以更快速地融入项目。<br>性能优化： 通过重构可以识别和改进性能问题，如减少不必要的计算、内存泄漏、资源加载等，提高应用的性能和响应速度。<br><span class="p ">减少技术债务</span>： 随着时间的推移，项目中可能会积累技术债务，导致代码难以维护和扩展。重构可以帮助减少技术债务，保持代码的健康状态。<br><span class="p ">增加适应性</span>： 重构可以使代码更易于适应变化，响应需求变更和新特性的引入，从而使项目更具灵活性。<br><span class="p ">降低风险</span>： 通过提高代码质量和稳定性，重构可以降低出现严重错误和故障的风险，提高应用的稳定性。<br><span class="p ">提高团队协作</span>： 规范的代码结构和命名可以促进团队成员之间的协作，减少代码冲突和误解。</p>              </div>            </details></h5><h5 id="-2"><a href="#-2" class="headerlink" title=""></a><details green="" open=""><summary pointer=""> 3.为什么要减少HTTP请求？（这里应该是要回答请求的过程和性能之间的关系） </summary>              <div class="content">              <p>减少 HTTP 请求是前端性能优化的关键策略之一，这是因为 HTTP 请求的过程对于网页加载性能有着重要影响。以下是几个原因解释为什么要减少 HTTP 请求：<br><span class="p ">网络延迟和响应时间</span>： 发起一个 HTTP 请求需要经过多个阶段，包括 DNS 解析、建立连接、发送请求、等待服务器响应、接收响应等，每个阶段都会增加网络延迟。减少请求意味着减少这些阶段的开销，从而降低页面加载时间，提供更好的用户体验。<br><span class="p ">带宽消耗</span>： 每个 HTTP 请求都会消耗带宽，特别是在移动设备上。减少请求可以降低总体带宽消耗，有助于节省用户的数据流量。<br><span class="p ">浏览器并发限制</span>： 大多数浏览器有并发请求限制，例如每个域名的同时请求数量有限。减少请求可以避免过多的请求被阻塞，提高并发性能。<br><span class="p ">页面渲染</span>： 每个请求都会触发浏览器的渲染过程，包括样式计算、布局、绘制等。减少请求可以降低渲染开销，加速页面加载和交互响应。<br><span class="p ">移动设备性能</span>： 移动设备的网络连接和处理能力相对较弱，较多的 HTTP 请求会对性能造成更大影响。减少请求可以改善移动设备上的用户体验。<br>为了减少 HTTP 请求，可以采取以下策略：<br><span class="p ">合并资源</span>：将多个小资源合并为一个大资源，如合并 CSS、JS 文件。<br><span class="p ">使用雪碧图（Sprites）</span>：将多个小图标合并成一张图片，通过 CSS 中的背景定位来显示不同图标。<br><span class="p ">利用缓存</span>：使用浏览器缓存机制，减少重复请求。<br><span class="p ">延迟加载</span>：将不关键的资源（如图片、JavaScript）推迟加载，以提高页面的首次加载速度。<br><span class="p ">使用数据URI</span>：将小图片直接嵌入到 CSS 中，避免额外的请求。<br><span class="p ">通过减少 HTTP 请求</span>，可以显著提升网页加载性能，加快页面加载速度，提供更好的用户体验。</p>              </div>            </details></h5><h5 id="-3"><a href="#-3" class="headerlink" title=""></a><details green="" open=""><summary pointer=""> 4. 怎么减少重排和重绘？ </summary>              <div class="content">              <p>重排（Reflow）和重绘（Repaint）是浏览器渲染过程中的两个关键步骤，它们可能会对页面性能产生影响。重排是指计算并应用元素的几何属性（如位置、大小、布局等），而重绘是指更新元素的视觉外观（如颜色、背景等）。由于重排和重绘会触发浏览器重新计算和绘制页面，因此频繁的重排和重绘会降低页面性能。</p><p>以下是一些减少重排和重绘的方法：</p><p><span class="p ">使用 CSS Transitions 和 Animations</span>： 使用 CSS Transitions 和 Animations 来实现动画效果，它们通常会在合适的情况下使用 GPU 加速，减少对页面布局的影响，从而减少重排。</p><p><span class="p ">使用 CSS Transform</span>： 使用 CSS Transform 属性来实现平移、旋转、缩放等变换，这可以触发 GPU 加速，减少对布局的影响。</p><p><span class="p ">避免频繁操作样式</span>： 避免在 JavaScript 中频繁操作样式，因为每次修改样式都可能触发重排和重绘。如果需要多次修改样式，可以使用 CSS 类名来一次性修改，减少对页面渲染的干扰。</p><p><span class="p ">使用 DocumentFragment</span>： 当需要操作 DOM 元素集合时，可以使用 DocumentFragment 来避免多次重排和重绘，因为 DocumentFragment 可以在内存中进行操作，然后一次性插入到页面中。</p><p><span class="p ">将元素脱离文档流</span>： 对于会导致重排的操作，可以将元素脱离文档流（例如使用 position: absolute 或 position: fixed），进行修改后再重新插入文档流中，以减少重排的影响。</p><p><span class="p ">批量更新</span>： 对于需要多次修改 DOM 的情况，可以使用批量更新的方式，将多个修改操作合并为一个，然后一次性更新 DOM，从而减少重排和重绘。</p><p><span class="p ">避免频繁查询布局信息</span>： 避免在循环中频繁查询布局信息（如元素的位置和尺寸），因为这可能会触发多次重排。可以使用缓存或一次性获取布局信息来优化。</p>              </div>            </details></h5><h5 id="-4"><a href="#-4" class="headerlink" title=""></a><details green="" open=""><summary pointer=""> 5.如果不把DOM属性放在循环里面，具体应该怎么做？ </summary>              <div class="content">              <p>在循环中频繁查询 DOM 属性可能会触发多次重排（Reflow），从而降低性能。为了避免这种情况，可以采取以下方法来优化代码：</p><p><span class="p ">缓存 DOM 属性</span>： 在循环之前，将需要查询的 DOM 属性缓存到变量中。这样，在循环内部就不需要每次都去查询 DOM，而是直接使用已经缓存的属性。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> element <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'myElement'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> elementWidth <span class="token operator">=</span> element<span class="token punctuation">.</span>offsetWidth<span class="token punctuation">;</span><span class="token keyword">const</span> elementHeight <span class="token operator">=</span> element<span class="token punctuation">.</span>offsetHeight<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 在循环内部使用 elementWidth 和 elementHeight，避免重复查询}</span></code></pre><p><span class="p ">分离读写操作</span>： 如果循环内部需要修改 DOM 属性，可以先在循环外部进行查询和计算，然后在循环内部执行修改操作。这样可以将读取和写入操作分离，减少重排的次数。</p><p><span class="p ">使用虚拟 DOM（Virtual DOM）</span>： 虚拟 DOM 是一种将 DOM 操作抽象为虚拟节点（Virtual Node）的技术，通过在虚拟 DOM 上进行操作，然后一次性将变更应用到实际 DOM，可以减少重排的次数。</p>              </div>            </details></h5><h5 id="-5"><a href="#-5" class="headerlink" title=""></a><details green="" open=""><summary pointer=""> 6.defineProperty对于对象的哪些属性监听不到？ </summary>              <div class="content">              <p>Object.defineProperty 方法用于在对象上定义新的属性或修改现有属性，并且可以设置属性的特性（例如，可写、可枚举、可配置等）。然而，Object.defineProperty 并不是适用于所有属性的监听。</p><p>Object.defineProperty 无法监听到以下情况的属性变化：</p><p><span class="p ">新增属性或删除属性</span>： Object.defineProperty 无法监听对象属性的新增或删除操作，它只能监听已经存在的属性的变化。</p><p><span class="p ">数组的索引和长度</span>： 对于数组对象，Object.defineProperty 不能监听数组的索引变化或长度变化，因为数组的索引和长度并不是普通的属性，而是特殊的内置属性。</p><p><span class="p ">内置对象的属性</span>： 对于一些内置对象（如 Array、Date 等），Object.defineProperty 也无法监听属性的变化，因为这些对象的属性通常是内置的、无法通过普通方式重新定义的。</p><p>要在 JavaScript 中实现更全面的属性监听，你可以使用 Proxy 对象。Proxy 对象允许你拦截并自定义对象的操作，包括属性的访问、修改、添加和删除等。</p>              </div>            </details></h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JS基础知识篇三&quot;&gt;&lt;a href=&quot;#JS基础知识篇三&quot; class=&quot;headerlink&quot; title=&quot;JS基础知识篇三&quot;&gt;&lt;/a&gt;JS基础知识篇三&lt;/h2&gt;&lt;h5 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;</summary>
      
    
    
    
    <category term="Typescript" scheme="https://github.com/categories/Typescript/"/>
    
    
    <category term="Typescript" scheme="https://github.com/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>JS基础知识篇二</title>
    <link href="https://github.com/2023/08/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%872/"/>
    <id>https://github.com/2023/08/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%872/</id>
    <published>2023-08-12T16:00:00.000Z</published>
    <updated>2023-08-14T00:56:40.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS基础知识篇二"><a href="#JS基础知识篇二" class="headerlink" title="JS基础知识篇二"></a>JS基础知识篇二</h2><h5 id="1-解释一下浏览器多线程以及如何实现？"><a href="#1-解释一下浏览器多线程以及如何实现？" class="headerlink" title="1.解释一下浏览器多线程以及如何实现？"></a>1.解释一下浏览器多线程以及如何实现？</h5><p>浏览器通常采用多线程来处理不同的任务，以提高用户体验和性能。主要的浏览器多线程包括以下几种：<br>主线程（Main Thread）： 这是浏览器中最重要的线程，负责处理用户界面、JavaScript 代码的执行、DOM 操作、布局和渲染等。在主线程中，有一个 JavaScript 引擎（例如 V8）负责解析和执行 JavaScript 代码。<br>渲染线程（Rendering Thread）： 负责将 HTML、CSS 和 JavaScript 转换为可视化的页面，包括布局、绘制、合成等。渲染线程通常与主线程交互，但在某些情况下也可以独立运行。<br>网络线程（Network Thread）： 负责处理网络请求和响应，包括下载 HTML、CSS、JavaScript、图片和其他资源。这有助于防止网络请求的阻塞影响用户界面的响应。<br>定时器线程（Timer Thread）： 负责管理定时器，例如 setTimeout 和 setInterval。当计时器到期时，会将回调函数放入主线程的消息队列中。<br>事件线程（Event Thread）： 处理事件和用户输入，例如点击、鼠标移动、键盘输入等。事件线程负责将事件放入主线程的消息队列中，以便主线程处理。<br>关于如何实现：通过消息队列和事件循环机制来协调。JavaScript 代码通常运行在主线程中，但通过异步编程（例如使用回调、Promise、async/await）可以利用事件循环机制实现非阻塞的异步操作；将一些计算密集型任务委托给 Web Workers 等机制来在后台线程执行。</p><h5 id="2-SSR介绍，渲染实现原理"><a href="#2-SSR介绍，渲染实现原理" class="headerlink" title="2. SSR介绍，渲染实现原理"></a>2. SSR介绍，渲染实现原理</h5><p>SSR（服务器端渲染）是一种在服务器端生成并输出渲染好的 HTML 页面给客户端的技术，相对于传统的客户端渲染（CSR）而言。SSR 的目标是改善页面的加载性能、搜索引擎优化（SEO）以及首次渲染时间，特别适用于单页面应用（SPA）等需要更好的性能和 SEO 的场景。<br>SSR 的渲染实现原理如下：<br>请求到渲染： 当浏览器请求一个页面时，服务器会处理该请求，根据路由和请求参数等决定要渲染的内容。<br>数据获取： 在服务器端，SSR 首先会根据当前请求的路由和页面组件，触发数据获取操作。这可以是从数据库、API 或其他数据源获取数据，确保渲染所需的数据是可用的。<br>渲染页面： 一旦数据准备完毕，服务器会将数据传递给页面组件，然后在服务器上执行页面组件的渲染过程，生成完整的 HTML。<br>生成响应： 服务器将渲染好的 HTML 页面作为响应返回给浏览器。这样，浏览器就不再需要等待 JavaScript 下载、解析和执行，即可显示页面内容。<br>客户端交互： 在浏览器接收到 HTML 后，它会开始渲染页面，并下载 JavaScript、CSS 等资源。与客户端渲染不同，这些资源在 SSR 中更多地用于增强页面交互、动画等方面，而不是渲染整个页面。<br>SSR 的优势包括：<br>更好的首次渲染性能： 由于服务器已经渲染好了页面内容，用户在浏览器中看到的内容更快。这对于降低首次加载时间很有帮助。<br>更好的 SEO： 由于搜索引擎可以直接抓取服务器返回的渲染好的 HTML 页面，SSR 有助于提升页面在搜索引擎中的可索引性。<br>更好的性能指标： SSR 可以降低页面的第一个内容绘制（FCP）和最大内容绘制（LCP）等性能指标，提高用户体验。<br>然而，SSR 也可能会增加服务器负载，需要更多的服务器资源，以及在开发上需要处理一些额外的复杂性。最终，选择使用 SSR 还是 CSR 取决于项目的需求和权衡。</p><h5 id="3-SSR常用方法介绍和实现原理"><a href="#3-SSR常用方法介绍和实现原理" class="headerlink" title="3.SSR常用方法介绍和实现原理"></a>3.SSR常用方法介绍和实现原理</h5><p>在服务器端渲染（SSR）中，有几种常用的方法和技术可以实现。以下是其中一些常见的方法以及它们的实现原理：<br>预渲染（Prerendering）：<br>预渲染是一种静态的服务器端渲染方法，适用于那些内容相对静态的页面。在构建时，预渲染将页面生成为 HTML 文件，并将这些文件托管在服务器上，供请求时直接返回。<br>实现原理：使用构建工具（如Webpack、Vue CLI、Nuxt.js）在构建阶段执行 SSR，生成静态 HTML 文件并存储在服务器上，当用户请求页面时直接返回预渲染的 HTML。<br>服务器端渲染框架（例如 Next.js 和 Nuxt.js）：<br>这些框架提供了整体的服务器端渲染解决方案，简化了配置和开发。它们提供了自动的路由处理、数据获取、渲染等功能。<br>实现原理：这些框架在服务器端根据请求路由，自动触发数据获取和渲染过程，生成最终的 HTML 页面，然后将 HTML 返回给客户端。<br>自定义 SSR：<br>你可以手动实现自己的服务器端渲染逻辑，根据项目需求进行定制化。<br>实现原理：在服务器端使用 Node.js 或其他后端技术，根据请求路由，手动触发数据获取和页面渲染，生成最终的 HTML 页面，然后将 HTML 返回给客户端。<br>服务器缓存（Server-side caching）：<br>一些服务器（如Nginx、Varnish）可以配置缓存策略，将已渲染的页面缓存起来，当下次有相同请求时，直接返回缓存的 HTML。<br>实现原理：服务器会根据请求的 URL 和参数，查找缓存中是否有对应的渲染好的 HTML，如果有则直接返回，避免再次渲染。<br>Web Workers：<br>Web Workers 是在浏览器中运行后台线程的机制，也可以用于 SSR。它们可以在后台线程中执行渲染，从而减少对主线程的阻塞。<br>实现原理：将渲染过程放入 Web Worker 中，在后台线程中执行渲染，然后将渲染结果返回给主线程，避免主线程被阻塞。<br>这些方法的选择取决于项目需求、开发团队的熟悉程度以及性能和复杂性的权衡。无论选择哪种方法，SSR 的核心原理是在服务器端生成并输出渲染好的 HTML 页面，以提高性能、搜索引擎可索引性和用户体验。</p><h5 id="4-浏览器性能优化方案"><a href="#4-浏览器性能优化方案" class="headerlink" title="4. 浏览器性能优化方案"></a>4. 浏览器性能优化方案</h5><p><strong>优化图片：</strong><br>使用适当的图片格式：选择合适的图片格式，如 JPEG、PNG、WebP，以减小文件大小。<br>图片压缩：使用工具压缩图片，减少文件大小，例如使用压缩工具、在线图片压缩网站等。<br>响应式图片：使用 srcset 属性为不同屏幕大小提供不同分辨率的图片，避免加载不必要的高分辨率图片。<br><strong>减少请求次数：</strong><br>合并文件：将多个 CSS、JavaScript 文件合并为一个，减少 HTTP 请求次数。<br>雪碧图（CSS Sprites）：将多个小图标合并到一张图片中，通过 CSS 背景定位显示不同图标。<br>使用字体图标：使用字体库（如 Font Awesome）代替图像图标，减少图像请求。<br><strong>使用缓存：</strong><br>浏览器缓存：使用适当的缓存策略，例如设置 Cache-Control 头，减少重复下载资源。<br>图片懒加载：延迟加载图片，只在用户滚动到可见区域时加载图片，减少初始页面加载时间。<br><strong>异步加载：</strong><br>异步加载脚本：使用 async 或 defer 属性加载 JavaScript，避免阻塞页面渲染。<br>延迟加载：将不必要的 JavaScript 延迟加载，例如放在页面底部或使用按需加载的技术（如动态导入）。<br><strong>DOM 操作优化：</strong><br>减少 DOM 操作：DOM 操作是昂贵的，尽量减少频繁的 DOM 操作。<br>批量 DOM 操作：将多个 DOM 操作合并成一个批量操作，减少重排和重绘。<br><strong>代码优化：</strong><br>减少重复代码：使用模块化和函数封装，避免重复编写相同的代码。<br>代码分割：将代码拆分成多个模块，按需加载，提高页面的加载速度。<br>JavaScript 性能优化：避免全局变量污染，减少不必要的计算，避免过多的递归等。<br><strong>减少重排和重绘：</strong><br>使用 CSS3 动画：使用 CSS3 过渡和动画代替 JavaScript 动画，减少重排和重绘。<br>利用 GPU 加速：使用 CSS3 属性（如 transform 和 opacity）来触发 GPU 加速，提高动画性能。<br><strong>服务端优化：</strong><br>使用服务器端缓存：利用服务器缓存，减少动态内容的生成频率。<br>使用 CDN：使用内容分发网络（CDN）分发静态资源，加快资源加载速度。</p><h5 id="5-JS的事件循环机制"><a href="#5-JS的事件循环机制" class="headerlink" title="5.JS的事件循环机制"></a>5.JS的事件循环机制</h5><p>浏览器中的事件循环（Event Loop）是一种机制，用于管理 JavaScript 代码的执行顺序、异步操作和事件处理。它确保代码按照正确的顺序执行，同时允许处理异步任务，例如定时器、网络请求和事件处理。<br>以下是浏览器的事件循环机制的简要说明：<br>调用栈（Call Stack）： 代码执行时，会将函数调用堆叠在调用栈中，每个函数的执行都会创建一个执行上下文。当函数执行完毕，它会从调用栈中弹出。<br>消息队列（Message Queue）： 在执行过程中，如果遇到异步操作（如定时器、网络请求、事件处理），这些操作会被放入消息队列中等待处理。<br>事件循环（Event Loop）： 当调用栈为空时，事件循环会将消息队列中的任务一个一个地取出，推入调用栈，执行对应的代码。这个过程持续进行，形成循环。<br>微任务和宏任务： 事件循环中的任务分为微任务（microtask）和宏任务（macrotask）两种。微任务优先级较高，会在当前任务执行完毕后立即执行，而宏任务则会在下一个事件循环开始前执行。<br>微任务包括 Promise 的 then 回调、MutationObserver 和 process.nextTick 等。<br>宏任务包括定时器回调、DOM 事件回调和网络请求等。<br>事件循环的执行过程可以简化为以下步骤：<br>执行当前调用栈中的任务（同步任务）。<br>查看是否有微任务队列，如果有，则依次执行微任务。<br>查看是否有宏任务队列，如果有，则取出一个宏任务，执行其回调。<br>返回第 1 步，重复执行。</p><h5 id="6-常见的HTTP状态码"><a href="#6-常见的HTTP状态码" class="headerlink" title="6. 常见的HTTP状态码"></a>6. 常见的HTTP状态码</h5><p>1xx - Informational（信息性状态码）:</p><p>100 Continue：请求已被接受，客户端应继续发送请求的其余部分。<br>101 Switching Protocols：服务器要求客户端切换协议（如从 HTTP 切换到 WebSocket）。<br>2xx - Successful（成功状态码）:</p><p>200 OK：请求已成功处理，并返回响应。<br>201 Created：请求已成功处理，服务器创建了新资源。<br>204 No Content：服务器成功处理了请求，但没有返回任何内容。<br>3xx - Redirection（重定向状态码）:</p><p>301 Moved Permanently：请求的资源已永久移动到新位置。<br>302 Found：请求的资源临时从不同的 URI 返回。<br>304 Not Modified：资源未被修改，客户端应使用缓存版本。<br>4xx - Client Error（客户端错误状态码）:</p><p>400 Bad Request：请求无效或无法被服务器理解。<br>401 Unauthorized：请求未经授权。<br>403 Forbidden：服务器拒绝请求。<br>404 Not Found：请求的资源未找到。<br>429 Too Many Requests：客户端发送的请求过多，服务器限制了请求频率。<br>5xx - Server Error（服务器错误状态码）:</p><p>500 Internal Server Error：服务器内部错误。<br>502 Bad Gateway：服务器作为网关或代理，从上游服务器收到无效响应。<br>503 Service Unavailable：服务器暂时无法处理请求，通常是由于过载或维护。<br>504 Gateway Timeout：服务器作为网关或代理，未及时从上游服务器收到响应。</p><h5 id="7-服务端渲染页面和客户端渲染页面有哪些区别"><a href="#7-服务端渲染页面和客户端渲染页面有哪些区别" class="headerlink" title="7.服务端渲染页面和客户端渲染页面有哪些区别"></a>7.服务端渲染页面和客户端渲染页面有哪些区别</h5><p><strong>服务端渲染（SSR）</strong>：<br>首屏渲染快： 在服务器端进行页面的渲染，浏览器收到的是已经渲染好的 HTML，首屏加载速度通常更快。<br>SEO 友好： 由于搜索引擎可以直接抓取渲染后的 HTML 内容，SSR 对搜索引擎优化（SEO）更友好。<br>对搜索引擎的支持更好： 因为服务器返回的是已渲染好的 HTML，不需要等待 JavaScript 执行完成，所以对于搜索引擎的支持更好。<br>首次加载耗时相对较长： 在首次加载时，服务器需要进行渲染，所以首次加载可能耗时较长。<br>服务器压力增加： 由于每次请求都需要服务器进行渲染，所以会增加服务器的压力。<br><strong>客户端渲染（CSR）：</strong><br>首次加载速度较慢： 浏览器首先加载一个基本的 HTML 骨架，然后通过 JavaScript 动态渲染页面内容，导致首次加载速度相对较慢。<br>用户体验更好： 一旦页面加载完成，后续的路由切换和页面更新会更加快速，因为只需要请求数据并更新部分内容，不需要重新加载整个页面。<br>减轻服务器负担： 服务器只返回数据，不需要进行页面渲染，减轻了服务器的负担。<br>对用户和搜索引擎体验不佳： 首次加载速度慢，对用户体验不佳。同时，搜索引擎爬虫在抓取时可能无法获取到动态渲染的内容，对 SEO 不友好。</p><h5 id="8-用async-await实现1秒后打印"><a href="#8-用async-await实现1秒后打印" class="headerlink" title="8.用async/await实现1秒后打印"></a>8.用async/await实现1秒后打印</h5><pre class=" language-typescript"><code class="language-typescript">async <span class="token keyword">function</span> <span class="token function">delayAndPrint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  await <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1秒后打印的内容'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">delayAndPrint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="9-判断是否是’回文’字符串"><a href="#9-判断是否是’回文’字符串" class="headerlink" title="9. 判断是否是’回文’字符串"></a>9. 判断是否是’回文’字符串</h5><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 去除非字母和数字的字符，并转换为小写</span>  <span class="token keyword">const</span> cleanStr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/[^a-zA-Z0-9]/g</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 反转字符串并与原字符串比较</span>  <span class="token keyword">const</span> reversedStr <span class="token operator">=</span> cleanStr<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 判断是否相同</span>  <span class="token keyword">return</span> cleanStr <span class="token operator">===</span> reversedStr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 测试</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token string">"racecar"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token string">"A man, a plan, a canal, Panama"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span></code></pre><h5 id="10-httponly是跨站脚本攻击吗？"><a href="#10-httponly是跨站脚本攻击吗？" class="headerlink" title="10.httponly是跨站脚本攻击吗？"></a>10.httponly是跨站脚本攻击吗？</h5><p>HttpOnly 是一个用于设置 Cookie 的属性，目的是增加对跨站脚本攻击（Cross-Site Scripting，XSS）的防护。虽然 HttpOnly 本身不是跨站脚本攻击，但它有助于减轻或防止某些类型的跨站脚本攻击。<br>HttpOnly 属性的作用是限制浏览器中的 JavaScript 访问某个 Cookie。如果将 Cookie 标记为 HttpOnly，则 JavaScript 无法通过 document.cookie 等方式访问这个 Cookie，只能在 HTTP 请求中发送给服务器。这有助于减轻跨站脚本攻击的影响，因为攻击者无法轻易获取用户的敏感信息。<br>总之，HttpOnly 是一项安全策略，用于减少跨站脚本攻击的风险，但并不是单独的跨站脚本攻击。它与其他安全措施一起可以帮助保护应用程序免受跨站脚本攻击的影响。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JS基础知识篇二&quot;&gt;&lt;a href=&quot;#JS基础知识篇二&quot; class=&quot;headerlink&quot; title=&quot;JS基础知识篇二&quot;&gt;&lt;/a&gt;JS基础知识篇二&lt;/h2&gt;&lt;h5 id=&quot;1-解释一下浏览器多线程以及如何实现？&quot;&gt;&lt;a href=&quot;#1-解释一下浏览器多</summary>
      
    
    
    
    <category term="Typescript" scheme="https://github.com/categories/Typescript/"/>
    
    
    <category term="Typescript" scheme="https://github.com/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>JS基础知识篇一</title>
    <link href="https://github.com/2023/08/12/JS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%871/"/>
    <id>https://github.com/2023/08/12/JS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%871/</id>
    <published>2023-08-11T16:00:00.000Z</published>
    <updated>2023-08-14T00:55:49.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS基础知识篇一"><a href="#JS基础知识篇一" class="headerlink" title="JS基础知识篇一"></a>JS基础知识篇一</h2><h6 id="1-js数组常用方法-哪些会改变原数组-遍历方法有哪些方式可以停止遍历？"><a href="#1-js数组常用方法-哪些会改变原数组-遍历方法有哪些方式可以停止遍历？" class="headerlink" title="1. js数组常用方法 哪些会改变原数组 遍历方法有哪些方式可以停止遍历？"></a>1. js数组常用方法 哪些会改变原数组 遍历方法有哪些方式可以停止遍历？</h6><p>   首先说一下会改变原数组的方法有哪些：<br>   push() 和 unshift()：在数组末尾或开头添加元素。<br>pop() 和 shift()：从数组末尾或开头删除元素。<br>splice()：删除、替换或插入元素。<br>reverse()：反转数组的顺序。<br>sort()：对数组元素进行排序。<br>fill()：用指定值填充数组的元素。<br>copyWithin()：从数组内部复制元素到其他位置。<br>不会改变原数组的方法：<br>concat()：合并多个数组，返回一个新数组。<br>join()：将数组元素连接为字符串。<br>slice()：返回选定的数组部分。<br>filter()：返回符合条件的新数组。<br>map()：根据函数对数组每个元素进行操作，返回新数组。<br>reduce() 和 reduceRight()：从左/右累积数组元素。<br>every()：检查数组所有元素是否满足条件。<br>some()：检查数组是否有满足条件的元素。<br>find() 和 findIndex()：查找数组中符合条件的第一个元素及其索引。<br>includes()：检查数组是否包含某个元素。<br>indexOf() 和 lastIndexOf()：返回元素在数组中的索引。<br>toString() 和 toLocaleString()：将数组转换为字符串。<br>遍历途中中止遍历：<br>使用原生的for循环遍历+break；</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numbers<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Found 3 at index:"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 停止遍历</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在some中中止遍历：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>numbers<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">===</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Found 3 at index:"</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 停止遍历</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h6 id="2-sort函数怎么从大到小排序"><a href="#2-sort函数怎么从大到小排序" class="headerlink" title="2.sort函数怎么从大到小排序"></a>2.sort函数怎么从大到小排序</h6><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用比较函数将数组从大到小排序</span>numbers<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> b <span class="token operator">-</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出: [10, 8, 7, 5, 2]</span></code></pre><p>如果 b - a 的值为负数，意味着 b 应该排在 a 前面，所以 a 和 b 的位置会交换。<br>如果 b - a 的值为零，意味着 a 和 b 相等的顺序不需要改变。<br>如果 b - a 的值为正数，意味着 b 应该排在 a 后面，所以它们的位置保持不变。</p><h5 id="3-深拷贝和浅拷贝的方法有哪些"><a href="#3-深拷贝和浅拷贝的方法有哪些" class="headerlink" title="3.深拷贝和浅拷贝的方法有哪些"></a>3.深拷贝和浅拷贝的方法有哪些</h5><p>浅拷贝—————-<br>Object.assign()： Object.assign(target, …sources) 方法可以将一个或多个源对象的属性复制到目标对象中。这是浅拷贝，如果属性值是对象，则复制的是引用。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> source <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token punctuation">{</span> c<span class="token punctuation">:</span> <span class="token number">2</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> shallowCopy <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> source<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Spread Operator（扩展运算符）： 使用 … 扩展运算符也可以进行浅拷贝。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> source <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token punctuation">{</span> c<span class="token punctuation">:</span> <span class="token number">2</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> shallowCopy <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>source <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>深拷贝———————–<br>递归方法： 递归地遍历对象的所有属性，对每个属性进行复制</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">!==</span> <span class="token string">'object'</span> <span class="token operator">||</span> obj <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> obj<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">const</span> copy <span class="token operator">=</span> <span class="token keyword">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      copy<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> copy<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>JSON.stringify() 和 JSON.parse()： 利用 JSON 序列化和反序列化可以实现深拷贝，但要注意它会忽略函数、循环引用等特殊情况</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> source <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token punctuation">{</span> c<span class="token punctuation">:</span> <span class="token number">2</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> deepCopy <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="4-es6-的new关键字-new-构造函数的时候this的指向改变四次-分别指向什么？"><a href="#4-es6-的new关键字-new-构造函数的时候this的指向改变四次-分别指向什么？" class="headerlink" title="4.es6 的new关键字 new 构造函数的时候this的指向改变四次 分别指向什么？"></a>4.es6 的new关键字 new 构造函数的时候this的指向改变四次 分别指向什么？</h5><p>使用 new 关键字来创建对象实例时，this 的指向会经历四次变化。这四次变化可以用来解释构造函数内部的执行过程。下面是这四次变化的具体情况：<br>①创建一个新对象： 当你使用 new 关键字调用构造函数时，首先会创建一个新的空对象。<br>②将新对象的原型链链接到构造函数的原型对象： 新对象会继承构造函数的原型对象上的属性和方法。<br>③将构造函数的作用域赋给新对象的 this： 此时，构造函数内部的代码会在新对象的上下文中执行，构造函数中的 this 指向新创建的对象。<br>④返回新对象： 如果构造函数没有显式返回其他对象，则返回新创建的对象</p><h5 id="5-数字千分位展示"><a href="#5-数字千分位展示" class="headerlink" title="5. 数字千分位展示"></a>5. 数字千分位展示</h5><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> <span class="token keyword">number</span> <span class="token operator">=</span> <span class="token number">1234567.89</span><span class="token punctuation">;</span><span class="token keyword">const</span> formattedNumber <span class="token operator">=</span> <span class="token keyword">number</span><span class="token punctuation">.</span><span class="token function">toLocaleString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>formattedNumber<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出: "1,234,567.89"</span></code></pre><h5 id="6-ES6模块化原理"><a href="#6-ES6模块化原理" class="headerlink" title="6.ES6模块化原理"></a>6.ES6模块化原理</h5><p>ES6 模块化基于两个主要概念：导入（import）和导出（export）。<br>导出（export）： 在一个模块中，使用 export 关键字将变量、函数、类等导出，使它们能够在其他模块中使用。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// example.js</span><span class="token keyword">export</span> <span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">"John"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Hello!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>导入（import）： 在另一个模块中，你可以使用 import 关键字来引入其他模块导出的内容。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// app.js</span><span class="token keyword">import</span> <span class="token punctuation">{</span> name<span class="token punctuation">,</span> sayHello <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./example.js'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出: "John"</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出: "Hello!"</span></code></pre><p>模块之间的连接： 当一个模块导入另一个模块时，JavaScript 引擎会自动执行被导入模块的代码，并且返回被导出的内容，使其在导入模块中可用。<br>静态解析： ES6 模块化是静态解析的，这意味着模块的依赖关系在代码被执行之前就可以确定。这有助于提高性能和可维护性。<br>单一实例： 每个模块在应用中只会被加载和执行一次，无论在多少地方导入它。这确保了模块的单一实例性质。<br>默认导出和导入： 除了命名导出，ES6 还支持默认导出和导入。默认导出可以是任何值，而不仅限于变量或函数。</p><h5 id="7-commonJS和ES模块化区别"><a href="#7-commonJS和ES模块化区别" class="headerlink" title="7. commonJS和ES模块化区别"></a>7. commonJS和ES模块化区别</h5><p>CommonJS 模块化：<br>用法： CommonJS 最初是为服务器端开发而设计的，主要在 Node.js 中使用。在 CommonJS 中，模块的加载是同步的，模块被执行后，它的输出会被缓存，后续引用直接使用缓存的值。<br>导入和导出： 使用 require 来导入模块，使用 module.exports 导出模块。<br>动态加载： CommonJS 允许在运行时动态加载模块，这使得模块的加载可以根据条件进行。<br>运行时执行： 模块的代码在导入时会被执行，因此适用于同步加载和运行的场景。<br>ES6 模块化：<br>用法： ES6 模块化是 JavaScript 标准库的一部分，可以在现代浏览器中使用，也可以在 Node.js 中使用。在 ES6 模块化中，模块的加载是异步的，加载后会生成一个只读引用。<br>导入和导出： 使用 import 来导入模块，使用 export 导出模块。<br>静态加载： ES6 模块化在编译阶段就确定了模块的依赖关系，使得代码更容易静态分析和优化。<br>编译时执行： 模块的代码在导入时不会立即执行，而是在被需要时按需执行，适用于异步加载的场景。<br>默认导出和导入： ES6 模块化支持默认导出和导入，使得在导入时可以更加灵活。</p><p>对于上面两者的执行时机，再做一下解释：<br>在 CommonJS 中，模块的代码在导入时立即执行，输出被缓存，后续导入直接使用缓存。<br>在 ES6 模块化中，模块的代码在导入时不会立即执行，只有在实际使用时才会被执行，导入的代码会被标记以便于后续执行。</p><h5 id="8-async和await区别"><a href="#8-async和await区别" class="headerlink" title="8. async和await区别"></a>8. async和await区别</h5><p>async 和 await 是 JavaScript 中用于处理异步操作的关键字，它们一起工作，使异步代码的编写和理解更加简洁和直观。下面是它们的主要区别：<br>async：<br>async 关键字用于声明一个函数是异步的，即使函数内部有同步的代码，也会被视为异步函数。<br>异步函数会隐式地返回一个 Promise 对象，这个 Promise 对象的状态和值会根据函数内部的执行结果进行设置。</p><pre class=" language-typescript"><code class="language-typescript">async <span class="token keyword">function</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token string">'Data fetched'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个 Promise，状态为已解决，并携带值 'Data fetched'</span><span class="token punctuation">}</span></code></pre><p>await：<br>await 关键字用于等待一个 Promise 对象的解决状态，只能在异步函数内部使用。<br>当遇到 await 时，函数会暂停执行，直到 Promise 对象的状态变为已解决，并返回解决的值。</p><pre class=" language-typescript"><code class="language-typescript">async <span class="token keyword">function</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> data <span class="token operator">=</span> await <span class="token function">fetchDataFromServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 等待 fetchDataFromServer() 的 Promise 解决</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>总结：<br>async 关键字用于声明异步函数，返回一个 Promise。<br>await 关键字用于等待 Promise 的解决状态，只能在异步函数内部使用，使代码执行等待异步操作完成。<br>需要注意的是，在使用 await 时，必须将它放在异步函数内部，以便正确地等待和处理异步操作。</p><h5 id="9-如果在const之前使用了变量会出现什么？"><a href="#9-如果在const之前使用了变量会出现什么？" class="headerlink" title="9.如果在const之前使用了变量会出现什么？"></a>9.如果在const之前使用了变量会出现什么？</h5><p>看下面的代码：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">const</span> y <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p>上面的代码正常输出15，不会报错！！<br>解释：const 关键字声明的常量确实需要在声明时进行赋值，但在 const 声明之前使用变量进行赋值或操作是没有问题的，不会导致语法错误。</p><h5 id="10-async和defer在js加载的时候区别"><a href="#10-async和defer在js加载的时候区别" class="headerlink" title="10. async和defer在js加载的时候区别"></a>10. async和defer在js加载的时候区别</h5><p>async 和 defer 是用于控制外部 JavaScript 文件加载和执行时机的两个属性。它们可以在 <script> 标签中使用，影响脚本的加载和执行顺序。以下是它们的区别：<br>async 属性：<br>当使用 async 属性时，浏览器会异步加载脚本，不会阻塞 HTML 解析。<br>脚本加载完成后，会立即开始执行。执行时机可能在其他资源（如 CSS 和图片）加载之前，也可能在其他资源加载之后，取决于加载完成的时间。<br>适用于不依赖其他脚本和 DOM 的脚本，例如一些统计代码或独立的插件。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"script.js"</span> async<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p>defer 属性：<br>当使用 defer 属性时，浏览器会异步加载脚本，但会等待 HTML 解析完成后再执行脚本。<br>脚本的执行时机是在 DOMContentLoaded 事件之前，保证脚本能够访问和操作 DOM。<br>适用于需要等待整个文档解析完毕才执行的脚本，可以操作 DOM。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"script.js"</span> defer<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p>总结：<br>async 属性用于异步加载并立即执行脚本，执行时机不确定。<br>defer 属性用于异步加载脚本，并在整个文档解析完成后执行，执行时机在 DOMContentLoaded 事件之前。</p></script></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JS基础知识篇一&quot;&gt;&lt;a href=&quot;#JS基础知识篇一&quot; class=&quot;headerlink&quot; title=&quot;JS基础知识篇一&quot;&gt;&lt;/a&gt;JS基础知识篇一&lt;/h2&gt;&lt;h6 id=&quot;1-js数组常用方法-哪些会改变原数组-遍历方法有哪些方式可以停止遍历？&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="Typescript" scheme="https://github.com/categories/Typescript/"/>
    
    
    <category term="Typescript" scheme="https://github.com/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>JS箭头函数和普通函数的区别</title>
    <link href="https://github.com/2023/08/11/JS%E7%9A%84%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://github.com/2023/08/11/JS%E7%9A%84%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2023-08-10T16:00:00.000Z</published>
    <updated>2023-08-11T01:58:32.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS箭头函数和普通函数的区别"><a href="#JS箭头函数和普通函数的区别" class="headerlink" title="JS箭头函数和普通函数的区别"></a>JS箭头函数和普通函数的区别</h2><p>首先看一下两种函数的书写形式：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token function">箭头函数：</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span>普通函数<span class="token punctuation">:</span><span class="token keyword">function</span> <span class="token function">xxx</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> </code></pre><p>从书写形式上来看，箭头函数语法是比较简洁的，下面展开论述一下它俩的区别：</p><ol><li>箭头函数不会创建自己的this，它没有自己的this，它只会从自己的作用域链的上一层继承this。并且是定义时的this，而不是调用时，也就是说箭头函数的this是定义时已经确定好了的，；而普通函数的this是在调用时动态绑定的。</li><li>箭头函数继承来的this指向永远不会变！！！它的指向永远是它定义的时所处的全局执行环境中的this，跟之后谁调用的无关，而且无法通过call/bind/apply来更改它的this指向（本来就没有自己的this）</li><li>箭头函数不能作为构造函数使用，下面先了解一下构造函数的new关键字都做了什么：<br>它会执行以下一系列步骤：<br>①创建一个新的空对象：<br>new 关键字会创建一个新的空对象，这个对象会成为最终的实例。<br>②将新对象的原型链接到构造函数的原型对象：<br>新创建的对象会通过原型链与构造函数的原型对象链接起来，这样新对象就可以继承构造函数原型上的方法和属性。<br>③将构造函数的 this 绑定到新对象：<br>构造函数内部的 this 会被绑定到新创建的对象，这样构造函数内部的操作就可以作用在新对象上。<br>④执行构造函数的代码块：<br>构造函数内部的代码会被执行，可以在其中设置新对象的属性和方法。<br>⑤返回新对象：<br>如果构造函数没有显式返回其他对象，则默认返回新创建的对象实例。如果构造函数显式返回了一个对象，那么最终返回的就是这个对象。<br>通过上述了解，可以知道箭头函数没有自己的this，所以无法完成上述步骤，因此不能作为构造函数。</li><li>箭头函数没有自己的arguments对象，而是继承了外围（包含箭头函数的函数）函数的 arguments 对象</li></ol><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">regularFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出调用 regularFunction 时的参数列表</span>  <span class="token punctuation">}</span>  <span class="token keyword">const</span> arrowFunction <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 此处会产生错误，因为箭头函数没有自己的 arguments 对象</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token function">regularFunction</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">arrowFunction</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 报错：Uncaught ReferenceError: arguments is not defined</span></code></pre><p><img src="/img/arrow1.png" class="lazyload placeholder" data-srcset="/img/arrow1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"></p><ol start="5"><li>箭头函数没有原型prototype，打印会是undefined<br><img src="/img/arrow.png" class="lazyload placeholder" data-srcset="/img/arrow.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="箭头函数无自己的原型"></li><li>箭头函数不能用作Generator函数，不能使用yeild关键字</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JS箭头函数和普通函数的区别&quot;&gt;&lt;a href=&quot;#JS箭头函数和普通函数的区别&quot; class=&quot;headerlink&quot; title=&quot;JS箭头函数和普通函数的区别&quot;&gt;&lt;/a&gt;JS箭头函数和普通函数的区别&lt;/h2&gt;&lt;p&gt;首先看一下两种函数的书写形式：&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Typescript" scheme="https://github.com/categories/Typescript/"/>
    
    
    <category term="Typescript" scheme="https://github.com/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>两种经典的CSS布局--双飞翼布局和圣杯布局</title>
    <link href="https://github.com/2023/07/26/%E4%B8%A4%E7%A7%8D%E7%BB%8F%E5%85%B8%E7%9A%84CSS%E5%B8%83%E5%B1%80--%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80%E5%92%8C%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80/"/>
    <id>https://github.com/2023/07/26/%E4%B8%A4%E7%A7%8D%E7%BB%8F%E5%85%B8%E7%9A%84CSS%E5%B8%83%E5%B1%80--%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80%E5%92%8C%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80/</id>
    <published>2023-07-25T16:00:00.000Z</published>
    <updated>2023-07-27T01:47:51.555Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS布局"><a href="#CSS布局" class="headerlink" title="CSS布局"></a>CSS布局</h2><h4 id="两种布局的历史由来"><a href="#两种布局的历史由来" class="headerlink" title="两种布局的历史由来"></a>两种布局的历史由来</h4><p>圣杯布局来源于文章<a href="https://alistapart.com/article/holygrail/">In Search of the Holy Grail</a>，而双飞翼布局来源于淘宝UED。虽然两者的实现方法略有差异，不过都遵循了以下要点：</p><ul><li>两侧宽度固定，中间宽度自适应</li><li>中间部分在DOM结构上优先，以便先行渲染</li><li>允许三列中的任意一列成为最高列</li><li>只需要使用一个额外的&lt; div&gt;标签<h4 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h4></li></ul><blockquote><p>原理：双飞翼布局是一种常用的三栏布局，它使用CSS浮动和负外边距来实现。该布局的特点是，主要内容在HTML结构中位于最前面，侧边栏在主要内容的左右两侧，且主要内容部分可以自适应宽度，侧边栏固定宽度。</p></blockquote><p>代码结构如下:</p><pre class=" language-typescript"><code class="language-typescript"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html lang<span class="token operator">=</span><span class="token string">"en"</span><span class="token operator">></span><span class="token operator">&lt;</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>meta name<span class="token operator">=</span><span class="token string">"viewport"</span> content<span class="token operator">=</span><span class="token string">"width=device-width, initial-scale=1.0"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>title<span class="token operator">></span>双飞翼布局<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>    <span class="token operator">&lt;</span>style<span class="token operator">></span>        <span class="token operator">*</span><span class="token punctuation">{</span>            padding<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>            margin<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        header<span class="token punctuation">{</span>            height<span class="token punctuation">:</span> 60px<span class="token punctuation">;</span>            background<span class="token operator">-</span>color<span class="token punctuation">:</span> plum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span>main<span class="token punctuation">{</span>            width<span class="token punctuation">:</span> <span class="token number">100</span><span class="token operator">%</span><span class="token punctuation">;</span>            background<span class="token operator">-</span>color<span class="token punctuation">:</span> paleturquoise<span class="token punctuation">;</span>            height<span class="token punctuation">:</span> <span class="token function">calc</span><span class="token punctuation">(</span>100vh <span class="token operator">-</span> 120px<span class="token punctuation">)</span><span class="token punctuation">;</span>            float<span class="token punctuation">:</span> left<span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">.</span>center<span class="token punctuation">{</span>            margin<span class="token punctuation">:</span> <span class="token number">0</span> 200px<span class="token punctuation">;</span>            background<span class="token operator">-</span>color<span class="token punctuation">:</span> paleturquoise<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span>left<span class="token punctuation">{</span>            float<span class="token punctuation">:</span> left<span class="token punctuation">;</span>            width<span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            margin<span class="token operator">-</span>left<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">100</span><span class="token operator">%</span><span class="token punctuation">;</span>            height<span class="token punctuation">:</span> <span class="token function">calc</span><span class="token punctuation">(</span>100vh <span class="token operator">-</span> 120px<span class="token punctuation">)</span><span class="token punctuation">;</span>            background<span class="token operator">-</span>color<span class="token punctuation">:</span> palevioletred<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span>right<span class="token punctuation">{</span>            float<span class="token punctuation">:</span> left<span class="token punctuation">;</span>            width<span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            margin<span class="token operator">-</span>left<span class="token punctuation">:</span> <span class="token operator">-</span>200px<span class="token punctuation">;</span>            height<span class="token punctuation">:</span> <span class="token function">calc</span><span class="token punctuation">(</span>100vh <span class="token operator">-</span> 120px<span class="token punctuation">)</span><span class="token punctuation">;</span>            background<span class="token operator">-</span>color<span class="token punctuation">:</span> purple<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        footer<span class="token punctuation">{</span>            height<span class="token punctuation">:</span> 60px<span class="token punctuation">;</span>            clear<span class="token punctuation">:</span> both<span class="token punctuation">;</span>            background<span class="token operator">-</span>color<span class="token punctuation">:</span> palegreen<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>style<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 双飞翼布局的实现 <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>header<span class="token operator">></span>头部<span class="token operator">&lt;</span><span class="token operator">/</span>header<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 中间区域先加载所以写在上面 <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"main"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"center"</span><span class="token operator">></span>主区域<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"left"</span><span class="token operator">></span>左边栏<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"right"</span><span class="token operator">></span>右边栏<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span>footer<span class="token operator">></span>底部<span class="token operator">&lt;</span><span class="token operator">/</span>footer<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span></code></pre><p>运行效果：<br><img src="/img/beizi2.png" class="lazyload placeholder" data-srcset="/img/beizi2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="双飞翼布局"></p><h4 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h4><p>代码结构如下：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html lang<span class="token operator">=</span><span class="token string">"en"</span><span class="token operator">></span><span class="token operator">&lt;</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>meta name<span class="token operator">=</span><span class="token string">"viewport"</span> content<span class="token operator">=</span><span class="token string">"width=device-width, initial-scale=1.0"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>title<span class="token operator">></span>圣杯布局<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>    <span class="token operator">&lt;</span>style<span class="token operator">></span>        <span class="token operator">*</span><span class="token punctuation">{</span>            margin<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>            padding<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span>clearfix<span class="token punctuation">{</span>            height<span class="token punctuation">:</span> <span class="token function">calc</span><span class="token punctuation">(</span>100vh <span class="token operator">-</span> 120px<span class="token punctuation">)</span><span class="token punctuation">;</span>            padding<span class="token punctuation">:</span> <span class="token number">0</span> 200px<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span>clearfix<span class="token punctuation">:</span><span class="token punctuation">:</span>after<span class="token punctuation">{</span>            content<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">;</span>            display<span class="token punctuation">:</span> block<span class="token punctuation">;</span>            clear<span class="token punctuation">:</span> both<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span>to<span class="token operator">-</span>float<span class="token punctuation">{</span>            float<span class="token punctuation">:</span> left<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        header<span class="token punctuation">{</span>            width<span class="token punctuation">:</span> <span class="token number">100</span><span class="token operator">%</span><span class="token punctuation">;</span>            height<span class="token punctuation">:</span> 60px<span class="token punctuation">;</span>            background<span class="token operator">-</span>color<span class="token punctuation">:</span> palegoldenrod<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        footer<span class="token punctuation">{</span>            width<span class="token punctuation">:</span> <span class="token number">100</span><span class="token operator">%</span><span class="token punctuation">;</span>            height<span class="token punctuation">:</span> 60px<span class="token punctuation">;</span>            background<span class="token operator">-</span>color<span class="token punctuation">:</span> palegreen<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span>center<span class="token punctuation">{</span>            width<span class="token punctuation">:</span> <span class="token number">100</span><span class="token operator">%</span><span class="token punctuation">;</span>            height<span class="token punctuation">:</span> <span class="token number">100</span><span class="token operator">%</span><span class="token punctuation">;</span>            background<span class="token operator">-</span>color<span class="token punctuation">:</span> papayawhip<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span>left<span class="token punctuation">{</span>            width<span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            height<span class="token punctuation">:</span> <span class="token number">100</span><span class="token operator">%</span><span class="token punctuation">;</span>            margin<span class="token operator">-</span>left<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">100</span><span class="token operator">%</span><span class="token punctuation">;</span>            position<span class="token punctuation">:</span> relative<span class="token punctuation">;</span>             left<span class="token punctuation">:</span> <span class="token operator">-</span>200px<span class="token punctuation">;</span>            background<span class="token operator">-</span>color<span class="token punctuation">:</span> palevioletred<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span>right<span class="token punctuation">{</span>            width<span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            height<span class="token punctuation">:</span> <span class="token number">100</span><span class="token operator">%</span><span class="token punctuation">;</span>            margin<span class="token operator">-</span>right<span class="token punctuation">:</span> <span class="token operator">-</span>200px<span class="token punctuation">;</span>            background<span class="token operator">-</span>color<span class="token punctuation">:</span> paleturquoise<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>style<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span>    <span class="token operator">&lt;</span>header<span class="token operator">></span>头部<span class="token operator">&lt;</span><span class="token operator">/</span>header<span class="token operator">></span>    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"clearfix"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"center to-float"</span><span class="token operator">></span>中间区域<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>        <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"left to-float"</span><span class="token operator">></span>左边栏<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>        <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"right to-float"</span><span class="token operator">></span>右边栏<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span>footer<span class="token operator">></span>底部<span class="token operator">&lt;</span><span class="token operator">/</span>footer<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span></code></pre><p>运行效果：<br><img src="/img/beizi1.png" class="lazyload placeholder" data-srcset="/img/beizi1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="圣杯布局"><br>参考文章：<a href="https://zhuanlan.zhihu.com/p/98518460">CSS 圣杯布局和双飞翼布局的理解与思考</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CSS布局&quot;&gt;&lt;a href=&quot;#CSS布局&quot; class=&quot;headerlink&quot; title=&quot;CSS布局&quot;&gt;&lt;/a&gt;CSS布局&lt;/h2&gt;&lt;h4 id=&quot;两种布局的历史由来&quot;&gt;&lt;a href=&quot;#两种布局的历史由来&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="HTML&amp;CSS" scheme="https://github.com/categories/HTML-CSS/"/>
    
    
    <category term="HTML&amp;CSS" scheme="https://github.com/tags/HTML-CSS/"/>
    
  </entry>
  
  <entry>
    <title>ES5如何实现继承</title>
    <link href="https://github.com/2023/07/25/ES5%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/"/>
    <id>https://github.com/2023/07/25/ES5%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/</id>
    <published>2023-07-24T16:00:00.000Z</published>
    <updated>2023-07-25T09:10:33.066Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ES5如何实现继承"><a href="#ES5如何实现继承" class="headerlink" title="ES5如何实现继承"></a>ES5如何实现继承</h2><blockquote><p>共有四种方式实现原型继承–原型链继承、构造函数继承、组合式继承、寄生式继承，下面我一一介绍，分别就实现以及特性分别展开来描述</p></blockquote><h3 id="原型链继承方式"><a href="#原型链继承方式" class="headerlink" title="原型链继承方式"></a>原型链继承方式</h3><blockquote><p>原理：将子类的原型对象指向一个父类的实例。通过这样的赋值，子类继承了父类的所有属性和方法，因为它的原型对象指向了一个父类实例，所以可以通过原型链访问到父类原型上的所有属性和方法。</p></blockquote><p>看下面的示例代码：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//父类</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'kitty'</span>  <span class="token comment" spellcheck="true">//基本数据类型</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>hobby <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'eat'</span><span class="token punctuation">,</span><span class="token string">'drink'</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">//引用数据类型</span><span class="token punctuation">}</span>Animal<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">}</span>Animal<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getHobby <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>hobby<span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//子类</span>Cat<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  Cat<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token keyword">constructor</span> <span class="token operator">=</span> Cat  <span class="token keyword">const</span> m1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> m2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>m1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'m1'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m1<span class="token punctuation">.</span>hobby<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'sleep'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m1<span class="token punctuation">.</span><span class="token function">getHobby</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m2<span class="token punctuation">.</span><span class="token function">getHobby</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>下面是运行结果：<br><img src="/img/extend1.png" class="lazyload placeholder" data-srcset="/img/extend1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="原型链继承运行结果"></p><h5 id="原因探究："><a href="#原因探究：" class="headerlink" title="原因探究："></a>原因探究：</h5><p>对于上面这个例子，我们分别对父类的两个不同的类型的属性进行修改，其中，一个是基本数据类型，另一个是引用数据类型，根据就运行结果可以发现，我们创建了两个cat子类，均通过原型链的继承方式，对Animal实现了继承，然后通过m1对引用数据类型hobby做出修改，之后再分别调用m1和m2的getHobby方法获取各自的hobby属性，发现m2的hobby属性也被修改了，这就暴露了原型链继承方式的缺点之一—-共享属性和方法，因为你的将子类（cat）的原型对象指向了父类（Animal）的同一个实例对象，也就是说你创建的所有cat对象的原型都是指向的同一个父类的实例对象，这意味着如果一个实例修改了原型上的属性，其他实例也会受到影响。<br>但再瞅一眼，为什么name没有发生这种问题呢？这是因为name是基本数据类型，如果属性是基本数据类型而不是引用类型，原型链继承就不存在共享属性问题，每个实例都会拥有独立的副本，也就是说m1.name = ‘m1’这句代码，会在当前m1的对象上新增一个name属性，然后赋值为’m1’,并不会影响到它原型上面的name属性，当打印m2.name的时候，因为m2本身没有name属性，那它就会去它的原型对象上去找这个属性，在这个例子中，也就是父类的name（’kitty’）。<br><img src="/img/extend2.png" class="lazyload placeholder" data-srcset="/img/extend2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="直接赋值，只是在当前对象本身上新增一个属性，并没影响到原型链上的属性"></p><h5 id="实现核心"><a href="#实现核心" class="headerlink" title="实现核心:"></a>实现核心:</h5><pre class=" language-typescript"><code class="language-typescript">Cat<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  Cat<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token keyword">constructor</span> <span class="token operator">=</span> Cat  </code></pre><p>Cat.prototype = new Animal():<br>这一行代码意味着将 Cat 的原型对象指向一个 Animal 的实例。通过这样的赋值，Cat 继承了 Animal 的所有属性和方法。<br>Cat.prototype.constructor = Cat:<br>这一行代码是为了修正因为前一步赋值导致的 constructor 属性被重写的问题。在第一步赋值后，Cat.prototype 的 constructor 属性会指向 Animal 的构造函数，即 Animal 函数。但实际上，我们希望 Cat.prototype.constructor 指向 Cat 构造函数本身，以保持对象的正确构造。<br>因此，通过显式赋值将 Cat.prototype.constructor 重新指向 Cat 构造函数，这样就纠正了原型链中的 constructor 属性。</p><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>1、共享属性和方法：<br>使用原型链继承时，子类的实例共享父类原型上的属性和方法。这意味着如果一个实例修改了原型上的属性，其他实例也会受到影响。这可能导致意外的副作用和不稳定的行为。<br>2、无法向父类构造函数传递参数：<br>在原型链继承中，子类通过继承父类的实例来实现继承，并没有直接调用父类构造函数。因此，无法直接向父类构造函数传递参数，导致在子类构造函数中无法完成父类构造函数的初始化操作。<br>3、无法实现多继承：<br>原型链继承只能继承一个父类的属性和方法，无法同时继承多个父类，这限制了它的灵活性。<br>4、子类无法重写父类的属性和方法，没有实现super方法：<br>如果子类的原型上定义了与父类相同名称的属性或方法，那么它会覆盖父类的属性和方法。这可能导致不可预期的行为，使代码难以维护和调试。</p><h3 id="构造函数继承方式"><a href="#构造函数继承方式" class="headerlink" title="构造函数继承方式"></a>构造函数继承方式</h3><blockquote><p>原理:在子类的构造函数中执行父类的构造函数，并为其绑定子类的this，避免了不同实例之间共享同一个原型实例，并且可以向父类的构造函数中传参,但是继承不到父类原型的属性和方法。</p></blockquote><p>看下面示例代码：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token comment" spellcheck="true">//基本数据类型</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>hobby <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'eat'</span><span class="token punctuation">,</span><span class="token string">'drink'</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">//引用数据类型</span><span class="token punctuation">}</span>Animal<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">}</span>Animal<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getHobby <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>hobby<span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 继承不到父类原型的属性和方法</span>    Animal<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>arguments<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">const</span> m1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">'m1'</span><span class="token punctuation">)</span><span class="token keyword">const</span> m2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">'m2'</span><span class="token punctuation">)</span>m1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'m1'</span><span class="token comment" spellcheck="true">// console.log(m1.getName());  //报错 Uncaught TypeError: m1.getName is not a function</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m1<span class="token punctuation">.</span>name<span class="token punctuation">,</span>m2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>m1<span class="token punctuation">.</span>hobby<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'sleep'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m1<span class="token punctuation">.</span>hobby<span class="token punctuation">,</span>m2<span class="token punctuation">.</span>hobby<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="/img/extend3.png" class="lazyload placeholder" data-srcset="/img/extend3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"></p><h6 id="原因探究：-1"><a href="#原因探究：-1" class="headerlink" title="原因探究："></a>原因探究：</h6><p>为什么调用不到父类原型上的方法呢？<br>原因是在使用构造函数继承时，子类实例只能继承父类构造函数内部设置的属性，而无法继承父类原型上的属性和方法。这是因为 Animal.apply(this, arguments) 调用的是父类构造函数，而不是父类原型上的方法。<br>实际上，使用构造函数继承时，创建的子类实例和父类实例是相互独立的，它们没有共享父类原型上的方法。这导致子类实例无法继承父类原型上的属性和方法。</p><h5 id="实现核心："><a href="#实现核心：" class="headerlink" title="实现核心："></a>实现核心：</h5><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 继承不到父类原型的属性和方法</span>    Animal<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>arguments<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>避免了不同实例之间共享同一个原型实例，实例对象之间修改属性值，不会相互影响。</p><h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><p>继承不到父类原型上的属性和方法。</p><h3 id="组合式继承方式"><a href="#组合式继承方式" class="headerlink" title="组合式继承方式"></a>组合式继承方式</h3><blockquote><p>原理：原型链继承方式+构造函数继承方式结合体</p></blockquote><p>看下面示例代码：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name  <span class="token comment" spellcheck="true">//基本数据类型</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>hobby <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'eat'</span><span class="token punctuation">,</span><span class="token string">'drink'</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">//引用数据类型</span><span class="token punctuation">}</span>Animal<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">}</span>Animal<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getHobby <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>hobby<span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Animal<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>arguments<span class="token punctuation">)</span><span class="token punctuation">}</span>Cat<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span>Cat<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token keyword">constructor</span> <span class="token operator">=</span> Cat<span class="token keyword">const</span> m1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">'m1'</span><span class="token punctuation">)</span><span class="token keyword">const</span> m2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">'m2'</span><span class="token punctuation">)</span>m1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'m1'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m1<span class="token punctuation">.</span>hobby<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'sleep'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m1<span class="token punctuation">.</span><span class="token function">getHobby</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m2<span class="token punctuation">.</span><span class="token function">getHobby</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="/img/extend4.png" class="lazyload placeholder" data-srcset="/img/extend4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"><br>打印其中一个子类实例对象看一下：<br><img src="/img/extend5.png" class="lazyload placeholder" data-srcset="/img/extend5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="子类实例对象的原型"></p><h5 id="原因探究：-2"><a href="#原因探究：-2" class="headerlink" title="原因探究："></a>原因探究：</h5><p>每次创建子类实例的时候，都执行了两次父类的构造函数（new Animal()与Animal.apply(this,arguments)），但是并不影响使用。</p><h5 id="实现核心：-1"><a href="#实现核心：-1" class="headerlink" title="实现核心："></a>实现核心：</h5><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Animal<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>arguments<span class="token punctuation">)</span><span class="token punctuation">}</span>Cat<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span>Cat<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token keyword">constructor</span> <span class="token operator">=</span> Cat</code></pre><h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><p>解决了原型链继承方式+构造函数继承方式出现的缺点</p><h5 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h5><p>重复执行了父类的构造函数，导致子类实例对象原型上的方法重复，不是特别的优雅。</p><h3 id="寄生式继承方式"><a href="#寄生式继承方式" class="headerlink" title="寄生式继承方式"></a>寄生式继承方式</h3><blockquote><p>原理：在组合式继承的基础上进行修改，将子类的原型对象指向父类的原型并不是父类实例的原型，从而减少一次父类构造函数的执行，子类实例并不直接继承父类原型上的方法。它只是创建了一个新对象，该对象的原型链中仅包含父类原型上的属性和方法。因此，它并不是传统意义上的原型链继承。</p></blockquote><p>看下面示例代码：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name  <span class="token comment" spellcheck="true">//基本数据类型</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>hobby <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'eat'</span><span class="token punctuation">,</span><span class="token string">'drink'</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">//引用数据类型</span><span class="token punctuation">}</span>Animal<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">}</span>Animal<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getHobby <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>hobby<span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Animal<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>arguments<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Object.create 创建的新对象是浅拷贝,也就是说它只复制对象的属性引用，而不会复制属性的值</span>Cat<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Animal<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>Cat<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token keyword">constructor</span> <span class="token operator">=</span> Cat<span class="token keyword">const</span> m1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">'m1'</span><span class="token punctuation">)</span><span class="token keyword">const</span> m2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">'m2'</span><span class="token punctuation">)</span>m1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'修改了m1'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m1<span class="token punctuation">.</span>hobby<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'sleep'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m1<span class="token punctuation">.</span><span class="token function">getHobby</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m2<span class="token punctuation">.</span><span class="token function">getHobby</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="/img/extend6.png" class="lazyload placeholder" data-srcset="/img/extend6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"></p><h5 id="实现核心：-2"><a href="#实现核心：-2" class="headerlink" title="实现核心："></a>实现核心：</h5><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Animal<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>arguments<span class="token punctuation">)</span><span class="token punctuation">}</span>Cat<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Animal<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>Cat<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token keyword">constructor</span> <span class="token operator">=</span> Cat</code></pre><h5 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h5><p>解决了父类构造函数被执行两次的问题，且该种方法是es5中最成熟的继承方式。</p><p>over———————————————————————————————————</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ES5如何实现继承&quot;&gt;&lt;a href=&quot;#ES5如何实现继承&quot; class=&quot;headerlink&quot; title=&quot;ES5如何实现继承&quot;&gt;&lt;/a&gt;ES5如何实现继承&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;共有四种方式实现原型继承–原型链继承、构造函数继承、组合式</summary>
      
    
    
    
    <category term="Typescript" scheme="https://github.com/categories/Typescript/"/>
    
    
    <category term="Typescript" scheme="https://github.com/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript严格模式以及this指向</title>
    <link href="https://github.com/2023/07/14/Javascript%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8Athis%E6%8C%87%E5%90%91/"/>
    <id>https://github.com/2023/07/14/Javascript%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8Athis%E6%8C%87%E5%90%91/</id>
    <published>2023-07-13T16:00:00.000Z</published>
    <updated>2023-07-13T16:37:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>看下面代码的输出</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token string">"use strict"</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span>info<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>info<span class="token punctuation">,</span><span class="token string">'开启严格模式'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>test<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token string">'使用call解决严格模式this指向报错问题'</span><span class="token punctuation">)</span><span class="token keyword">const</span> obj  <span class="token operator">=</span> <span class="token punctuation">{</span>    fn1 <span class="token punctuation">:</span> <span class="token punctuation">(</span>info<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>info<span class="token punctuation">)</span><span class="token punctuation">,</span>    fn2 <span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>info<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span>obj<span class="token punctuation">.</span><span class="token function">fn1</span><span class="token punctuation">(</span><span class="token string">'obj直接调用fn1'</span><span class="token punctuation">)</span>obj<span class="token punctuation">.</span><span class="token function">fn2</span><span class="token punctuation">(</span><span class="token string">'obj直接调用fn2'</span><span class="token punctuation">)</span><span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">obj<span class="token punctuation">.</span>fn2</span><span class="token punctuation">(</span><span class="token string">'使用new运算符，将fn2看为类'</span><span class="token punctuation">)</span><span class="token keyword">const</span> y <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">obj<span class="token punctuation">.</span>fn1</span><span class="token punctuation">(</span><span class="token string">'使用new运算符，将fn1看为类'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span></code></pre><p>在上面的代码中，obj对象包含两个方法fn1和fn2，fn1是一个箭头函数，而fn2使用普通函数的形式定义。</p><p>对于箭头函数，它没有自己的this值，它会捕获上下文中的this，因此fn1中的this指向的是全局对象window（当开启严格模式时，指向的是undefined）。<br>对于普通函数，它的this值是在运行时动态绑定的。因此，当我们调用obj.fn2()时，输出结果是obj，因为是obj调用的这个函数。</p><p>对于const x = new obj.fn2()，因为fn2是一个普通函数，new运算符可以正确的创建实例，并且this值指向新创建的实例对象（即是一个包含fn2方法的对象）；<br>对于const y = new obj.fn1()，因为fn1是一个箭头函数，它没有自己的构造函数，也没有自己的this值，素以在使用new运算符创建实例会报错。运行结果如下图所示：<br><img src="/img/strict.png" class="lazyload placeholder" data-srcset="/img/strict.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;看下面代码的输出&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot; language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token string&quot;&gt;&quot;u</summary>
      
    
    
    
    <category term="Typescript" scheme="https://github.com/categories/Typescript/"/>
    
    
    <category term="Typescript" scheme="https://github.com/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>手写Promise及其API</title>
    <link href="https://github.com/2023/07/01/%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0%EF%BC%9A%E6%89%8B%E5%86%99Promise%E5%8F%8A%E5%85%B6API/"/>
    <id>https://github.com/2023/07/01/%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0%EF%BC%9A%E6%89%8B%E5%86%99Promise%E5%8F%8A%E5%85%B6API/</id>
    <published>2023-06-30T16:00:00.000Z</published>
    <updated>2023-07-25T09:10:21.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="手写Promise及其API"><a href="#手写Promise及其API" class="headerlink" title="手写Promise及其API"></a>手写Promise及其API</h2><h3 id="Promise构造函数"><a href="#Promise构造函数" class="headerlink" title="Promise构造函数"></a>Promise构造函数</h3><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// promise的构造函数，同步执行</span><span class="token comment" spellcheck="true">// executor===(resolve,reject)=>{}</span><span class="token keyword">function</span> <span class="token function">Promise</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Promise的内置属性 PromiseState与PromiseResult的初始化</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>PromiseState <span class="token operator">=</span> <span class="token string">'pending'</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>PromiseResult <span class="token operator">=</span> <span class="token keyword">null</span>    <span class="token keyword">const</span> self <span class="token operator">=</span> <span class="token keyword">this</span>    <span class="token comment" spellcheck="true">// 缓存then的回调函数，用于异步执行</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>callback <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>PromiseState <span class="token operator">!==</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token keyword">return</span>        self<span class="token punctuation">.</span>PromiseState <span class="token operator">=</span> <span class="token string">'fulfilled'</span>        self<span class="token punctuation">.</span>PromiseResult <span class="token operator">=</span> data        <span class="token comment" spellcheck="true">// 因为then的执行是异步的</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        self<span class="token punctuation">.</span>callback<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            item<span class="token punctuation">.</span><span class="token function">resolved</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>     <span class="token punctuation">}</span>    <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>PromiseState <span class="token operator">!==</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token keyword">return</span>        self<span class="token punctuation">.</span>PromiseState <span class="token operator">=</span> <span class="token string">'rejected'</span>        self<span class="token punctuation">.</span>PromiseResult <span class="token operator">=</span> data        <span class="token comment" spellcheck="true">// 因为then的执行是异步的</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            self<span class="token punctuation">.</span>callback<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                item<span class="token punctuation">.</span><span class="token function">rejected</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 立即执行传入Promise里的执行器函数</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token function">executor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="实例方法then"><a href="#实例方法then" class="headerlink" title="实例方法then"></a>实例方法then</h3><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">//实例方法 接收两个回调函数，成功的回调和失败的回调</span>Promise<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>then <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>resolved<span class="token punctuation">,</span>rejected<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> self <span class="token operator">=</span> <span class="token keyword">this</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> resolved <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        resolved <span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span> value <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> value<span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> rejected <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        rejected <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span> reason <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">throw</span> reason<span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token keyword">function</span> <span class="token function">callbackFn</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>             <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token function">type</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>PromiseResult<span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token keyword">instanceof</span> <span class="token class-name">Promise</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>v<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                    <span class="token function">resolve</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                    <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>            <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>             <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>PromiseState<span class="token operator">==</span><span class="token string">'pending'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>callback<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>resolved<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">callbackFn</span><span class="token punctuation">(</span>resolved<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>rejected<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">callbackFn</span><span class="token punctuation">(</span>rejected<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>PromiseState<span class="token operator">==</span><span class="token string">'fulfilled'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token function">callbackFn</span><span class="token punctuation">(</span>resolved<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>PromiseState<span class="token operator">==</span><span class="token string">'rejected'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token function">callbackFn</span><span class="token punctuation">(</span>rejected<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="实例方法catch"><a href="#实例方法catch" class="headerlink" title="实例方法catch"></a>实例方法catch</h3><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">//实例方法 接受一个失败的回调函数</span>Promise<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token keyword">catch</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>rejected<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>undefined<span class="token punctuation">,</span>rejected<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="静态方法resolve"><a href="#静态方法resolve" class="headerlink" title="静态方法resolve"></a>静态方法resolve</h3><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 静态方法 返回值为一个Promise实例</span>Promise<span class="token punctuation">.</span>resolve <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token keyword">instanceof</span> <span class="token class-name">Promise</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>v<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token function">resolve</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="静态方法reject"><a href="#静态方法reject" class="headerlink" title="静态方法reject"></a>静态方法reject</h3><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 静态方法 返回值为一个Promise实例</span>Promise<span class="token punctuation">.</span>reject <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="静态方法all"><a href="#静态方法all" class="headerlink" title="静态方法all"></a>静态方法all</h3><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 静态方法 接受一个由promise组成的数组 返回值为一个Promise实例 若成功则结果值为一个Pormise,这个promise的结果值为一个数组,存放的为每个promise实例的成功的结果值,若失败则返回为最先失败的那个Promise实例</span>Promise<span class="token punctuation">.</span>all <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>PromiseArr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>PromiseArr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            PromiseArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>v<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                count<span class="token operator">++</span>                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> v                <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">===</span> PromiseArr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token function">resolve</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="静态方法race"><a href="#静态方法race" class="headerlink" title="静态方法race"></a>静态方法race</h3><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 静态方法 接受一个由promise组成的数组 返回结果为最先改变状态的promise</span>Promise<span class="token punctuation">.</span>race <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>PromiseArr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>PromiseArr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            PromiseArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>v<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token function">resolve</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="使用es6的class实现Promise"><a href="#使用es6的class实现Promise" class="headerlink" title="使用es6的class实现Promise"></a>使用es6的class实现Promise</h3><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Promise</span><span class="token punctuation">{</span>    <span class="token keyword">constructor</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>PromiseState <span class="token operator">=</span> <span class="token string">'pending'</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>PromiseResult <span class="token operator">=</span> <span class="token keyword">null</span>        <span class="token keyword">const</span> self <span class="token operator">=</span> <span class="token keyword">this</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>callback <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>PromiseState <span class="token operator">!==</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token keyword">return</span>            self<span class="token punctuation">.</span>PromiseState <span class="token operator">=</span> <span class="token string">'fulfilled'</span>            self<span class="token punctuation">.</span>PromiseResult <span class="token operator">=</span> data            <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            self<span class="token punctuation">.</span>callback<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                item<span class="token punctuation">.</span><span class="token function">resolved</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>         <span class="token punctuation">}</span>        <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>PromiseState <span class="token operator">!==</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token keyword">return</span>            self<span class="token punctuation">.</span>PromiseState <span class="token operator">=</span> <span class="token string">'rejected'</span>            self<span class="token punctuation">.</span>PromiseResult <span class="token operator">=</span> data            <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                self<span class="token punctuation">.</span>callback<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                    item<span class="token punctuation">.</span><span class="token function">rejected</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>                    <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token function">executor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">then</span><span class="token punctuation">(</span>resolved<span class="token punctuation">,</span>rejected<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">const</span> self <span class="token operator">=</span> <span class="token keyword">this</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> resolved <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            resolved <span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span> value <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> value<span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> rejected <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            rejected <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span> reason <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">throw</span> reason<span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">function</span> <span class="token function">callbackFn</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                 <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token function">type</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>PromiseResult<span class="token punctuation">)</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token keyword">instanceof</span> <span class="token class-name">Promise</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>v<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                        <span class="token function">resolve</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>                    <span class="token punctuation">}</span><span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                        <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>                    <span class="token punctuation">}</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                    <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>                <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                   <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>                 <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>PromiseState<span class="token operator">==</span><span class="token string">'pending'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>callback<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>resolved<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">callbackFn</span><span class="token punctuation">(</span>resolved<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>rejected<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">callbackFn</span><span class="token punctuation">(</span>rejected<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>PromiseState<span class="token operator">==</span><span class="token string">'fulfilled'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                    <span class="token function">callbackFn</span><span class="token punctuation">(</span>resolved<span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>PromiseState<span class="token operator">==</span><span class="token string">'rejected'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                    <span class="token function">callbackFn</span><span class="token punctuation">(</span>rejected<span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span><span class="token punctuation">(</span>rejected<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>undefined<span class="token punctuation">,</span>rejected<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token keyword">instanceof</span> <span class="token class-name">Promise</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>v<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                    <span class="token function">resolve</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                    <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token function">all</span><span class="token punctuation">(</span>PromiseArr<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>PromiseArr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                PromiseArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>v<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                    count<span class="token operator">++</span>                    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> v                    <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">===</span> PromiseArr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token function">resolve</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                    <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token function">race</span><span class="token punctuation">(</span>PromiseArr<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>PromiseArr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                PromiseArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>v<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                    <span class="token function">resolve</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                    <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;手写Promise及其API&quot;&gt;&lt;a href=&quot;#手写Promise及其API&quot; class=&quot;headerlink&quot; title=&quot;手写Promise及其API&quot;&gt;&lt;/a&gt;手写Promise及其API&lt;/h2&gt;&lt;h3 id=&quot;Promise构造函数&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="Typescript" scheme="https://github.com/categories/Typescript/"/>
    
    
    <category term="Typescript" scheme="https://github.com/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>前端实现元素水平垂直居中的九种方式</title>
    <link href="https://github.com/2023/07/01/%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E4%B9%9D%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://github.com/2023/07/01/%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E4%B9%9D%E7%A7%8D%E6%96%B9%E5%BC%8F/</id>
    <published>2023-06-30T16:00:00.000Z</published>
    <updated>2023-07-01T08:53:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前端实现元素水平垂直居中的九种方式"><a href="#前端实现元素水平垂直居中的九种方式" class="headerlink" title="前端实现元素水平垂直居中的九种方式"></a>前端实现元素水平垂直居中的九种方式</h2><p>这是我的HTML结构：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>parent<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>child<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p>下面是我的CSS代码，分为九种方式实现：</p><ol><li>定位+margin:auto （推荐）<pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>        <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>        <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>        <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token selector"><span class="token class">.child</span></span><span class="token punctuation">{</span>        <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>        <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token property">bottom</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token property">right</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>        <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>        <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> brown<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre></li><li>定位+transform （推荐）</li></ol><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>            <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token selector"><span class="token class">.child</span></span><span class="token punctuation">{</span>            <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>            <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>            <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>            <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-<span class="token number">50%</span>,-<span class="token number">50%</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> brown<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><ol start="3"><li>定位+margin</li></ol><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>            <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token selector"><span class="token class">.child</span></span><span class="token punctuation">{</span>            <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>            <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>            <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>            <span class="token property">margin-left</span><span class="token punctuation">:</span>-<span class="token number">50</span>px<span class="token punctuation">;</span>            <span class="token property">margin-top</span><span class="token punctuation">:</span> -<span class="token number">50</span>px<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> brown<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><ol start="4"><li>定位+calc</li></ol><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>            <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token selector"><span class="token class">.child</span></span><span class="token punctuation">{</span>            <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span> */            <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>            <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>            <span class="token property">margin-left</span><span class="token punctuation">:</span><span class="token function">calc</span><span class="token punctuation">(</span>-<span class="token number">50</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token property">margin-top</span><span class="token punctuation">:</span> <span class="token function">calc</span><span class="token punctuation">(</span>-<span class="token number">50</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/* 上面四行等同于下面两行 注意:使用calc的时候，运算符两边要留个空格，否则效果不会出现 */</span>            <span class="token property">top</span><span class="token punctuation">:</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token number">50%</span> - <span class="token number">50</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token property">left</span><span class="token punctuation">:</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token number">50%</span> - <span class="token number">50</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> brown<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><ol start="5"><li>flex （推荐）</li></ol><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>            <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>            <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token selector"><span class="token class">.child</span></span><span class="token punctuation">{</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> brown<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><ol start="6"><li>grid</li></ol><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>            <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>            <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token selector"><span class="token class">.child</span></span><span class="token punctuation">{</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> brown<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><ol start="7"><li>table-cell+vertical-align: middle</li></ol><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>            <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span>   //或者使用line-height代替            <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token selector"><span class="token class">.child</span></span><span class="token punctuation">{</span>            <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> brown<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><ol start="8"><li>table-cell+line-height</li></ol><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>            <span class="token property">line-height</span><span class="token punctuation">:</span><span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token selector"><span class="token class">.child</span></span><span class="token punctuation">{</span>            <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> brown<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><ol start="9"><li>flex+margin:auto （推荐） </li></ol><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token selector"><span class="token class">.child</span></span><span class="token punctuation">{</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> brown<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><p>好了，以上就是实现元素水平垂直居中的九种方式，亲自在浏览器中调试过了，都是没有问题的，具体代码文件已经上传。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前端实现元素水平垂直居中的九种方式&quot;&gt;&lt;a href=&quot;#前端实现元素水平垂直居中的九种方式&quot; class=&quot;headerlink&quot; title=&quot;前端实现元素水平垂直居中的九种方式&quot;&gt;&lt;/a&gt;前端实现元素水平垂直居中的九种方式&lt;/h2&gt;&lt;p&gt;这是我的HTML结构</summary>
      
    
    
    
    <category term="HTML&amp;CSS" scheme="https://github.com/categories/HTML-CSS/"/>
    
    
    <category term="HTML&amp;CSS" scheme="https://github.com/tags/HTML-CSS/"/>
    
  </entry>
  
  <entry>
    <title>Promise异步编程的应用</title>
    <link href="https://github.com/2023/06/29/Promise%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>https://github.com/2023/06/29/Promise%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8/</id>
    <published>2023-06-28T16:00:00.000Z</published>
    <updated>2023-07-01T08:55:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Promise异步编程的应用"><a href="#Promise异步编程的应用" class="headerlink" title="Promise异步编程的应用"></a>Promise异步编程的应用</h2><h3 id="Promise出现的原因或者它的出现为了解决什么问题"><a href="#Promise出现的原因或者它的出现为了解决什么问题" class="headerlink" title="Promise出现的原因或者它的出现为了解决什么问题"></a>Promise出现的原因或者它的出现为了解决什么问题</h3><p>在Promise出现之前，解决异步问题的方式通常是用回调函数的方式来解决的，看下面几个例子：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// fs文件操作 第二个参数为指定的回调函数</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'./index.html'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// AJAX 第三个参数为指定的回调函数</span>$<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/server'</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>data<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 定时器相关 第一个参数就是指定的回调函数</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span></code></pre><p>那回调函数的方式就可以解决异步的问题，那为什么还要使用Promise呢，下面是传统的回调函数方法解决异步的缺点：</p><blockquote><p>1、可读性差（回调地狱）：回调地狱的代码嵌套深度高，导致代码难以理解和阅读。每个异步操作的回调函数需要嵌套在前一个异步操作的回调函数中，使得代码结构变得复杂。<br>2、错误处理困难：在回调地狱中，错误处理通常需要在每个回调函数中进行，容易出现遗漏或混乱。当出现错误时，追踪和调试问题变得困难，尤其是当错误处理代码也被嵌套在多个层级中时。<br>3、难以维护：由于代码结构复杂，回调地狱中的代码修改和维护都会变得困难。如果需要添加、修改或删除某个异步操作，可能需要修改多个嵌套的回调函数，增加了代码的脆弱性。<br>4、缺乏顺序控制：在回调地狱中，异步操作的执行顺序通常由回调函数的嵌套关系决定，使得代码的执行流程不易理解和控制。特别是在有多个异步操作需要按特定顺序执行的情况下，代码会变得混乱。</p></blockquote><p>使用Promise就可以解决上面的问题,下面展开Promise相关的内容.<br><img src="/img/promise1.png" class="lazyload placeholder" data-srcset="/img/promise1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Promise"><br>对于一个Promise来说，他有两个内置属性，分别为：PromiseState与PromiseResult。</p><ol><li>PromiseState：表示 Promise 的当前状态，它可以有以下三个可能的取值：<br>“pending”：Promise 正在进行中，尚未完成或被拒绝。<br>“fulfilled”：Promise 已成功完成，即已被解析。<br>“rejected”：Promise 被拒绝，即出现了错误或异常。</li><li>PromiseResult：表示 Promise 的最终结果值，它的值取决于 Promise 的状态。如果 Promise 被成功解析（fulfilled），则该属性将包含解析后的值。如果 Promise 被拒绝（rejected），则该属性将包含拒绝的原因。<br>还有一点就是一个Promise实例的状态只能改变一次，且只能从Pending到fulfilled或者从Pending到rejected。</li></ol><h3 id="Promise的工作流程"><a href="#Promise的工作流程" class="headerlink" title="Promise的工作流程"></a>Promise的工作流程<img src="/img/promise2.png" class="lazyload placeholder" data-srcset="/img/promise2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Promise的工作流程"></h3><h3 id="Promise的构造函数的组成"><a href="#Promise的构造函数的组成" class="headerlink" title="Promise的构造函数的组成"></a>Promise的构造函数的组成</h3><p>Promise(executor){}</p><ol><li>executor函数:执行器函数 (resolve,reject)=&gt;{]</li><li>resolve函数:内部定义成功时我们调用的函数</li><li>reject()函数:内部定义失败时我们调用的函数<br>注:executor执行器函数是同步调用的，如下例：<pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span></code></pre>运行结果:<br><img src="/img/promise3.png" class="lazyload placeholder" data-srcset="/img/promise3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"><h3 id="Promise-resolve（）"><a href="#Promise-resolve（）" class="headerlink" title="Promise.resolve（）"></a>Promise.resolve（）</h3>对于这个静态方法，如果传入的参数是一个非 Promise 对象（比如一个普通的值或一个 对象），那么返回的 Promise 对象将会处于已解决（fulfilled）状态，并且它的值将是传入的参数。<br>如果传入的参数是一个 Promise 对象，那么 Promise.resolve 方法将直接返回这个 Promise 对象，则返回的 Promise 对象的状态就是内部这个promise的状态，<br>看代码：</li></ol><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token function">reject</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span></code></pre><p>输出结果如下:<br><img src="/img/promise4.png" class="lazyload placeholder" data-srcset="/img/promise4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="输出结果"></p><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h3><p>对于这个方法，无论传入的参数是什么，Promise.reject 方法返回的 Promise 对象都将处于已拒绝（rejected）状态。传入的参数将成为拒绝原因，可以通过 Promise 对象的 catch 方法或 onRejected 回调函数来处理。</p><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><p>Promise.all 方法是一个静态方法，用于处理多个 Promise 对象，并返回一个新的 Promise 对象。它接受一个可迭代的对象（比如数组）作为参数，该可迭代对象包含了多个 Promise 对象。<br>如果传入的可迭代对象是空的，则 Promise.all 立即返回一个已解决（fulfilled）状态的 Promise 对象，且该 Promise 对象的值是一个空数组 []。</p><pre class=" language-typescript"><code class="language-typescript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p><img src="/img/promise5.png" class="lazyload placeholder" data-srcset="/img/promise5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Promise.all"><br>如果传入的可迭代对象中的所有 Promise 对象都处于已解决状态，则 Promise.all 返回的 Promise 对象也会处于已解决状态，并且它的值是一个与传入的 Promise 对象顺序相对应的值数组。<br>如果传入的可迭代对象中的任何一个 Promise 对象处于已拒绝状态，则 Promise.all 返回的 Promise 对象会立即处于已拒绝状态，并且它的拒绝原因是第一个被拒绝的 Promise 对象的拒绝原因。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> p1 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">const</span> p2 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">const</span> p3 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">,</span>p3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//[1,2,3]</span><span class="token punctuation">}</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">,</span>p3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>下面是运行结果:<br><img src="/img/promise6.png" class="lazyload placeholder" data-srcset="/img/promise6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"><br>当其中有reject的promise时又是怎样的呢，看下面的例子：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> p1 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">const</span> p2 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">const</span> p3 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">,</span>p3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p><img src="/img/promise7.png" class="lazyload placeholder" data-srcset="/img/promise7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"><br>可以看到它的拒绝原因是第一个被拒绝的 Promise 对象的拒绝原因。</p><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p>Promise.race 方法是一个静态方法，用于处理多个 Promise 对象，并返回一个新的 Promise 对象。它接受一个可迭代的对象（比如数组）作为参数，该可迭代对象包含了多个 Promise 对象。<br>Promise.race 方法的行为如下：<br>如果传入的可迭代对象是空的，则 Promise.race 返回的 Promise 对象将永远处于待定（pending）状态。</p><pre class=" language-typescript"><code class="language-typescript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>运行结果：<br><img src="/img/promise8.png" class="lazyload placeholder" data-srcset="/img/promise8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"></p><p>如果传入的可迭代对象中的任何一个 Promise 对象首先变为已解决（fulfilled）或已拒绝（rejected）状态，则 Promise.race 返回的 Promise 对象也会立即变为相应的状态，并且其值或拒绝原因与首先完成的 Promise 对象相对应。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> p1 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">const</span> p2 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">const</span> p3 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">,</span>p3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p><img src="/img/promise9.png" class="lazyload placeholder" data-srcset="/img/promise9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"></p><h3 id="改变Promise实例状态的方式"><a href="#改变Promise实例状态的方式" class="headerlink" title="改变Promise实例状态的方式"></a>改变Promise实例状态的方式</h3><ul><li>resolve  将状态变成fulfilled</li><li>reject     将状态变成rejected</li><li>throw     将状态变成rejected</li></ul><h3 id="Promise指定多个回调"><a href="#Promise指定多个回调" class="headerlink" title="Promise指定多个回调"></a>Promise指定多个回调</h3><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> p1 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>p1<span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>p1<span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">34</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>运行结果：<br><img src="/img/promise10.png" class="lazyload placeholder" data-srcset="/img/promise10.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"><br>指定多个then也是同理的，都会执行（前提是promise的状态发生了变化，如果一直是pending状态就都不会执行）。</p><h3 id="中断Promise链的方式"><a href="#中断Promise链的方式" class="headerlink" title="中断Promise链的方式"></a>中断Promise链的方式</h3><p><img src="/img/promise11.png" class="lazyload placeholder" data-srcset="/img/promise11.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="中断Promise链的方式"><br>运行结果只会输出1和2，不会输出3，因为我们把它中断了，并且中断promise链的方式有且只有这一种。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Promise异步编程的应用&quot;&gt;&lt;a href=&quot;#Promise异步编程的应用&quot; class=&quot;headerlink&quot; title=&quot;Promise异步编程的应用&quot;&gt;&lt;/a&gt;Promise异步编程的应用&lt;/h2&gt;&lt;h3 id=&quot;Promise出现的原因或者它的出</summary>
      
    
    
    
    <category term="Typescript" scheme="https://github.com/categories/Typescript/"/>
    
    
    <category term="Typescript" scheme="https://github.com/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>Vue的初始化过程都做了什么</title>
    <link href="https://github.com/2023/06/27/Vue%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E9%83%BD%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>https://github.com/2023/06/27/Vue%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E9%83%BD%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</id>
    <published>2023-06-26T16:00:00.000Z</published>
    <updated>2023-07-01T08:56:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue的初始化过程都做了什么？"><a href="#Vue的初始化过程都做了什么？" class="headerlink" title="Vue的初始化过程都做了什么？"></a>Vue的初始化过程都做了什么？</h2><p>从构造函数前面打断点，然后进行一步步的调试：<br><img src="/img/initvue1.png" class="lazyload placeholder" data-srcset="/img/initvue1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="调试方式"><br>首先会进入init.js里面执行Vue构造函数。init函数之前会进行一下判断：即init之前的代码作用为:检测在使用 Vue 构造函数时是否使用了 new 关键字进行实例化。它主要用于开发环境下的警告提示,之后开始执行init函数正式进入Vue初始化过程。这个options就是用户传入的合并选项在这里，即</p><pre class=" language-typescript"><code class="language-typescript"><span class="token punctuation">{</span>data<span class="token punctuation">:</span><span class="token punctuation">{</span>msg<span class="token punctuation">:</span><span class="token string">'123'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>methods<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'eat'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token function">drink</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'drink'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="/img/initvue2.png" class="lazyload placeholder" data-srcset="/img/initvue2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="init初始化方法"><br>下面让我们进入init方法，给出具体的源代码：rt</p><pre class=" language-typescript"><code class="language-typescript">Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>_init <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>options<span class="token operator">?</span><span class="token punctuation">:</span> Object<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> vm<span class="token punctuation">:</span> Component <span class="token operator">=</span> <span class="token keyword">this</span>    <span class="token comment" spellcheck="true">// a uid</span>    vm<span class="token punctuation">.</span>_uid <span class="token operator">=</span> uid<span class="token operator">++</span>    <span class="token keyword">let</span> startTag<span class="token punctuation">,</span> endTag    <span class="token comment" spellcheck="true">/* istanbul ignore if */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>NODE_ENV <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> config<span class="token punctuation">.</span>performance <span class="token operator">&amp;&amp;</span> mark<span class="token punctuation">)</span> <span class="token punctuation">{</span>      startTag <span class="token operator">=</span> <span class="token template-string"><span class="token string">`vue-perf-start:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>vm<span class="token punctuation">.</span>_uid<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span>      endTag <span class="token operator">=</span> <span class="token template-string"><span class="token string">`vue-perf-end:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>vm<span class="token punctuation">.</span>_uid<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span>      <span class="token function">mark</span><span class="token punctuation">(</span>startTag<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// a flag to avoid this being observed</span>    vm<span class="token punctuation">.</span>_isVue <span class="token operator">=</span> <span class="token keyword">true</span>    <span class="token comment" spellcheck="true">// merge options</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>options <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>_isComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// optimize internal component instantiation</span>      <span class="token comment" spellcheck="true">// since dynamic options merging is pretty slow, and none of the</span>      <span class="token comment" spellcheck="true">// internal component options needs special treatment.</span>      <span class="token function">initInternalComponent</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> options<span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      vm<span class="token punctuation">.</span>$options <span class="token operator">=</span> <span class="token function">mergeOptions</span><span class="token punctuation">(</span>        <span class="token function">resolveConstructorOptions</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token keyword">constructor</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        options <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        vm      <span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* istanbul ignore else */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>NODE_ENV <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">initProxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      vm<span class="token punctuation">.</span>_renderProxy <span class="token operator">=</span> vm    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// expose real self</span>    vm<span class="token punctuation">.</span>_self <span class="token operator">=</span> vm    <span class="token function">initLifecycle</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>    <span class="token function">initEvents</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>    <span class="token function">initRender</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeCreate'</span><span class="token punctuation">)</span>    <span class="token function">initInjections</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// resolve injections before data/props</span>    <span class="token function">initState</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>    <span class="token function">initProvide</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// resolve provide after data/props</span>    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'created'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">/* istanbul ignore if */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>NODE_ENV <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> config<span class="token punctuation">.</span>performance <span class="token operator">&amp;&amp;</span> mark<span class="token punctuation">)</span> <span class="token punctuation">{</span>      vm<span class="token punctuation">.</span>_name <span class="token operator">=</span> <span class="token function">formatComponentName</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token keyword">false</span><span class="token punctuation">)</span>      <span class="token function">mark</span><span class="token punctuation">(</span>endTag<span class="token punctuation">)</span>      <span class="token function">measure</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`vue </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>vm<span class="token punctuation">.</span>_name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> init`</span></span><span class="token punctuation">,</span> startTag<span class="token punctuation">,</span> endTag<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>      vm<span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这个方法是vue实例的初始化方法，它会在创建一个 Vue 实例时被调用。让我们来进一步展开这个方法具体做了什么。</p><ol><li>首先，给当前实例设置 _uid 属性，用于标识唯一的 Vue 实例。</li><li>创建变量startTag 和 endTag 是用于标记解析模板中的标签的起始和结束位置的变量。这是为了创建ast语法树用的，然后设置实例的 _isVue 属性为 true，表示该对象是一个 Vue 实例。</li><li>判断该组件是不是内部组件，如果是内部组件则调用initInternalComponent(vm, options)进行组件合并，否则调用mergeOptions进行组件合并，至于为什么这么做，就是为了提高性能，下面是详细的介绍：</li></ol><blockquote><p>当创建一个组件实例时，会调用 _init 方法进行初始化。在初始化过程中，会检查 options 对象是否存在且具有 _isComponent 属性。如果存在，并且 _isComponent 的值为 true，则表示当前组件是一个内部组件（可以想象成局部注册的组件）。<br>针对内部组件的实例化，由于内部组件的选项合并不需要特殊处理，而且动态选项合并的性能较低，因此可以进行优化。在这种情况下，会调用 initInternalComponent 方法，将内部组件实例和选项对象作为参数传递给该方法。<br>initInternalComponent 方法负责完成内部组件的初始化，包括对选项的处理、状态的初始化等。通过将内部组件的初始化逻辑单独提取为一个方法，可以提高内部组件实例化的性能，并避免对内部组件的选项进行不必要的处理。<br>总而言之，上述代码片段中的逻辑用于优化内部组件的实例化过程，通过调用 initInternalComponent 方法进行内部组件的初始化。这样可以提高内部组件实例化的性能，并简化内部组件选项的处理过程。</p></blockquote><p> 下面是处理内部组件合并的源代码:</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">function</span> initInternalComponent <span class="token punctuation">(</span>vm<span class="token punctuation">:</span> Component<span class="token punctuation">,</span> options<span class="token punctuation">:</span> InternalComponentOptions<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> opts <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token keyword">constructor</span><span class="token punctuation">.</span>options<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// doing this because it's faster than dynamic enumeration.</span>  <span class="token keyword">const</span> parentVnode <span class="token operator">=</span> options<span class="token punctuation">.</span>_parentVnode  opts<span class="token punctuation">.</span>parent <span class="token operator">=</span> options<span class="token punctuation">.</span>parent  opts<span class="token punctuation">.</span>_parentVnode <span class="token operator">=</span> parentVnode  <span class="token keyword">const</span> vnodeComponentOptions <span class="token operator">=</span> parentVnode<span class="token punctuation">.</span>componentOptions  opts<span class="token punctuation">.</span>propsData <span class="token operator">=</span> vnodeComponentOptions<span class="token punctuation">.</span>propsData  opts<span class="token punctuation">.</span>_parentListeners <span class="token operator">=</span> vnodeComponentOptions<span class="token punctuation">.</span>listeners  opts<span class="token punctuation">.</span>_renderChildren <span class="token operator">=</span> vnodeComponentOptions<span class="token punctuation">.</span>children  opts<span class="token punctuation">.</span>_componentTag <span class="token operator">=</span> vnodeComponentOptions<span class="token punctuation">.</span>tag  <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>render<span class="token punctuation">)</span> <span class="token punctuation">{</span>    opts<span class="token punctuation">.</span>render <span class="token operator">=</span> options<span class="token punctuation">.</span>render    opts<span class="token punctuation">.</span>staticRenderFns <span class="token operator">=</span> options<span class="token punctuation">.</span>staticRenderFns  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这个函数的意思：子组件的选项会通过合并方式添加到子组件实例的选项中，以便子组件能够继承和访问父组件的选项。通过这种方式，子组件可以访问父组件的属性、方法、生命周期钩子等。<br>即initInternalComponent 方法主要用于局部注册的组件实例化时的选项合并，mergeOptions 方法用于全局注册和局部注册的组件选项的合并。合并的选项主要为components，directives，methods，computed，props等等，还有子组件的钩子函数等等。合并的结果是父组件的选项优先级高，子组件的选项会被合并到父组件的选项中，形成最终的组件选项对象<br>4. 接下来执行initLifecycle方法，它的作用就是初始化组件实例的生命周期相关属性：例如：<br>初始化 $parent 属性：将父组件实例赋值给 $parent，用于在组件实例中可以访问到其父组件实例。<br>初始化 $root 属性：将根组件实例赋值给 $root，用于在组件实例中可以访问到根组件实例。<br>初始化 $children 属性，初始化 $refs 属性<br>初始化 _watcher 属性<br>初始化 _inactive 属性<br>初始化 _isMounted 属性：将 false 赋值给 _isMounted，表示组件实例当前没有挂载到 DOM 中。<br>初始化 _isDestroyed 属性<br>初始化 _isBeingDestroyed 属性<br>5. initEvents 方法初始化组件实例的事件相关属性和方法。它主要完成以下几个任务：<br>初始化 _events 属性：将空对象赋值给 _events，用于存储组件实例的事件监听器。<br>初始化 _hasHookEvent 属性：将 false 赋值给 _hasHookEvent，表示组件实例当前没有绑定任何钩子函数的事件监听器。<br>将组件构造函数选项中的事件监听器合并到组件实例的 _events 属性中。这样可以在组件实例中通过 $on、$off、$once 等方法进行事件的订阅和取消订阅。<br>将组件实例的父组件的事件监听器合并到组件实例的 _events 属性中。这样可以在组件实例中访问到其父组件的事件监听器。<br>总之，通过执行 initEvents 方法，Vue 组件实例可以进行事件的订阅和触发，从而实现组件间的通信和交互。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">function</span> initEvents <span class="token punctuation">(</span>vm<span class="token punctuation">:</span> Component<span class="token punctuation">)</span> <span class="token punctuation">{</span>  vm<span class="token punctuation">.</span>_events <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>  vm<span class="token punctuation">.</span>_hasHookEvent <span class="token operator">=</span> <span class="token keyword">false</span>  <span class="token comment" spellcheck="true">// init parent attached events</span>  <span class="token keyword">const</span> listeners <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>_parentListeners  <span class="token keyword">if</span> <span class="token punctuation">(</span>listeners<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">updateComponentListeners</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> listeners<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>6.执行initRender 方法，Vue 组件实例具备了渲染功能所需的基本属性和方法（_vnode，$slots等等）。它为组件的模板渲染提供了必要的支持，使组件能够生成对应的虚拟节点，并进行相应的渲染和更新操作。<br>7.调用beforeCreate钩子函数，注意，beforeCreate 钩子函数在组件实例创建之前执行，此时组件的数据、计算属性、方法等还未初始化，但是可以在这个阶段进行一些初始化配置或执行其他操作。还有就是，<strong>选项合并是关于组件选项对象的处理，而初始化是关于组件实例的内部状态的设置和准备。</strong><br>8.initInjections 方法的主要功能是处理组件实例的注入选项（inject）并将其添加到组件实例的 _provided 属性中。它会在组件实例化的过程中被调用，确保组件实例可以直接访问注入的数据。<br>9.执行 initState 方法，它的作用是初始化组件实例的状态，状态包括组件的数据（data）、计算属性（computed）、观察者（watchers）等，下面给出代码，按这个顺序进行的初始化：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> initState <span class="token punctuation">(</span>vm<span class="token punctuation">:</span> Component<span class="token punctuation">)</span> <span class="token punctuation">{</span>  vm<span class="token punctuation">.</span>_watchers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token keyword">const</span> opts <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>props<span class="token punctuation">)</span> <span class="token function">initProps</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>props<span class="token punctuation">)</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>methods<span class="token punctuation">)</span> <span class="token function">initMethods</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>methods<span class="token punctuation">)</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">initData</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token function">observe</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">true</span> <span class="token comment" spellcheck="true">/* asRootData */</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>computed<span class="token punctuation">)</span> <span class="token function">initComputed</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>computed<span class="token punctuation">)</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>watch <span class="token operator">&amp;&amp;</span> opts<span class="token punctuation">.</span>watch <span class="token operator">!==</span> nativeWatch<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">initWatch</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>watch<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>10.initProvide方法，用于初始化组件的Provide选项，其允许一个组件向其所有的子组件提供数据或者方法，这样子组件就可以通过inject来访问这些数据和方法。<br>11..调用created钩子函数.组件实例刚好被创建然后立即调用该方法，表明此时组件的数据观测 和事件机制都已经初始化完成。<br>12.模板渲染：在 created 钩子函数之后，Vue.js 将根据组件的虚拟 DOM 结构开始渲染组件的模板。这个过程涉及以下步骤：<br>将组件的虚拟 DOM 与实际的 DOM 进行比对，找出需要更新的部分。<br>将需要更新的部分进行 DOM 操作，实现视图的更新。<br>13.调用beforeMount钩子函数<br>14.模板挂载：在 beforeMount 钩子函数之后，Vue.js 开始将组件的虚拟 DOM 渲染到实际的 DOM 中。这个过程包括以下步骤：<br>将组件的虚拟 DOM 插入到实际 DOM 中的指定位置。<br>执行实际的 DOM 操作，如添加、修改或删除 DOM 元素。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Vue的初始化过程都做了什么？&quot;&gt;&lt;a href=&quot;#Vue的初始化过程都做了什么？&quot; class=&quot;headerlink&quot; title=&quot;Vue的初始化过程都做了什么？&quot;&gt;&lt;/a&gt;Vue的初始化过程都做了什么？&lt;/h2&gt;&lt;p&gt;从构造函数前面打断点，然后进行一步步</summary>
      
    
    
    
    <category term="Vue" scheme="https://github.com/categories/Vue/"/>
    
    
    <category term="Vue" scheme="https://github.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>TS判断一个值是否为数组类型</title>
    <link href="https://github.com/2023/06/26/TS%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%80%BC%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B/"/>
    <id>https://github.com/2023/06/26/TS%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%80%BC%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B/</id>
    <published>2023-06-25T16:00:00.000Z</published>
    <updated>2023-07-01T08:55:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TS判断一个值是否为数组类型"><a href="#TS判断一个值是否为数组类型" class="headerlink" title="TS判断一个值是否为数组类型"></a>TS判断一个值是否为数组类型</h2><h3 id="instanceof-用于检查对象是否属于特定类或构造函数的实例，返回的是一个布尔值。"><a href="#instanceof-用于检查对象是否属于特定类或构造函数的实例，返回的是一个布尔值。" class="headerlink" title="instanceof 用于检查对象是否属于特定类或构造函数的实例，返回的是一个布尔值。"></a>instanceof 用于检查对象是否属于特定类或构造函数的实例，返回的是一个布尔值。</h3><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> arr<span class="token punctuation">:</span> <span class="token keyword">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> isArray <span class="token operator">=</span> arr <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'使用instanceof判断'</span><span class="token punctuation">,</span>isArray<span class="token punctuation">)</span></code></pre><p><img src="/img/arr_judge.png" class="lazyload placeholder" data-srcset="/img/arr_judge.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"></p><h3 id="Array-isArray-用于检查一个值是否为数组类型，返回的是一个布尔类型"><a href="#Array-isArray-用于检查一个值是否为数组类型，返回的是一个布尔类型" class="headerlink" title="Array.isArray 用于检查一个值是否为数组类型，返回的是一个布尔类型"></a>Array.isArray 用于检查一个值是否为数组类型，返回的是一个布尔类型</h3><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> isArray<span class="token punctuation">:</span> <span class="token keyword">boolean</span> <span class="token operator">=</span> <span class="token keyword">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//true</span></code></pre><h3 id="Array-prototype-isPrototypeof"><a href="#Array-prototype-isPrototypeof" class="headerlink" title="Array.prototype.isPrototypeof"></a>Array.prototype.isPrototypeof</h3><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> obj<span class="token punctuation">:</span>object <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">const</span> arr<span class="token punctuation">:</span> <span class="token keyword">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> isPrototype<span class="token punctuation">:</span> <span class="token keyword">boolean</span> <span class="token operator">=</span> <span class="token keyword">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//false</span><span class="token keyword">const</span> isPrototype<span class="token punctuation">:</span> <span class="token keyword">boolean</span> <span class="token operator">=</span> <span class="token keyword">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//true</span></code></pre><p>备注:Array.prototype.isPrototypeOf 方法主要用于检查对象是否继承了数组的原型，而不是判断对象是否为数组类型，其返回一个布尔值，如果 obj 是数组的实例或继承自数组的原型，则返回 true，否则返回 false。<br>看下面一个例子：</p><pre class=" language-typescript"><code class="language-typescript">  <span class="token keyword">interface</span> <span class="token class-name">MyObject</span> <span class="token keyword">extends</span> <span class="token class-name">Array</span><span class="token operator">&lt;</span><span class="token keyword">any</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">const</span> myObj<span class="token punctuation">:</span> MyObject <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>  myObj<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在上述示例中，我们通过定义一个 MyObject 接口来表示 myObj 对象，它扩展了 Array<any> 类型，这样我们就可以在 myObj 对象上使用数组的属性和方法。使用类型断言 const myObj: MyObject = Object.create(Array.prototype); 将 myObj 声明为 MyObject 类型，表示它是继承自数组原型的对象。<br>打印数组如下：</any></p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">Array</span> <span class="token punctuation">{</span> <span class="token string">'0'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> length<span class="token punctuation">:</span> <span class="token number">3</span> <span class="token punctuation">}</span></code></pre><pre class=" language-typescript"><code class="language-typescript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>myObj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>myObj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myObj <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span></code></pre><p>至于为什么，那就需要了解一下isArray的实现原理：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">Array</span><span class="token punctuation">.</span>isArray <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'[object Array]'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>我再解释一下：当我们使用 Object.create(Array.prototype) 创建对象 myObj 时，myObj 成为了一个继承了数组原型的新对象。它继承了数组原型上的方法和属性，包括 push、pop、length 等。<br>然而，Array.isArray 方法的实现原理是基于 JavaScript 的内部特性，它不仅仅依赖于对象是否继承了数组原型，还会检查对象是否具有内部的特殊属性 [[Class]]。只有当对象的 [[Class]] 属性为 “Array” 时，Array.isArray 才会返回 true。<br>对于真正的数组对象，它们的 [[Class]] 属性会被设置为 “Array”，这是 JavaScript 引擎的内部行为。这样，Array.isArray 就可以准确地判断一个值是否为数组。<br>然而，通过 Object.create(Array.prototype) 创建的对象 myObj 并不具有 “Array” 的 [[Class]] 属性。它的 [[Class]] 属性为 “Object”，因为它本质上仍然是一个对象。<br>因此，尽管 myObj 继承了数组原型上的方法，可以调用 push 方法并具有类似数组的行为，但它不满足 Array.isArray 对于数组类型的判断条件，因为它的 [[Class]] 属性不是 “Array”。所以 Array.isArray(myObj) 返回 false。<br>这个行为巧妙地区分了真正的数组和仅仅继承了数组原型的对象。它让我们能够更准确地判断一个值是否为数组类型,。</p><h3 id="Object-getPrototypeOf-方法用于获取指定对象的原型（即该对象继承的原型对象）"><a href="#Object-getPrototypeOf-方法用于获取指定对象的原型（即该对象继承的原型对象）" class="headerlink" title="Object.getPrototypeOf 方法用于获取指定对象的原型（即该对象继承的原型对象）"></a>Object.getPrototypeOf 方法用于获取指定对象的原型（即该对象继承的原型对象）</h3><pre class=" language-typescript"><code class="language-typescript">Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token keyword">Array</span><span class="token punctuation">.</span>prototype <span class="token comment" spellcheck="true">//true</span></code></pre><p>Object.getPrototypeOf 方法会返回指定对象的原型对象。它是通过访问对象的 [[Prototype]] 属性来获取原型。[[Prototype]] 属性存储了对象的原型引用。</p><h3 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h3><pre class=" language-typescript"><code class="language-typescript">Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//[object Array]</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//[object Object]</span></code></pre><p>综上，isArray和Object.prototype.toString判断的是最准确的。</p><hr><h3 id="番外：typeof相关内容"><a href="#番外：typeof相关内容" class="headerlink" title="番外：typeof相关内容"></a>番外：typeof相关内容</h3><p>typeof 运算符可以判断以下类型：<br>“undefined”：未定义的变量或未赋值的变量。<br>“boolean”：布尔值。<br>“number”：数值。<br>“string”：字符串。<br>“symbol”：符号类型（ES6 引入）。<br>“function”：函数。<br>“object”：对象（包括数组、对象字面量、null、以及特殊的内置对象如 Date、RegExp 等）。<br>但是，typeof 运算符存在一些限制和特殊情况。例如，对于 null 类型和数组类型，typeof 运算符会返回 “object”，无法细分具体的类型，也就是说用来判断基本数据类型还可以，判断引用类型不太好使。</p><p>Object.prototype.toString.call() 方法可以判断几乎所有的数据类型，包括基本类型和复杂类型。它会返回一个类似于 “[object Type]” 的字符串，其中 “Type” 表示具体的数据类型，例如 “[object Array]”、”[object Object]”、”[object Date]” 等，但是，使用 typeof 和 Object.prototype.toString.call() 时，对于自定义的对象类型，都会返回 “[object Object]”，无法准确判断具体的自定义类型。这时可以通过其他方式，如 instanceof 运算符或构造函数来进行更精确的判断。<br>下面是Object.prototype.toString失灵的例子：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span>  <span class="token keyword">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 创建一个person实例</span><span class="token keyword">const</span> person<span class="token punctuation">:</span> Person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"John"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用 typeof 和 Object.prototype.toString.call()</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "object"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "[object Object]"</span></code></pre><p>完结！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TS判断一个值是否为数组类型&quot;&gt;&lt;a href=&quot;#TS判断一个值是否为数组类型&quot; class=&quot;headerlink&quot; title=&quot;TS判断一个值是否为数组类型&quot;&gt;&lt;/a&gt;TS判断一个值是否为数组类型&lt;/h2&gt;&lt;h3 id=&quot;instanceof-用于检查对象</summary>
      
    
    
    
    <category term="Typescript" scheme="https://github.com/categories/Typescript/"/>
    
    
    <category term="Typescript" scheme="https://github.com/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>算法:二叉树的构建(TS实现)</title>
    <link href="https://github.com/2023/06/25/%E7%AE%97%E6%B3%95_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA(TS%E5%AE%9E%E7%8E%B0)/"/>
    <id>https://github.com/2023/06/25/%E7%AE%97%E6%B3%95_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA(TS%E5%AE%9E%E7%8E%B0)/</id>
    <published>2023-06-24T16:00:00.000Z</published>
    <updated>2023-07-25T09:10:56.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法-二叉树的构建-TS实现"><a href="#算法-二叉树的构建-TS实现" class="headerlink" title="算法:二叉树的构建(TS实现)"></a>算法:二叉树的构建(TS实现)</h2><blockquote><p>需求:传入一个数组，将其构建成为一颗二叉树</p></blockquote><blockquote><p>算法思想:</p><ol><li>用户传入一个空数组，或者传入其他非数组值，直接返回null，代表一颗空树</li><li>用户传入一个数组（数组长度大于等于1）：将下标为0的节点作为根节点，其左孩子下标值为2n+1，右孩子下标值为2n+2，根节点下标为0，当左孩子还有孩子时，就将用户传入的数组和当前索引传入handleToNode，进行递归调用，直至递归到最后一层；如果当前孩子有右孩子也是同理；若当前节点没有左孩子或者右孩子，则直接返回null，这也是递归结束的条件。</li></ol></blockquote><p>代码结构如下：<br>首先看一下二叉树中每个节点的结构：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token operator">&lt;</span>TreeType<span class="token operator">></span><span class="token punctuation">{</span>  value<span class="token punctuation">:</span>TreeType <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//节点的值</span>  leftChild<span class="token punctuation">:</span>TreeNode<span class="token operator">&lt;</span>TreeType<span class="token operator">></span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//左孩子</span>  rightChild<span class="token punctuation">:</span>TreeNode<span class="token operator">&lt;</span>TreeType<span class="token operator">></span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//右孩子</span>  <span class="token keyword">constructor</span><span class="token punctuation">(</span>value<span class="token punctuation">:</span>TreeType <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//初始化节点值</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>leftChild <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//初始化左孩子</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>rightChild <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 初始化右孩子</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>数据结构如上图所示—–value用于存储节点的值，leftChild指向当前节点的左孩子，rightChild指向当前节点的右孩子，初始时，节点的左右孩子指针分别指为空。</p><p>节点的结构定义好了之后，开始写二叉树的构建算法：<br>这里我分成了两个方法：分别为buildBinaryTree、handleNode<br>其中buildBinaryTree做了两件事情：一是用来判断当前传入的数组是否合法，二是构建二叉树。做了一层最基本的条件判断与处理，即如果传入的参数有值就进行递归处理成二叉树，若无值则直接return null 返回空树。<br>handleNode是用来实现构建二叉树的细节，以及深层次的递归处理，需要两个参数分别为：要转化的数组和当前处理的节点索引。<br>下面是buildBinaryTree方法的具体实现：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> buildBinaryTree<span class="token operator">&lt;</span>TreeType<span class="token operator">></span><span class="token punctuation">(</span>initTree<span class="token punctuation">:</span><span class="token punctuation">(</span>TreeType<span class="token operator">|</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>TreeNode<span class="token operator">&lt;</span>TreeType<span class="token operator">></span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 当前节点的索引值为n 左孩子的索引值为2n+1 右孩子的索引值为2n+2  且索引从0开始  即根节点的索引值下标是0</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>initTree<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//说明是一颗空树</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> handleNode<span class="token operator">&lt;</span>TreeType<span class="token operator">></span><span class="token punctuation">(</span>initTree<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>下面是handleNode方法的具体实现：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> handleNode<span class="token operator">&lt;</span>TreeType<span class="token operator">></span><span class="token punctuation">(</span>initTree<span class="token punctuation">:</span> <span class="token keyword">Array</span><span class="token operator">&lt;</span>TreeType <span class="token operator">|</span> <span class="token keyword">null</span><span class="token operator">></span><span class="token punctuation">,</span>index<span class="token punctuation">:</span><span class="token keyword">number</span><span class="token punctuation">)</span><span class="token punctuation">:</span>TreeNode<span class="token operator">&lt;</span>TreeType<span class="token operator">></span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">>=</span>initTree<span class="token punctuation">.</span>length<span class="token operator">||</span>initTree<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span>  <span class="token keyword">const</span> currentNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token operator">&lt;</span>TreeType<span class="token operator">></span><span class="token punctuation">(</span>initTree<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>  currentNode<span class="token punctuation">.</span>leftChild <span class="token operator">=</span> <span class="token function">handleNode</span><span class="token punctuation">(</span>initTree<span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">*</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>  currentNode<span class="token punctuation">.</span>rightChild <span class="token operator">=</span> <span class="token function">handleNode</span><span class="token punctuation">(</span>initTree<span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">*</span>index<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> currentNode<span class="token punctuation">}</span></code></pre><p>假如我们传递的参数为：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> preBinaryTree <span class="token punctuation">:</span><span class="token keyword">Array</span><span class="token operator">&lt;</span>Number<span class="token operator">|</span><span class="token keyword">null</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token function">buildBinaryTree</span><span class="token punctuation">(</span>preBinaryTree<span class="token punctuation">)</span></code></pre><p>下面真机运行一下：<br><img src="/img/treebuild1.png" class="lazyload placeholder" data-srcset="/img/treebuild1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="二叉树构建"><br>实际生成的物理结构应该是这样的：<br><img src="/img/treebuild2.png" class="lazyload placeholder" data-srcset="/img/treebuild2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="物理结构图"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;算法-二叉树的构建-TS实现&quot;&gt;&lt;a href=&quot;#算法-二叉树的构建-TS实现&quot; class=&quot;headerlink&quot; title=&quot;算法:二叉树的构建(TS实现)&quot;&gt;&lt;/a&gt;算法:二叉树的构建(TS实现)&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;需求:传入一个</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://github.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://github.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>块级格式化上下文BFC（Block Formatting Context）</title>
    <link href="https://github.com/2023/06/23/%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87BFC%EF%BC%88Block%20Formatting%20Context%EF%BC%89/"/>
    <id>https://github.com/2023/06/23/%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87BFC%EF%BC%88Block%20Formatting%20Context%EF%BC%89/</id>
    <published>2023-06-22T16:00:00.000Z</published>
    <updated>2023-07-01T08:58:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>在介绍BFC之前，先了解一下文档流相关的内容。<br>我们常说的文档流包括定位流、浮动流、普通流三种。</p><h4 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h4><p>如果元素的属性position为absolute或fixed，那这个元素就是一个绝对定位的元素，它会脱离普通流，它的位置由绝对定位的坐标和层级决定，对于position:absolute的元素来说，它将相对于离自己最近的上级元素且设有relative、fixed、absolute的元素进行定位，如果没有则相对于body元素进行定位。<br>对于设置fixed的元素来说，相对于浏览器的窗口进行定位，但是如果该元素的祖先有设置transfrom非none时，会相对于该祖先元素进行定位。</p><h4 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h4><p>在浮动布局中，元素按照普通流的位置出现，然后根据浮动的方向尽可能的偏移，这里有个坑🕳：请看代码</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">padding</span><span class="token punctuation">:</span><span class="token number">0</span> <span class="token number">10</span>px<span class="token punctuation">;</span><span class="token property">background-color</span><span class="token punctuation">:</span> yellowgreen<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>span1(没有设置浮动)<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">float</span><span class="token punctuation">:</span>left<span class="token punctuation">;</span><span class="token property">padding</span><span class="token punctuation">:</span><span class="token number">0</span> <span class="token number">10</span>px<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">40</span>px<span class="token punctuation">;</span><span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>span2(设置左浮动)<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span></code></pre><p>这是运行的效果，会发现第二个设置浮动的span元素跑到了第一个span前面，原因是这样的：float这一属性，float:left会使元素变成一个inline-block元素（使得第一个span元素可以设置宽高）。实际上他是和上一行内元素span显示在同一行。<br>一个浮动的盒子会向右或向左移动直至触碰到包含<strong>块</strong>的边界或另一个浮动盒子的边界。<br>span既不是其包含块也不是另一个浮动的盒子，故div会移动至包含块的边界，所以div会显示在span之前。<br><img src="/img/bfc1.png" class="lazyload placeholder" data-srcset="/img/bfc1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行效果"></p><h4 id="普通流"><a href="#普通流" class="headerlink" title="普通流"></a>普通流</h4><p>普通流其实就是BFC的FC（Formatting Context）格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局以及和其他元素之间的关系和作用。</p><p>在普通流中，元素按照在文档中的先后位置从上至下布局，即行内元素水平排列，块级元素独占一行。</p><h3 id="BFC相关内容"><a href="#BFC相关内容" class="headerlink" title="BFC相关内容"></a>BFC相关内容</h3><h4 id="关于BFC的定义："><a href="#关于BFC的定义：" class="headerlink" title="关于BFC的定义："></a>关于BFC的定义：</h4><blockquote><p>块级格式化上下文（BFC）是WEB页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p></blockquote><p>具有BFC特性的元素可以看作是隔离了的独立容器（想象成一个独立的箱子），容器内的元素不会在布局上影响到外面的元素（你里箱子里面的物品如何怎么摆放都不会影响到外面），并且BFC具有普通容器所没有的一些特性，且同一个元素不可能同时存在于两个BFC中。</p><h4 id="BFC的触发方式"><a href="#BFC的触发方式" class="headerlink" title="BFC的触发方式"></a>BFC的触发方式</h4><p>满足下方任何一个条件即可触发BFC特性</p><ol><li>根元素本身就是个BFC</li><li>浮动元素 float为left或right</li><li>overflow不为visible，即为auto、scroll、hidden</li><li>绝对定位：position:absolute、fixed</li><li>display的值为inline-block flex grid inline-flex inline-grid block等<h4 id="BFC的特性"><a href="#BFC的特性" class="headerlink" title="BFC的特性"></a>BFC的特性</h4></li><li>BFC是页面上的一个独立容器，容器里面的子元素不会影响外面的元素。</li><li>同一个BFC里面的两个相邻的块级元素可能会发生外边距折叠，创建新的BFC可以解决此种情况。</li><li>浮动盒的区域不会和BFC重叠</li><li>计算BFC的高度时，浮动元素也会参与计算</li></ol><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>1、自适应两列布局</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>left<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>right<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><pre class=" language-css"><code class="language-css"><span class="token selector">&lt;style>        <span class="token class">.left</span></span><span class="token punctuation">{</span>            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>            <span class="token property">margin-right</span><span class="token punctuation">:</span> <span class="token number">10</span>px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> blueviolet<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token selector"><span class="token class">.right</span></span><span class="token punctuation">{</span>            <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    &lt;/style></code></pre><p>看一下运行的效果：<br><img src="/img/bfc2.png" class="lazyload placeholder" data-srcset="/img/bfc2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="BFC应用-自适应"><br>这利用了BFC 的「包含浮动元素的影响」（浮动盒的区域不会和BFC重叠）这个特性，右侧的元素开启BFC，不给定宽度，左侧的元素定宽或者不定宽都可以，</p><ul><li>将左列设为左浮动，使得其他块级元素可以和它占据同一行</li><li>右侧为块级元素，利用其自身的流特性占满整行</li><li>右列设置overflow：hidden，触发BFC特性，使其自身与左侧浮动盒隔离开，不占满整行<br>2、解决margin重叠问题<br><img src="/img/bfc3.png" class="lazyload placeholder" data-srcset="/img/bfc3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="margin重叠问题"></li></ul><pre class=" language-css"><code class="language-css">    &lt;div>        &lt;div class=<span class="token string">"div1"</span>>div<span class="token number">1</span>&lt;/div>        &lt;div class=<span class="token string">"div2"</span>>div<span class="token number">2</span>&lt;/div>    &lt;/div></code></pre><p>我给div1设置下边距10px，div2设置上边距是20px,按代码里面两个div盒子应该上下相距30px才对，但是发生了重叠，会取两个margin’中最大的一个值，并不会相加，至于解决方法，如果用BFC解决的话，可以将两个盒子分别放到不同的BFC中，下面是改进的代码：<br>其中wrap设置overflow:hidden开启BFC</p><pre class=" language-html"><code class="language-html">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>div1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>div1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>div2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>div2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p>这利用到了上面BFC特性的第二条—-同一个BFC里面的两个相邻的块级元素可能会发生外边距折叠，那就再开启一个BFC就好了。</p><p>3、父子元素的外边距重叠的问题<br>这种情况存在于父元素与其第一个或最后一个子元素之间。<br><img src="/img/bfc4.png" class="lazyload placeholder" data-srcset="/img/bfc4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="父子元素的外边距重叠的问题"><br>看下代码：</p><pre class=" language-css"><code class="language-css">       <span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/* 有没有都一个样 */</span>            <span class="token property">margin-top</span><span class="token punctuation">:</span> <span class="token number">10</span>px<span class="token punctuation">;</span>             <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token selector"><span class="token class">.son</span></span><span class="token punctuation">{</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">margin-top</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><p>解决办法很多，比如给parent触发BFC；给父元素添加border或者将父元素的margin替换成padding</p><p>4、还有就是可以清楚浮动，当父元素的子元素设置浮动之后，并且父元素此时还没有设定高度，那此时父元素的高度就只有边框，padding或者margin的高度了，解决办法就是给父元素启用BFC，使得其具有BFC的特性，这利用了BFC特性的第四条—–内部的浮动元素也参与计算。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h2&gt;&lt;p&gt;在介绍BFC之前，先了解一下文档流相关的内容。&lt;br&gt;我们常说的文档流包括定位流、浮动流、普通流三种。&lt;/p&gt;
&lt;h4 id</summary>
      
    
    
    
    <category term="HTML&amp;CSS" scheme="https://github.com/categories/HTML-CSS/"/>
    
    
    <category term="HTML&amp;CSS" scheme="https://github.com/tags/HTML-CSS/"/>
    
  </entry>
  
  <entry>
    <title>Javascript执行上下文与闭包</title>
    <link href="https://github.com/2023/06/22/Javascript%E9%97%AD%E5%8C%85%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>https://github.com/2023/06/22/Javascript%E9%97%AD%E5%8C%85%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</id>
    <published>2023-06-21T16:00:00.000Z</published>
    <updated>2023-07-01T08:55:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Javascript执行上下文与闭包"><a href="#Javascript执行上下文与闭包" class="headerlink" title="Javascript执行上下文与闭包"></a>Javascript执行上下文与闭包</h2><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>说闭包之前先解释一下JavaScript的执行上下文，即作用域。</p><ol><li>全局作用域:默认环境，当我们第一次启动程序时，默认创建的全局作用域。</li><li>函数作用域:当执行流进入函数体时就会创建一个本地函数执行上下文，并压入栈中。</li><li>块级作用域:这是es6中新出的作用域，比如for循环、while循环、{}等都属于是块级作用域。</li></ol><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p> 知道了作用域之后，我们来看一下闭包的定义、作用以及使用场景：</p><blockquote><p><strong>闭包定义</strong>：指的是那些引用了另一个函数作用域中变量的<strong>函数</strong>，通常是在嵌套函数中实现的。———-JS红宝书上面的解释</p></blockquote><blockquote><p><strong>个人理解</strong>：该作用域存在对上级作用域当中变量的引用即形成闭包。上级作用域内的变量，因为被下级作用域内引用，而没有被释放。就导致上级作用域内的变量，等到下级作用域执行完以后才正常得到释放（也就是说当解除了对该闭包的所有引用的时候，这个闭包才会被JS的垃圾回收机制回收）。</p></blockquote><p>下面我先给出一个看似闭包但不是闭包的例子，以助后面更好的认识以及理解闭包：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span><span class="token keyword">void</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> outerVariable<span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">innerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>      <span class="token keyword">let</span> innerVariable<span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>outerVariable <span class="token operator">+</span> innerVariable<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">innerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p> 在这个例子中，我们定义了一个外部函数 outerFunction，其中包含一个内部函数 innerFunction。在 outerFunction 中，我们直接调用了 innerFunction，而不是将其作为返回值或赋值给变量。<br>尽管 innerFunction 访问了 outerFunction 中的变量 outerVariable，但由于 innerFunction 在 outerFunction 内部被直接调用，而不是在外部作用域外被调用，它不满足闭包的条件。<br>在这个例子中，innerFunction 没有形成闭包，因为它没有在外部函数作用域外被调用，也没有捕获外部函数作用域的引用。<br>看一下运行效果：<br><img src="/img/context1.png" class="lazyload placeholder" data-srcset="/img/context1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果(伪闭包)"></p><p>可以看到，并没有实现闭包的效果，原因就是三次调用outerFunction函数，之间没有任何关系，每次执行完之后都会将该函数内部的变量回收。<br>下面我们改造一下这个函数，让其变成闭包：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token number">1</span> <span class="token keyword">function</span> <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span><span class="token keyword">Function</span> <span class="token punctuation">{</span><span class="token number">2</span>    <span class="token keyword">let</span> outerVariable <span class="token punctuation">:</span><span class="token keyword">number</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token number">3</span>    <span class="token keyword">function</span> <span class="token function">innerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span><span class="token keyword">number</span><span class="token punctuation">{</span><span class="token number">4</span>      <span class="token keyword">let</span> innerVariable <span class="token punctuation">:</span><span class="token keyword">number</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token number">5</span>       outerVariable <span class="token operator">++</span><span class="token number">6</span>      <span class="token keyword">return</span> <span class="token punctuation">(</span>outerVariable <span class="token operator">+</span> innerVariable<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">7</span>    <span class="token punctuation">}</span><span class="token number">8</span>    <span class="token keyword">return</span> innerFunction<span class="token punctuation">;</span><span class="token number">9</span> <span class="token punctuation">}</span><span class="token number">10</span> <span class="token keyword">const</span> closure <span class="token punctuation">:</span><span class="token keyword">Function</span> <span class="token operator">=</span> <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">11</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">closure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">12</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">closure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">13</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">closure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>先看一下执行的结果：<br><img src="/img/context2.png" class="lazyload placeholder" data-srcset="/img/context2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="修改为闭包之后的执行结果"></p><p>修改之处在于，我们将 innerFunction 返回并赋值给 closure 变量，并在外部调用 closure()。<br>现在，closure 变量中保存的是 innerFunction，它实际上是一个闭包。在调用 closure() 时，innerFunction 可以访问其定义时所在的外部函数 outerFunction 的作用域，即可以访问 outerVariable。这样，我们就创建了一个闭包，使得 innerFunction 在外部函数作用域外仍然能够访问和操作其引用的变量。<br>通过这种方式，我们确保了 innerFunction 在外部函数作用域外被调用时仍然可以访问外部变量，满足了闭包的条件。</p><h3 id="剖析执行过程"><a href="#剖析执行过程" class="headerlink" title="剖析执行过程"></a>剖析执行过程</h3><ul><li>第 1-9行。我们在全局执行上下文中创建了一个新的变量outerFunction，并赋值了一个的函数定义。</li><li>第10行。我们在全局执行上下文中声明了一个名为closure的新变量。</li><li>第11行。我们需要调用outerVariable 函数并将其返回值赋给closure变量。</li><li>第 1-9行。调用函数，创建新的本地执行上下文。</li><li>第2行。在本地执行上下文中，声明一个名为outerVariable 的新变量并赋值为 1;</li><li>第 3-7行。声明一个名为myFunction的新变量，变量在本地执行上下文中声明,变量的内容是为第4-6行所定义。</li><li>第8行。返回innerFunction变量的内容，删除本地执行上下文。变量innerFunction和outerVariable 不再存在。</li><li>第10行。在调用上下文(全局执行上下文)中，outerFunction返回的值赋给了closure，变量closure现在包含一个函数定义内容为outerFunction返回的函数。它不再标记为innerFunction，但它的定义是相同的。这个closure就相当于是闭包的引用，如果该变量一直引用着，则这个闭包会一直存在于内存当中，不会被垃圾回收机制标记为垃圾。</li><li>第11行。查找closure变量，它是一个函数并调用它。它包含前面返回的函数定义，除此之外它还有一个带有变量的闭包</li><li>创建一个新的执行上下文。没有参数，开始执行函数。</li><li>第四行，声明了一个innerVariable变量并赋值20</li><li>第五行，寻找变量outerVariable，在查找当前作用域和上级作用域之前，会先检查一下闭包当中有没有，找到了，然后执行+1操作，然后将其再次存储到闭包当中，待下次使用。</li><li>第六行，返回outerVariable + innerVariable的值，然后销毁当前上下文。</li><li>回到第11行，打印出22.</li><li>接下来就是第12行和第13行就是重复步骤执行第11行代码的执行步骤，实现递增的效果。分别打印出23，24.</li></ul><blockquote><p><strong>闭包的作用</strong>：保护函数的私有变量不受外界干扰；将上级作用域的引用保存下来，实现方法或者属性的私有化；实现模块化</p></blockquote><blockquote><p><strong>闭包的缺点</strong>：使用不当，会造成内存泄漏。</p></blockquote><p>下面是一个使用闭包不当造成内存泄漏的例子：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> outerVariable <span class="token operator">=</span> <span class="token string">'1'</span><span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">innerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> innerVariable <span class="token operator">=</span> <span class="token string">'1'</span><span class="token punctuation">;</span>    <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    outerVariable<span class="token operator">++</span>    innerVariable<span class="token operator">++</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>outerVariable <span class="token operator">+</span> innerVariable<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">innerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在这个例子中，我们定义了一个外部函数 outerFunction，其中包含一个内部函数 innerFunction。在 innerFunction 中，我们使用 setInterval 创建了一个定时器，每秒钟输出 outerVariable 和 innerVariable 的值。<br>由于定时器的回调函数形成了闭包，它可以访问 outerVariable 和 innerVariable，即使 innerFunction 已经执行完毕。这导致闭包中引用的变量无法被垃圾回收，因为定时器仍然持有对闭包的引用。<br>如果我们多次调用 outerFunction，每次调用都会创建一个新的定时器，并且每个定时器都会保留对其自己的闭包的引用。这会导致内存泄漏，因为闭包中引用的变量无法被释放。<br>为了避免内存泄漏，要记得清除定时器。<br><img src="/img/context3.png" class="lazyload placeholder" data-srcset="/img/context3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="执行结果"></p><blockquote><p><strong>闭包的使用场景</strong>：节抖或防流；自执行函数以及回调函数等</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Javascript执行上下文与闭包&quot;&gt;&lt;a href=&quot;#Javascript执行上下文与闭包&quot; class=&quot;headerlink&quot; title=&quot;Javascript执行上下文与闭包&quot;&gt;&lt;/a&gt;Javascript执行上下文与闭包&lt;/h2&gt;&lt;h3 id=&quot;执</summary>
      
    
    
    
    <category term="Typescript" scheme="https://github.com/categories/Typescript/"/>
    
    
    <category term="Typescript" scheme="https://github.com/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>数据结构八大排序之快速排序算法</title>
    <link href="https://github.com/2023/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://github.com/2023/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2023-06-20T16:00:00.000Z</published>
    <updated>2023-07-01T08:58:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构八大排序之快速排序算法"><a href="#数据结构八大排序之快速排序算法" class="headerlink" title="数据结构八大排序之快速排序算法"></a>数据结构八大排序之快速排序算法</h2><blockquote><p>算法思想如下:<br>1、选择基准元素：从待排序的数组中选择一个元素作为基准（pivot）。可以选择数组的第一个元素、最后一个元素或者随机位置的元素作为基准。<br>2、划分操作：将数组中的其他元素按照与基准的大小关系进行划分，将比基准小的元素放在基准的左侧，比基准大的元素放在基准的右侧。同时，基准元素所在的位置也确定了。<br>3、递归排序：对基准元素左侧和右侧的子数组分别进行递归调用快速排序算法，重复上述步骤，直到子数组的长度为1或0（即已经有序）。<br>4、合并结果：递归调用的过程中，子数组的排序会不断地将基准元素放置在正确的位置上，最终整个数组就变为有序。</p></blockquote><h3 id="该算法在前端中的应用"><a href="#该算法在前端中的应用" class="headerlink" title="该算法在前端中的应用"></a>该算法在前端中的应用</h3><p>目前我知道的：js的数组操作方法sort这个api的实现原理就是快速排序算法。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 快速排序算法 </span><span class="token keyword">function</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span><span class="token keyword">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>type<span class="token punctuation">:</span>SortType<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 当数组中只有一项则直接返回 且也是结束递归的出口</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> arr    <span class="token comment" spellcheck="true">// 基准元素的索引</span>    <span class="token keyword">const</span> pivotIndex <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 基准元素的值</span>    <span class="token keyword">const</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>pivotIndex<span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// 将小于基准元素的值放入该数组中</span>    <span class="token keyword">const</span> less<span class="token punctuation">:</span><span class="token keyword">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// 将等于基准元素的值放入该数组中</span>    <span class="token keyword">const</span> equal<span class="token punctuation">:</span><span class="token keyword">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// 将大于基准元素的值放入该数组中</span>    <span class="token keyword">const</span> greater<span class="token punctuation">:</span><span class="token keyword">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// 遍历数组进行切分 </span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> element of arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span>element <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span><span class="token operator">?</span> less<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">:</span>undefined<span class="token punctuation">;</span>        <span class="token punctuation">(</span>element <span class="token operator">></span> pivot<span class="token punctuation">)</span><span class="token operator">?</span> greater<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">:</span>undefined<span class="token punctuation">;</span>        <span class="token punctuation">(</span>element <span class="token operator">==</span> pivot<span class="token punctuation">)</span><span class="token operator">?</span> equal<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">:</span>undefined    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 升序排列 递归</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>type<span class="token operator">==</span>SortType<span class="token punctuation">.</span>Asc<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token function">quickSort</span><span class="token punctuation">(</span>less<span class="token punctuation">,</span>SortType<span class="token punctuation">.</span>Asc<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">...</span>equal<span class="token punctuation">,</span><span class="token operator">...</span><span class="token function">quickSort</span><span class="token punctuation">(</span>greater<span class="token punctuation">,</span>SortType<span class="token punctuation">.</span>Asc<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// 降序排列</span>    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token function">quickSort</span><span class="token punctuation">(</span>greater<span class="token punctuation">,</span>SortType<span class="token punctuation">.</span>Desc<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">...</span>equal<span class="token punctuation">,</span><span class="token operator">...</span><span class="token function">quickSort</span><span class="token punctuation">(</span>less<span class="token punctuation">,</span>SortType<span class="token punctuation">.</span>Desc<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h3 id="算法的使用"><a href="#算法的使用" class="headerlink" title="算法的使用"></a>算法的使用</h3><p>以下面这个数组为例子，算法接收两个参数，第一个参数是待排序的数组，第二个参数指定待排序的规则（升序还是降序).</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> sortArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span></code></pre><p>实现数组升序排列：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> newArr <span class="token operator">=</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>sortArr<span class="token punctuation">,</span>SortType<span class="token punctuation">.</span>Asc<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'使用快速排序实现数组的升序排列'</span><span class="token punctuation">,</span>newArr<span class="token punctuation">)</span></code></pre><p><img src="/img/quick1.png" class="lazyload placeholder" data-srcset="/img/quick1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"></p><p>实现数组降序排列：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> newArr <span class="token operator">=</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>sortArr<span class="token punctuation">,</span>SortType<span class="token punctuation">.</span>Desc<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'使用快速排序实现数组的降序排列'</span><span class="token punctuation">,</span>newArr<span class="token punctuation">)</span></code></pre><p><img src="/img/quick2.png" class="lazyload placeholder" data-srcset="/img/quick2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"></p><h3 id="执行过程详解"><a href="#执行过程详解" class="headerlink" title="执行过程详解"></a>执行过程详解</h3><p>1、选择基准元素：在这个例子中，我们选择数组的第一个元素作为基准，即 5。</p><p>2、划分操作：将数组中的其他元素按照与基准的大小关系进行划分。比基准小的元素放在基准的左侧，比基准大的元素放在基准的右侧。</p><ul><li>第一次划分：将数组划分为 [3, 2, 1]、[5]、[6, 9] 三部分。</li><li>第二次划分：对左侧的子数组 [3, 2, 1] 进行划分，得到 [2, 1]、[3]。</li><li>第三次划分：对右侧的子数组 [6, 9] 进行划分，得到 [6]、[9]。<br>最终的划分结果为 [2, 1, 3, 5, 6, 9]。</li></ul><p>3、递归排序：对基准元素左侧和右侧的子数组分别进行递归调用快速排序算法。<br>对左侧子数组 [2, 1, 3] 进行快速排序。</p><ul><li>选择基准元素 2。<br>划分结果为 [1]、[2]、[3]。<br>对右侧子数组 [6, 9] 进行快速排序。</li><li>选择基准元素 6。<br>划分结果为 [6]、[9]。<br>4、合并结果：递归调用的过程中，子数组的排序会不断地将基准元素放置在正确的位置上，最终整个数组就变为有序。</li></ul><p>最终排序结果为 [1, 2, 3, 5, 6, 9]。<br>选择基准元素，这个元素尽量能将数组划分成两个相同长度的表，长度越接近越好，因为这样可以减少递归的深度，节省性能，</p><p>假如你选择的基准元素不好，我们来调试一下，看一下效果：<br><img src="/img/quick3.png" class="lazyload placeholder" data-srcset="/img/quick3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="调试基准元素"><br>上面的情况是对于数组几乎有序或者已经有序，并且每次基准元素选择数组的第一项的时候，这时候性能开销最大，==其时间复杂度为O(n²)==，当然如果数据量小，那确实无所谓，几乎看不出什么。<br>下面是选择基准元素适中的情况，我们再来看一下运行过程中的状态:<br><img src="/img/quick4.png" class="lazyload placeholder" data-srcset="/img/quick4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="调试基准元素"><br>两图对比一下，第二张图，基准元素选择适中，递归深度减少一半，性能开销小，两个子表几乎相同，==其时间复杂度为O(nlogn)==，这就等同于一颗二叉树，左孩子与右孩子高度相同，它相比于第一张图的单只树(只有右孩子没有左孩子)，那肯定是单只树的性能开销比较大。当数据量过大的时候，受基准元素选择不好以及待排序数组的影响，爆栈都有可能。</p><h3 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h3><p>快速排序算法的性能在八大排序中算得上是优秀的。<br>其平均时间复杂度是O(nlogn) 。其中划分子表的时间复杂度是logn级别，对子表排序的时间复杂度是n级别。<br>空间复杂度是O(n),开辟了三个长度为n的数组，总体为O(n)级别.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据结构八大排序之快速排序算法&quot;&gt;&lt;a href=&quot;#数据结构八大排序之快速排序算法&quot; class=&quot;headerlink&quot; title=&quot;数据结构八大排序之快速排序算法&quot;&gt;&lt;/a&gt;数据结构八大排序之快速排序算法&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;算法思想如</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://github.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://github.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构八大排序之冒泡排序算法</title>
    <link href="https://github.com/2023/06/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://github.com/2023/06/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2023-06-19T16:00:00.000Z</published>
    <updated>2023-07-01T08:58:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构八大排序之冒泡排序算法"><a href="#数据结构八大排序之冒泡排序算法" class="headerlink" title="数据结构八大排序之冒泡排序算法"></a>数据结构八大排序之冒泡排序算法</h2><blockquote><p>需求：用户传入数字类型的数组，并传入排序规则（升序还是降序），实现数组排列，要求使用typescript实现</p></blockquote><p>首先对传入的排序规则参数做一下约束，提高程序健壮性。rt</p><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 定义枚举类型，规定接收的排序规则参数只能是特定的值</span><span class="token keyword">enum</span> SortType <span class="token punctuation">{</span>    Asc <span class="token operator">=</span> <span class="token string">'asc'</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//升序</span>    Desc <span class="token operator">=</span> <span class="token string">'desc'</span> <span class="token comment" spellcheck="true">//降序</span><span class="token punctuation">}</span></code></pre><p>下面是算法的实现过程，它接收两个参数，数组和排序规则</p><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 传入的arr必须为数组类型，type参数表示要升序还是降序，且成员是数字，函数返回值为数字数组</span><span class="token keyword">function</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span><span class="token keyword">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>type<span class="token punctuation">:</span>SortType<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> length <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 用来判断某轮对比是否发生了交换</span>        <span class="token keyword">let</span> isExchange <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 外层循环每执行完一轮都能确定一个元素的最终位置，所以要减去i轮，这里再减1是因为每次都是用下标j和j+1进行比较的</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>length<span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>type<span class="token operator">===</span>SortType<span class="token punctuation">.</span>Asc<span class="token punctuation">)</span><span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">// 使用解构赋值来进行交换，使得代码更加简洁</span>                <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">(</span><span class="token punctuation">[</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>isExchange <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">:</span>undefined            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>type<span class="token operator">===</span>SortType<span class="token punctuation">.</span>Desc<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">(</span><span class="token punctuation">[</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>isExchange <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">:</span>undefined               <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 发生了交换，此时还不能确定排序是否完成,还需要进行下一轮循环</span>            isExchange <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果某轮循环没有发生元素的交换，则表示排序已经完成，直接结束算法执行返回数组</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>isExchange<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">}</span></code></pre><p>当中使用了一个变量isExchange 来判断此轮循环是否发生了元素交换，如果没有，则可以立马结束算法，节省了一定的性能。<br>下面是算法的执行过程，拿【5，3，6，2，9，1】来做演示实现升序排列：<br>第一轮冒泡：<br>比较 5 和 3，交换位置：[3, 5, 6, 2, 9, 1]<br>比较 5 和 6，不交换位置：[3, 5, 6, 2, 9, 1]<br>比较 6 和 2，交换位置：[3, 5, 2, 6, 9, 1]<br>比较 6 和 9，不交换位置：[3, 5, 2, 6, 9, 1]<br>比较 9 和 1，交换位置：[3, 5, 2, 6, 1, 9]<br>第二轮冒泡：<br>比较 3 和 5，不交换位置：[3, 5, 2, 6, 1, 9]<br>比较 5 和 2，交换位置：[3, 2, 5, 6, 1, 9]<br>比较 5 和 6，不交换位置：[3, 2, 5, 6, 1, 9]<br>比较 6 和 1，交换位置：[3, 2, 5, 1, 6, 9]<br>第三轮冒泡：<br>比较 3 和 2，交换位置：[2, 3, 5, 1, 6, 9]<br>比较 3 和 5，不交换位置：[2, 3, 5, 1, 6, 9]<br>比较 5 和 1，交换位置：[2, 3, 1, 5, 6, 9]<br>第四轮冒泡：<br>比较 2 和 3，不交换位置：[2, 3, 1, 5, 6, 9]<br>比较 3 和 1，交换位置：[2, 1, 3, 5, 6, 9]<br>第五轮冒泡：<br>比较 2 和 1，交换位置：[1, 2, 3, 5, 6, 9]<br>最终排序结果应该是：[1, 2, 3, 5, 6, 9]</p><p>下面是该算法的使用以及真机的运行结果：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> sortArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">const</span> newArr <span class="token operator">=</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>sortArr<span class="token punctuation">,</span>SortType<span class="token punctuation">.</span>Asc<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newArr<span class="token punctuation">)</span></code></pre><p><img src="/img/sort1.png" class="lazyload placeholder" data-srcset="/img/sort1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"><br>升序排列</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> newArr <span class="token operator">=</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>sortArr<span class="token punctuation">,</span>SortType<span class="token punctuation">.</span>Desc<span class="token punctuation">)</span></code></pre><p><img src="/img/sort2.png" class="lazyload placeholder" data-srcset="/img/sort2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"><br>降序排列</p><p><strong>总结一下：</strong></p><p>时间复杂度：该算法的最好时间复杂度是O(n),也就是当待排序数组基本按序排列时；最坏时间复杂度为O(n²) ，也就是当数组完全逆序时。平均复杂度为O(n²)。<br>空间复杂度:该算法只创建了常量级别的变量，因此空间复杂度为O(1)。<br>稳定性:当遇到数组当中又两个相同的值的时候，默认不交换位置，因此该算法是稳定的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据结构八大排序之冒泡排序算法&quot;&gt;&lt;a href=&quot;#数据结构八大排序之冒泡排序算法&quot; class=&quot;headerlink&quot; title=&quot;数据结构八大排序之冒泡排序算法&quot;&gt;&lt;/a&gt;数据结构八大排序之冒泡排序算法&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;需求：用户</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://github.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://github.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>组件化，模块化，高内聚和低耦合</title>
    <link href="https://github.com/2023/06/19/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E9%AB%98%E5%86%85%E8%81%9A%E5%92%8C%E4%BD%8E%E8%80%A6%E5%90%88%E7%9B%B8%E5%85%B3/"/>
    <id>https://github.com/2023/06/19/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E9%AB%98%E5%86%85%E8%81%9A%E5%92%8C%E4%BD%8E%E8%80%A6%E5%90%88%E7%9B%B8%E5%85%B3/</id>
    <published>2023-06-18T16:00:00.000Z</published>
    <updated>2023-07-01T08:57:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><blockquote><p>下面是我看了相关的文章与解答总结出来的自己的看法：<br>组件化：对于Vue中中的组件化来说就是整合HTML css js在一个文件中，拥有特定的基础功能<br>我认为组件化开发的好处主要是：<br>1、增加程序的可维护性；<br>2、代码的复用性；<br>3、拆分成单个组件使得每个组件拥有独立的状态和数据，避免了全局变量污染。<br>4、有利于提升渲染性能，实现局部刷新</p></blockquote><p>  对于第一点增加程序的可维护性，尤其当开发大型应用的时候，程序中有大量的变量以及函数，如果不采用组件化的开发，当某个数据发生改变时，就要更新整个页面的内容，浪费的不必要的性能，而且在变量命名的时候也会令人有些恼头，容易造成命名冲突等问题，当项目越来越大的时候，容易出现bug，维护性相对较差。<br>对于第二点来说，当这个项目中很多页面都需要用到相同的组件的时候，如果不采用组件化，那只能重写，造成代码冗余，降低开发效率。<br>对于第三点和第四点来说，Vue的每个组件都拥有独立的数据和状态，是互不干扰的，每个组件是一个watcher，当这个组件中的数据更新的时候，只需重新渲染这一个组件的区域，提升了渲染性能，做到了局部刷新。</p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><blockquote><p>模块化，在前端这边可以单独对css，js等进行单独封装成单个文件，具有某个特定的功能。比如我们项目中的utils工具文件等等<br>模块化的好处：<br>1、方便代码的复用、可读性，减少代码冗余度，提高开发效率，模块化使得代码结构更清晰和模块间的关系更明确，代码更易读、易理解。方便代码的维护和交接。<br>2、可维护性：将大文件拆解成小文件，增加可读性，每个模块可拥有独特的功能，当某个功能出现了问题，可以统一得到解决，也方便找到问题所在位置。</p></blockquote><h2 id="高内聚与低耦合"><a href="#高内聚与低耦合" class="headerlink" title="高内聚与低耦合"></a>高内聚与低耦合</h2><blockquote><p>我理解的高内聚的定义是：组件或模块内部的元素（例如函数、类、方法）彼此关联紧密，<strong>共同完成一个明确的最终目标（功能）</strong>。高内聚意味着组件内的元素具有相似的功能、目的或责任，相关的代码被组织在一起，更容易定位和修改。<br>低耦合：彼此之间相对独立，相互之间的影响较小，<strong>每个组件或者模块单独完成最终目标中的一个小目标（功能）</strong>，且修改一个组件不会对其他组件造成太大的影响，可扩展性与灵活性好。</p></blockquote><p>为了更好的理解，我拿笔记本电脑来举个简单的例子，一个笔记本电脑的实现就等同于一个最终功能–供人使用，它需要硬件和软件来支撑这个最终功能，在这高内聚就体现为电脑的一个个零件，网卡、声卡、显卡、CPU等，它们分别实现某个特定的小功能（专精），当你的网卡坏了，你上不了网了，你第一时间会想到的就是网卡相关的部件以及关联的软件配置是否出现故障，这就体现了上面提到的高内聚更容易定位故障产生的位置，这就是高内聚。<br>但是呢单独一个零件又不能发挥什么作用，这些零件只是具有某个单独的功能，需要各个零件之间的合作与配合，才能组成一个完整的笔记本，才能拥有完整的功能，假如某一天你觉得CPU的性能不太好了，你想升级一下，那你只需要动CPU零件，其他零件受到的影响很小，这就是低耦合。<br>总之，代码的高内聚就是相关功能的代码组合在一起，实现某个特定的小功能，各个小功能需要关联起来才能实现整个大功能。<br>代码的低耦合就是某个特定的小功能的修改与变更对其他模块影响很小，方便针对某个单独的功能进行维护与更新。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;组件化&quot;&gt;&lt;a href=&quot;#组件化&quot; class=&quot;headerlink&quot; title=&quot;组件化&quot;&gt;&lt;/a&gt;组件化&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;下面是我看了相关的文章与解答总结出来的自己的看法：&lt;br&gt;组件化：对于Vue中中的组件化来说就是整合HTM</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://github.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机基础" scheme="https://github.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Grid布局</title>
    <link href="https://github.com/2023/06/17/CSS%20Grid%E5%B8%83%E5%B1%80%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://github.com/2023/06/17/CSS%20Grid%E5%B8%83%E5%B1%80%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-06-16T16:00:00.000Z</published>
    <updated>2023-07-01T08:54:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS-Grid布局的使用"><a href="#CSS-Grid布局的使用" class="headerlink" title="CSS Grid布局的使用"></a>CSS Grid布局的使用</h1><p>介绍之前，先了解一下该门技术的优缺点，看自己是否值得学习，优缺点如下：</p><blockquote><p>优点：CSS Grid布局是一种用于创建网页布局的强大工具。它引入了一个二维网格系统，可以以行和列的形式创建布局，提供了更灵活和精确的控制，并且减少了不必要的一些计算。<br>缺点：兼容性问题：CSS Grid布局是在CSS3中引入的较新的特性，因此旧版本的浏览器可能不支持它或支持有限。</p></blockquote><h2 id="具体的使用"><a href="#具体的使用" class="headerlink" title="具体的使用"></a>具体的使用</h2><p>  <strong>布局效果如下：（利用grid布局）</strong><br> <img src="/img/result.png" class="lazyload placeholder" data-srcset="/img/result.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="效果图"><br>上图利用grid栅格系统，从上到下共三个部分，nav main footer<br>1、nav部分四个button独占一行，先看下nav部分具体的代码，再做介绍：</p><pre class=" language-css"><code class="language-css"><span class="token selector">nav</span><span class="token punctuation">{</span>    <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>    <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">4</span>,<span class="token number">1</span>fr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token property">gap</span><span class="token punctuation">:</span> <span class="token number">10</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面代码的意思是生成一行四列的表格，每列平摊空间，每个格子之间的间距为10px，且nav的宽度会根据屏幕的宽度进行自适应。<br> 2、main部分代码如下：</p><pre class=" language-css"><code class="language-css"><span class="token selector">main</span><span class="token punctuation">{</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">450</span>px<span class="token punctuation">;</span>    <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>    <span class="token property">gap</span><span class="token punctuation">:</span> <span class="token number">20</span>px<span class="token punctuation">;</span>    <span class="token property">grid-template-areas</span><span class="token punctuation">:</span> <span class="token string">'banner banner banner banner banner box-r-top'</span>    <span class="token string">'banner banner banner banner banner box-r-bottom'</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面是main部分，使用grid布局，其中grid-template-areas将main元素分割为两行六列的栅格，并使用命名空间分别占据main的空间，下面是内部的三个元素使用空间的代码：</p><pre class=" language-css"><code class="language-css"><span class="token selector">main li<span class="token pseudo-class">:first-child</span></span><span class="token punctuation">{</span>     <span class="token property">grid-area</span><span class="token punctuation">:</span> banner<span class="token punctuation">;</span>     <span class="token property">background</span><span class="token punctuation">:</span> <span class="token url">url(./banner.jpg)</span><span class="token punctuation">;</span>     <span class="token property">background-size</span><span class="token punctuation">:</span> cover<span class="token punctuation">;</span>     <span class="token property">background-position</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">main button</span><span class="token punctuation">{</span>     <span class="token property">color</span><span class="token punctuation">:</span> <span class="token function">var</span><span class="token punctuation">(</span>--light<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面的grid-area是用来占用空间的，它的值填写grid-template-areas的某个值，比如写banner就会占据main的所有命名空间名称是banner的位置。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSS-Grid布局的使用&quot;&gt;&lt;a href=&quot;#CSS-Grid布局的使用&quot; class=&quot;headerlink&quot; title=&quot;CSS Grid布局的使用&quot;&gt;&lt;/a&gt;CSS Grid布局的使用&lt;/h1&gt;&lt;p&gt;介绍之前，先了解一下该门技术的优缺点，看自己是否值得</summary>
      
    
    
    
    <category term="HTML&amp;CSS" scheme="https://github.com/categories/HTML-CSS/"/>
    
    
    <category term="HTML&amp;CSS" scheme="https://github.com/tags/HTML-CSS/"/>
    
  </entry>
  
</feed>
